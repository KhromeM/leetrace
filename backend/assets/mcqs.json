[
	{
		"slug": "longest-palindrome-subseq",
		"title": "Longest Palindromic Subsequence",
		"leetcodeUrl": "https://leetcode.com/problems/longest-palindromic-subsequence",
		"difficulty": "Medium",
		"topics": ["Dynamic Programming", "String"],
		"content": "Given a string `s`, find the length of the longest palindromic subsequence in `s`.\n\nA subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. A palindrome is a string that reads the same forward and backward.\n\n**Example 1:**\n```\nInput: s = \"bbbab\"\nOutput: 4\nExplanation: One possible longest palindromic subsequence is \"bbbb\".\n```\n\n**Example 2:**\n```\nInput: s = \"cbbd\"\nOutput: 2\nExplanation: One possible longest palindromic subsequence is \"bb\".\n```\n\n**Constraints:**\n- `1 <= s.length <= 1000`\n- `s` consists only of lowercase English letters.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the dynamic programming solution for finding the longest palindromic subsequence in a string of length n?",
				"options": ["O(n^2)", "O(n^3)", "O(n log n)", "O(2^n)"],
				"explanation": "The dynamic programming solution for finding the longest palindromic subsequence involves filling up a 2D table where each entry dp[i][j] represents the length of the longest palindromic subsequence in the substring s[i...j]. This requires iterating over all possible substrings, which results in a time complexity of O(n^2).",
				"answer": "a",
				"topics": ["Dynamic Programming", "Complexity Analysis"]
			},
			{
				"question": "Given the following code for finding the longest palindromic subsequence, which line contains a bug?\n```python\n1. def longestPalindromeSubseq(s):\n2.     n = len(s)\n3.     dp = [[0] * n for _ in range(n)]\n4.     for i in range(n):\n5.         dp[i][i] = 1\n6.     for length in range(2, n+1):\n7.         for i in range(n-length+1):\n8.             j = i + length - 1\n9.             if s[i] == s[j]:\n10.                dp[i][j] = dp[i+1][j-1] + 2\n11.            else:\n12.                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n13.    return dp[0][n-1]\n```",
				"options": [
					"Line 5: dp[i][i] = 1",
					"Line 9: if s[i] == s[j]:",
					"Line 10: dp[i][j] = dp[i+1][j-1] + 2",
					"Line 12: dp[i][j] = max(dp[i+1][j], dp[i][j-1])"
				],
				"explanation": "The bug is in Line 10: dp[i][j] = dp[i+1][j-1] + 2. This line assumes that dp[i+1][j-1] is valid for all cases, but it should only be used if i+1 <= j-1. However, since the loop ensures that length is at least 2, this condition is always satisfied, so there is no bug in this line. The code is correct as is.",
				"answer": "c",
				"topics": ["Dynamic Programming", "Implementation Analysis"]
			},
			{
				"question": "In the context of finding the longest palindromic subsequence, which of the following modifications would optimize space complexity while maintaining the same time complexity?",
				"options": [
					"Use a 1D array instead of a 2D array, updating it in place",
					"Use a hash map to store only necessary subproblems",
					"Use a stack to track the current state of the DP table",
					"Use a queue to process the DP table in a breadth-first manner"
				],
				"explanation": "The space complexity can be optimized from O(n^2) to O(n) by using a 1D array instead of a 2D array. This is possible because each state dp[i][j] only depends on dp[i+1][j-1], dp[i+1][j], and dp[i][j-1], which can be stored in a single array by iterating in reverse order.",
				"answer": "a",
				"topics": ["Dynamic Programming", "Space Optimization"]
			},
			{
				"question": "Consider the following recursive solution with memoization for finding the longest palindromic subsequence:\n```python\n@lru_cache(None)\ndef lps(s, i, j):\n    if i > j:\n        return 0\n    if i == j:\n        return 1\n    if s[i] == s[j]:\n        return 2 + lps(s, i+1, j-1)\n    return max(lps(s, i+1, j), lps(s, i, j-1))\n```\nWhat is the time and space complexity of this solution?",
				"options": [
					"Time: O(n^2), Space: O(n^2)",
					"Time: O(n^2), Space: O(n)",
					"Time: O(2^n), Space: O(n)",
					"Time: O(n^3), Space: O(n^2)"
				],
				"explanation": "The recursive solution with memoization has a time complexity of O(n^2) because it stores results for all subproblems in a 2D table, avoiding redundant calculations. The space complexity is also O(n^2) due to the storage of these subproblems in the cache.",
				"answer": "a",
				"topics": ["Dynamic Programming", "Complexity Analysis"]
			},
			{
				"question": "Which of the following scenarios would make a recursive solution with memoization more efficient than a bottom-up dynamic programming approach for finding the longest palindromic subsequence?",
				"options": [
					"When the input string is very short (n < 10)",
					"When the input string has a lot of repeated characters",
					"When the input string is very long (n > 1000)",
					"When the input string is a palindrome"
				],
				"explanation": "A recursive solution with memoization can be more efficient than a bottom-up approach when the input string has a lot of repeated characters, as it can skip many unnecessary calculations by reusing previously computed results. However, for very long strings, the overhead of recursion might outweigh the benefits, and a bottom-up approach could be more efficient.",
				"answer": "b",
				"topics": ["Dynamic Programming", "Recursion vs Iteration"]
			}
		]
	},
	{
		"slug": "add-two-numbers",
		"title": "Add Two Numbers",
		"leetcodeUrl": "https://leetcode.com/problems/add-two-numbers",
		"difficulty": "Medium",
		"topics": ["Linked List", "Math"],
		"content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number `0` itself.\n\n**Example 1:**\n```\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n```\n\n**Example 2:**\n```\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n```\n\n**Example 3:**\n```\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n```\n\n**Constraints:**\n- The number of nodes in each linked list is in the range `[1,100]`.\n- `0 <= Node.val <= 9`\n- It is guaranteed that the list represents a number that does not have leading zeros.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to solve the 'Add Two Numbers' problem using linked lists?",
				"options": [
					"Iterate through both linked lists simultaneously, adding corresponding digits and managing carry-over.",
					"Convert both linked lists to integers, add them, and convert the result back to a linked list.",
					"Use a stack to reverse the linked lists, add corresponding digits, and reverse the result.",
					"Recursively add corresponding digits from both linked lists, managing carry-over."
				],
				"explanation": "The correct approach is to iterate through both linked lists simultaneously, adding corresponding digits and managing carry-over. This approach directly handles the linked list structure and efficiently manages the carry-over without needing to convert the entire list to an integer or use additional data structures like stacks.",
				"answer": "a",
				"topics": ["Linked List", "Math"]
			},
			{
				"question": "Given the following implementation of the 'Add Two Numbers' problem, which line contains a bug?\n```python\n1. def addTwoNumbers(l1, l2):\n2.     carry = 0\n3.     dummy = ListNode(0)\n4.     current = dummy\n5.     while l1 or l2:\n6.         val1 = l1.val if l1 else 0\n7.         val2 = l2.val if l2 else 0\n8.         total = val1 + val2 + carry\n9.         carry = total // 10\n10.        current.next = ListNode(total % 10)\n11.        current = current.next\n12.        if l1: l1 = l1.next\n13.        if l2: l2 = l2.next\n14.    if carry > 0:\n15.        current.next = ListNode(carry)\n16.    return dummy.next\n```",
				"options": [
					"Line 5: The loop condition should also check for carry.",
					"Line 10: Incorrect calculation of the new node's value.",
					"Line 14: The condition should be 'carry >= 0'.",
					"Line 6: Incorrect handling of l1 being None."
				],
				"explanation": "The bug is in line 5. The loop should continue if there is a carry left to process, even if both l1 and l2 are None. The correct condition should be 'while l1 or l2 or carry'.",
				"answer": "a",
				"topics": ["Linked List", "Implementation Analysis"]
			},
			{
				"question": "In the 'Add Two Numbers' problem, what is the time complexity of the optimal solution?",
				"options": [
					"O(n), where n is the length of the longer linked list.",
					"O(n^2), due to nested iterations over the linked lists.",
					"O(log n), since we are adding numbers digit by digit.",
					"O(1), as we only iterate through the lists once."
				],
				"explanation": "The time complexity is O(n), where n is the length of the longer linked list. We iterate through each node of both linked lists once, performing constant-time operations for each node.",
				"answer": "a",
				"topics": ["Linked List", "Complexity Analysis"]
			},
			{
				"question": "Consider the following code snippet for adding two numbers represented by linked lists. Which line should replace the ??? to correctly handle the carry-over?\n```python\n1. def addTwoNumbers(l1, l2):\n2.     carry = 0\n3.     dummy = ListNode(0)\n4.     current = dummy\n5.     while l1 or l2:\n6.         val1 = l1.val if l1 else 0\n7.         val2 = l2.val if l2 else 0\n8.         total = val1 + val2 + carry\n9.         ???\n10.        current.next = ListNode(total % 10)\n11.        current = current.next\n12.        if l1: l1 = l1.next\n13.        if l2: l2 = l2.next\n14.    if carry > 0:\n15.        current.next = ListNode(carry)\n16.    return dummy.next\n```",
				"options": [
					"carry = total // 10",
					"carry = total % 10",
					"carry = (total + 1) // 10",
					"carry = (total - 1) % 10"
				],
				"explanation": "The correct line to handle the carry-over is 'carry = total // 10'. This calculates the carry for the next iteration by dividing the total by 10, which is the standard way to handle carry in addition.",
				"answer": "a",
				"topics": ["Linked List", "Implementation"]
			},
			{
				"question": "Which of the following modifications would optimize the space complexity of the 'Add Two Numbers' solution?",
				"options": [
					"Use a single linked list to store both input and output values.",
					"Modify the input linked lists in place to store the result.",
					"Use a circular linked list to reduce space usage.",
					"Implement the solution using arrays instead of linked lists."
				],
				"explanation": "Modifying the input linked lists in place to store the result would optimize the space complexity, as it avoids the need for additional nodes in a new linked list. However, this approach may not be feasible if the input lists should remain unchanged.",
				"answer": "b",
				"topics": ["Linked List", "Optimization"]
			}
		]
	},
	{
		"slug": "longest-substring-without-repeating-characters",
		"title": "Longest Substring Without Repeating Characters",
		"leetcodeUrl": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
		"difficulty": "Medium",
		"topics": ["String", "Sliding Window"],
		"content": "Given a string `s`, find the length of the longest substring without repeating characters.\n\n**Example 1:**\n```\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n```\n\n**Example 2:**\n```\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n**Example 3:**\n```\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n```\n\n**Constraints:**\n- `0 <= s.length <= 5 * 10^4`\n- `s` consists of English letters, digits, symbols and spaces.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the optimal solution for finding the longest substring without repeating characters using a sliding window approach?",
				"options": ["O(n^2)", "O(n log n)", "O(n)", "O(1)"],
				"explanation": "The optimal solution uses a sliding window approach with two pointers and a hash map to track the last seen index of each character. This allows us to efficiently move the left pointer to skip over repeated characters, resulting in a linear time complexity of O(n), where n is the length of the string.",
				"answer": "c",
				"topics": ["String", "Sliding Window"]
			},
			{
				"question": "Given the following implementation of finding the longest substring without repeating characters, which line contains a bug?\n```python\n1. def lengthOfLongestSubstring(s):\n2.     char_map = {}\n3.     left = 0\n4.     max_length = 0\n5.     for right in range(len(s)):\n6.         if s[right] in char_map:\n7.             left = max(left, char_map[s[right]] + 1)\n8.         char_map[s[right]] = right\n9.         max_length = max(max_length, right - left)\n10.    return max_length\n```\n",
				"options": [
					"Line 6: if s[right] in char_map:",
					"Line 7: left = max(left, char_map[s[right]] + 1)",
					"Line 9: max_length = max(max_length, right - left)",
					"Line 8: char_map[s[right]] = right"
				],
				"explanation": "The bug is in Line 9: max_length = max(max_length, right - left). The length of the substring should be calculated as right - left + 1, because both right and left are inclusive indices. The correct line should be max_length = max(max_length, right - left + 1).",
				"answer": "c",
				"topics": ["String", "Sliding Window"]
			},
			{
				"question": "In the context of finding the longest substring without repeating characters, which of the following modifications would optimize the space complexity of the solution?",
				"options": [
					"Use a fixed-size array instead of a hash map for character indices",
					"Use a linked list to store characters",
					"Use a stack to track the last seen characters",
					"Use a queue to manage the sliding window"
				],
				"explanation": "Using a fixed-size array instead of a hash map can optimize the space complexity from O(n) to O(1) because the number of possible characters is limited (e.g., 128 for ASCII). This allows us to directly index into the array using character ASCII values, reducing the overhead of hash map operations.",
				"answer": "a",
				"topics": ["String", "Sliding Window"]
			},
			{
				"question": "Consider the following code snippet for finding the longest substring without repeating characters. Which line should replace the ??? to correctly update the left pointer?\n```python\n1. def lengthOfLongestSubstring(s):\n2.     char_map = {}\n3.     left = 0\n4.     max_length = 0\n5.     for right in range(len(s)):\n6.         if s[right] in char_map:\n7.             ???\n8.         char_map[s[right]] = right\n9.         max_length = max(max_length, right - left + 1)\n10.    return max_length\n```\n",
				"options": [
					"left = char_map[s[right]] + 1",
					"left = right + 1",
					"left = max(left, char_map[s[right]])",
					"left = char_map[s[right]]"
				],
				"explanation": "The correct line to update the left pointer is 'left = max(left, char_map[s[right]] + 1)'. This ensures that the left pointer only moves forward and does not move backward, which would incorrectly include repeated characters in the current window.",
				"answer": "a",
				"topics": ["String", "Sliding Window"]
			},
			{
				"question": "Which of the following scenarios would cause the sliding window approach to perform suboptimally compared to other methods for finding the longest substring without repeating characters?",
				"options": [
					"The string is very short (length < 10)",
					"The string consists of all unique characters",
					"The string has a large number of repeating characters",
					"The string is very long with a small number of unique characters"
				],
				"explanation": "The sliding window approach is optimal for strings with a large number of repeating characters because it efficiently skips over repeated sections. However, if the string is very long with a small number of unique characters, the overhead of maintaining the hash map might not be justified compared to simpler methods like brute force, especially if the string length is close to the maximum constraint.",
				"answer": "d",
				"topics": ["String", "Sliding Window"]
			}
		]
	},
	{
		"slug": "median-of-two-sorted-arrays",
		"title": "Median of Two Sorted Arrays",
		"leetcodeUrl": "https://leetcode.com/problems/median-of-two-sorted-arrays",
		"difficulty": "Hard",
		"topics": ["Array", "Binary Search"],
		"content": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.\n\nThe overall runtime complexity should be `O(log(m+n))`.\n\n**Example 1:**\n```\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n```\n\n**Example 2:**\n```\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n```\n\n**Constraints:**\n- `nums1.length == m`\n- `nums2.length == n`\n- `0 <= m <= 1000`\n- `0 <= n <= 1000`\n- `1 <= m + n <= 2000`\n- `-10^6 <= nums1[i], nums2[i] <= 10^6`",
		"rating": 2400,
		"MCQs": [
			{
				"question": "Given the problem of finding the median of two sorted arrays, which of the following approaches correctly achieves the required O(log(m+n)) time complexity?",
				"options": [
					"a) Merge the two arrays and find the median of the merged array.",
					"b) Use a binary search on the smaller array to partition both arrays.",
					"c) Use a min-heap to keep track of the smallest elements.",
					"d) Perform a linear scan to find the median."
				],
				"explanation": "The correct approach is to use binary search on the smaller array to partition both arrays. This method leverages the properties of binary search to achieve the desired O(log(min(m, n))) time complexity, which is effectively O(log(m+n)) when m and n are of similar size. Merging the arrays or using a heap would result in O(m+n) time complexity, which is not efficient enough for this problem.",
				"answer": "b",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "In the binary search approach to find the median of two sorted arrays, what is the key condition to check for a valid partition?",
				"options": [
					"a) The left partition of the first array should be smaller than the right partition of the second array.",
					"b) The maximum of the left partitions should be less than or equal to the minimum of the right partitions.",
					"c) The sum of the left partitions should equal the sum of the right partitions.",
					"d) The length of the left partitions should be equal to the length of the right partitions."
				],
				"explanation": "The key condition for a valid partition is that the maximum of the left partitions should be less than or equal to the minimum of the right partitions. This ensures that the elements on the left are all less than or equal to the elements on the right, which is necessary for correctly finding the median.",
				"answer": "b",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "Consider the following code snippet for finding the median of two sorted arrays. Identify the bug in the implementation:\n```python\n1. def findMedianSortedArrays(nums1, nums2):\n2.     if len(nums1) > len(nums2):\n3.         nums1, nums2 = nums2, nums1\n4.     x, y = len(nums1), len(nums2)\n5.     low, high = 0, x\n6.     while low <= high:\n7.         partitionX = (low + high) // 2\n8.         partitionY = (x + y + 1) // 2 - partitionX\n9.         maxX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n10.        minX = float('inf') if partitionX == x else nums1[partitionX]\n11.        maxY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n12.        minY = float('inf') if partitionY == y else nums2[partitionY]\n13.        if maxX <= minY and maxY <= minX:\n14.            if (x + y) % 2 == 0:\n15.                return (max(maxX, maxY) + min(minX, minY)) / 2\n16.            else:\n17.                return max(maxX, maxY)\n18.        elif maxX > minY:\n19.            high = partitionX - 1\n20.        else:\n21.            low = partitionX + 1\n22.    raise ValueError(\"Input arrays are not sorted\")\n```",
				"options": [
					"a) Line 8: Incorrect calculation of partitionY.",
					"b) Line 13: Incorrect condition for valid partition.",
					"c) Line 15: Incorrect calculation of median for even total length.",
					"d) Line 19: Incorrect adjustment of high index."
				],
				"explanation": "The code correctly calculates partitionY in line 8 as it ensures the total number of elements in the left partitions is equal to the total number of elements in the right partitions. The condition in line 13 is correct for checking valid partitions. The calculation in line 15 correctly averages the maximum of the left partitions and the minimum of the right partitions for even total length. The adjustment of the high index in line 19 is correct when maxX is greater than minY. Therefore, there is no bug in the provided code snippet.",
				"answer": "d",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "What is the time complexity of the binary search approach for finding the median of two sorted arrays, and why is it efficient?",
				"options": [
					"a) O(n), because it iterates through both arrays.",
					"b) O(log(m+n)), because it uses binary search on the combined length.",
					"c) O(log(min(m, n))), because it performs binary search on the smaller array.",
					"d) O(m+n), because it merges the arrays first."
				],
				"explanation": "The time complexity of the binary search approach is O(log(min(m, n))) because it performs binary search on the smaller of the two arrays. This is efficient because it reduces the problem size logarithmically, leveraging the sorted nature of the arrays to find the median without needing to merge them.",
				"answer": "c",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "In the context of finding the median of two sorted arrays, why is it beneficial to always perform binary search on the smaller array?",
				"options": [
					"a) It reduces the number of comparisons needed.",
					"b) It ensures the algorithm runs in constant space.",
					"c) It minimizes the number of iterations needed for convergence.",
					"d) It guarantees that the median is found in the first half of the arrays."
				],
				"explanation": "Performing binary search on the smaller array minimizes the number of iterations needed for convergence. This is because the binary search's efficiency is directly related to the size of the array being searched. By choosing the smaller array, the algorithm ensures that the number of potential partitions to check is minimized, leading to faster convergence.",
				"answer": "c",
				"topics": ["Array", "Binary Search"]
			}
		]
	},
	{
		"slug": "longest-palindromic-substring",
		"title": "Longest Palindromic Substring",
		"leetcodeUrl": "https://leetcode.com/problems/longest-palindromic-substring",
		"difficulty": "Medium",
		"topics": ["String"],
		"content": "Given a string `s`, return the longest palindromic substring in `s`.\n\n**Example 1:**\n```\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n```\n\n**Example 2:**\n```\nInput: s = \"cbbd\"\nOutput: \"bb\"\n```\n\n**Constraints:**\n- `1 <= s.length <= 1000`\n- `s` consists of only digits and English letters.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the dynamic programming approach to find the longest palindromic substring?",
				"options": ["O(n^2)", "O(n^3)", "O(n log n)", "O(n)"],
				"explanation": "The dynamic programming approach involves filling a table where each entry dp[i][j] is true if the substring s[i:j+1] is a palindrome. This requires checking all substrings, leading to a time complexity of O(n^2).",
				"answer": "a",
				"topics": ["String", "Dynamic Programming"]
			},
			{
				"question": "Given this solution for finding the longest palindromic substring:\n```python\ndef longestPalindrome(s):\n    longest = ''\n    for i in range(len(s)):\n        # Expand around center for odd length\n        left, right = i, i\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            if right - left > len(longest):  # BUG: Should be right - left + 1\n                longest = s[left:right]\n            left -= 1\n            right += 1\n        \n        # Even length palindromes\n        left, right = i, i+1\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            if right - left > len(longest):\n                longest = s[left:right]\n            left -= 1\n            right += 1\n    return longest\n```\nWhich line contains the bug and why does it still pass many test cases?",
				"options": [
					"if right - left > len(longest): because it compares length with index difference",
					"longest = s[left:right]: because it slices incorrectly",
					"while left >= 0 and right < len(s): because it checks bounds in wrong order",
					"left, right = i, i: because it starts from wrong indices"
				],
				"explanation": "The bug is in the line `if right - left > len(longest):` because it should be `right - left + 1` to correctly calculate the length of the substring. It still passes many test cases because the condition often holds true for palindromes of odd length, where the center expansion naturally corrects the off-by-one error.",
				"answer": "a",
				"topics": ["String", "Implementation Analysis"]
			},
			{
				"question": "In this solution for merge intervals, which line should replace the ??? to correctly merge overlapping intervals?\n```python\ndef merge(intervals):\n    if not intervals:\n        return []\n    \n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    \n    for interval in intervals[1:]:\n        if ???:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged\n```",
				"options": [
					"interval[0] <= merged[-1][1]",
					"interval[0] <= merged[-1][1] + 1",
					"interval[0] - merged[-1][1] <= 1",
					"merged[-1][1] >= interval[0]"
				],
				"explanation": "The correct condition is `interval[0] <= merged[-1][1]`, which checks if the current interval overlaps with the last merged interval. If it does, they are merged by updating the end of the last interval to the maximum end of both intervals.",
				"answer": "a",
				"topics": ["Array", "Sorting", "Implementation"]
			},
			{
				"question": "Analyze the time and space complexity of this recursive solution, considering both the recursion stack and memoization:\n```python\n@lru_cache(None)\ndef solve(s, i, j):\n    if i >= j:\n        return 0\n    if s[i] == s[j]:\n        return solve(s, i+1, j-1)\n    return 1 + min(solve(s, i+1, j), solve(s, i, j-1))\n```",
				"options": [
					"Time: O(2^n), Space: O(n) - the memoization reduces time to O(n²)",
					"Time: O(n²), Space: O(n²) - due to memoization storing all subproblems",
					"Time: O(n²), Space: O(n) - memoization reuses space but stack grows linearly",
					"Time: O(n²), Space: O(n²) - both recursion stack and cache grow quadratically"
				],
				"explanation": "The time complexity is O(n²) because memoization ensures each subproblem is solved only once, and there are O(n²) subproblems. The space complexity is also O(n²) because the memoization table stores results for all subproblems, and the recursion stack can grow to O(n) depth, but this is dominated by the memoization space.",
				"answer": "b",
				"topics": ["Recursion", "Dynamic Programming", "Complexity Analysis"]
			},
			{
				"question": "Given these three solutions for finding the kth largest element:\nA) QuickSelect algorithm\nB) Heap-based solution\nC) Sorting-based solution\n\nWhich combination of input characteristics would make solution B perform better than both A and C?",
				"options": [
					"Large array size (n > 10⁶), k is close to n/2, elements are randomly distributed",
					"Small array size (n < 10³), k is very small (k < 10), many duplicates present",
					"Medium array size (10⁴ < n < 10⁵), k is close to n, elements are nearly sorted",
					"Large array size (n > 10⁶), k is very small (k < 100), elements are roughly sorted"
				],
				"explanation": "The heap-based solution (B) is efficient when k is small compared to n, as it maintains a min-heap of size k, leading to O(n log k) complexity. This is more efficient than QuickSelect's average O(n) and sorting's O(n log n) when n is large and k is small, as in option d.",
				"answer": "d",
				"topics": ["Heap", "Sorting", "Algorithm Comparison"]
			}
		]
	},
	{
		"slug": "zigzag-conversion",
		"title": "Zigzag Conversion",
		"leetcodeUrl": "https://leetcode.com/problems/zigzag-conversion",
		"difficulty": "Medium",
		"topics": ["String"],
		"content": "The string `\"PAYPALISHIRING\"` is written in a zigzag pattern on a given number of rows like this:\n\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\nAnd then read line by line:\n\n```\nPAHNAPLSIIGYIR\n```\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\n```python\nstring convert(string s, int numRows);\n```\n\n**Example 1:**\n```\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n```\n\n**Example 2:**\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation: \"PINALSIGYAHRPI\"\n```\n\n**Example 3:**\n```\nInput: s = \"A\", numRows = 1\nOutput: \"A\"\n```\n\n**Constraints:**\n- `1 <= s.length <= 1000`\n- `s` consist of English letters (lower-case and upper-case), `','` and `'.'`.\n- `1 <= numRows <= 1000`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the Zigzag Conversion algorithm when implemented by simulating the zigzag pattern row by row?",
				"options": [
					"O(n) where n is the length of the string",
					"O(n^2) where n is the length of the string",
					"O(n log n) where n is the length of the string",
					"O(1) constant time"
				],
				"explanation": "The time complexity is O(n) because each character in the string is processed exactly once to determine its position in the zigzag pattern. The algorithm iterates over the string and places each character in the appropriate row, which is a linear operation relative to the length of the string.",
				"answer": "a",
				"topics": ["String", "Complexity Analysis"]
			},
			{
				"question": "Given the following implementation of the Zigzag Conversion, which line contains a bug that causes incorrect output for certain inputs?\n```python\n1. def convert(s, numRows):\n2.     if numRows == 1 or numRows >= len(s):\n3.         return s\n4.     rows = [''] * numRows\n5.     current_row, step = 0, 1\n6.     for char in s:\n7.         rows[current_row] += char\n8.         if current_row == 0:\n9.             step = 1\n10.        elif current_row == numRows - 1:\n11.            step = -1\n12.        current_row += step\n13.    return ''.join(rows)\n```\nWhich line contains the bug?",
				"options": [
					"Line 2: if numRows == 1 or numRows >= len(s):",
					"Line 4: rows = [''] * numRows",
					"Line 7: rows[current_row] += char",
					"Line 10: elif current_row == numRows - 1:"
				],
				"explanation": "The bug is in Line 2: `if numRows == 1 or numRows >= len(s):`. The condition `numRows >= len(s)` is incorrect because it should not return the string as is when the number of rows is greater than or equal to the length of the string. The correct condition should only check if `numRows == 1`.",
				"answer": "a",
				"topics": ["String", "Implementation Analysis"]
			},
			{
				"question": "In the Zigzag Conversion problem, which data structure is most appropriate for storing the characters of each row during the conversion process?",
				"options": [
					"Array of strings",
					"Linked list of characters",
					"Hash map with row indices as keys",
					"Stack for each row"
				],
				"explanation": "An array of strings is most appropriate because it allows direct access to each row and efficient concatenation of characters. Each index in the array corresponds to a row in the zigzag pattern, and characters are appended to the appropriate string as they are processed.",
				"answer": "a",
				"topics": ["String", "Data Structures"]
			},
			{
				"question": "Consider the following code snippet for Zigzag Conversion. Which line should replace the ??? to correctly handle the case when numRows is greater than the length of the string?\n```python\n1. def convert(s, numRows):\n2.     if numRows == 1 or ???:\n3.         return s\n4.     rows = [''] * numRows\n5.     current_row, step = 0, 1\n6.     for char in s:\n7.         rows[current_row] += char\n8.         if current_row == 0:\n9.             step = 1\n10.        elif current_row == numRows - 1:\n11.            step = -1\n12.        current_row += step\n13.    return ''.join(rows)\n```",
				"options": [
					"numRows >= len(s)",
					"numRows > len(s)",
					"numRows <= 1",
					"numRows < 2"
				],
				"explanation": "The correct line to replace ??? is `numRows <= 1`. This condition ensures that if there is only one row or the number of rows is less than or equal to 1, the function returns the string as is, since no zigzag pattern is needed.",
				"answer": "c",
				"topics": ["String", "Edge Cases"]
			},
			{
				"question": "Which of the following scenarios would cause the Zigzag Conversion algorithm to perform suboptimally if not handled correctly?",
				"options": [
					"When the input string is empty",
					"When the number of rows is 1",
					"When the number of rows is greater than the length of the string",
					"When the input string contains only one unique character"
				],
				"explanation": "When the number of rows is greater than the length of the string, the algorithm might perform unnecessary operations if not handled correctly. The optimal approach is to return the string as is when the number of rows is greater than or equal to the length of the string, as no zigzag pattern can be formed.",
				"answer": "c",
				"topics": ["String", "Optimization"]
			}
		]
	},
	{
		"slug": "reverse-integer",
		"title": "Reverse Integer",
		"leetcodeUrl": "https://leetcode.com/problems/reverse-integer",
		"difficulty": "Medium",
		"topics": ["Math"],
		"content": "Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-2^31, 2^31 - 1]`, then return `0`. Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n**Example 1:**\n```\nInput: x = 123\nOutput: 321\n```\n\n**Example 2:**\n```\nInput: x = -123\nOutput: -321\n```\n\n**Example 3:**\n```\nInput: x = 120\nOutput: 21\n```\n\n**Constraints:**\n- `-2^31 <= x <= 2^31 - 1`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of reversing an integer by converting it to a string, reversing the string, and converting it back to an integer?",
				"options": [
					"O(n), where n is the number of digits in the integer",
					"O(log n), where n is the integer value",
					"O(1), since the number of digits is constant",
					"O(n^2), due to string operations"
				],
				"explanation": "The time complexity is O(n), where n is the number of digits in the integer. This is because converting the integer to a string, reversing the string, and converting it back to an integer all involve operations that are linear in the number of digits.",
				"answer": "a",
				"topics": ["Math", "Time Complexity"]
			},
			{
				"question": "Given the following code to reverse an integer, which line contains a bug that could cause incorrect results for certain inputs?\n```python\n1. def reverse(x):\n2.     sign = -1 if x < 0 else 1\n3.     x *= sign\n4.     reversed_x = 0\n5.     while x:\n6.         reversed_x = reversed_x * 10 + x % 10\n7.         x //= 10\n8.     return sign * reversed_x\n```\nWhich line contains the bug?",
				"options": [
					"Line 2: Incorrect sign determination",
					"Line 3: Incorrect handling of negative numbers",
					"Line 6: Potential overflow not handled",
					"Line 8: Incorrect return value calculation"
				],
				"explanation": "The bug is in line 6. The code does not handle potential overflow when reversing the integer. If the reversed integer exceeds the 32-bit signed integer range, it should return 0 instead of the reversed value.",
				"answer": "c",
				"topics": ["Math", "Implementation Analysis"]
			},
			{
				"question": "Which of the following modifications would correctly handle overflow in the integer reversal code?\n```python\n1. def reverse(x):\n2.     sign = -1 if x < 0 else 1\n3.     x *= sign\n4.     reversed_x = 0\n5.     while x:\n6.         if reversed_x > (2**31 - 1) // 10:\n7.             return 0\n8.         reversed_x = reversed_x * 10 + x % 10\n9.         x //= 10\n10.    return sign * reversed_x\n```\nWhich line should be added or modified?",
				"options": [
					"Add line 6: if reversed_x > (2**31 - 1) // 10:",
					"Modify line 8: reversed_x = reversed_x * 10 + x % 10",
					"Add line 7: return 0 if reversed_x > 2**31 - 1 else reversed_x",
					"Modify line 10: return 0 if reversed_x > 2**31 - 1 else sign * reversed_x"
				],
				"explanation": "Adding the check in line 6 ensures that before multiplying by 10 and adding the next digit, we verify that the current reversed_x will not overflow when multiplied by 10. This prevents overflow by returning 0 if the condition is met.",
				"answer": "a",
				"topics": ["Math", "Optimization Modifications"]
			},
			{
				"question": "Consider the following three methods for reversing an integer:\nA) Convert to string, reverse, and convert back\nB) Use arithmetic operations to reverse\nC) Use a stack to reverse digits\nWhich method is most efficient in terms of space complexity?",
				"options": [
					"Method A: Convert to string, reverse, and convert back",
					"Method B: Use arithmetic operations to reverse",
					"Method C: Use a stack to reverse digits",
					"All methods have the same space complexity"
				],
				"explanation": "Method B, which uses arithmetic operations, is the most space-efficient because it operates in O(1) space. It does not require additional data structures like a string or stack, which would require O(n) space where n is the number of digits.",
				"answer": "b",
				"topics": ["Math", "Space Complexity"]
			},
			{
				"question": "Analyze the time and space complexity of the following integer reversal algorithm:\n```python\n1. def reverse(x):\n2.     sign = -1 if x < 0 else 1\n3.     x *= sign\n4.     reversed_x = 0\n5.     while x:\n6.         reversed_x = reversed_x * 10 + x % 10\n7.         x //= 10\n8.     return sign * reversed_x\n```\nWhat are the time and space complexities?",
				"options": [
					"Time: O(n), Space: O(1)",
					"Time: O(log n), Space: O(1)",
					"Time: O(n), Space: O(n)",
					"Time: O(log n), Space: O(n)"
				],
				"explanation": "The time complexity is O(log n) because the number of digits in the integer is proportional to log n, where n is the integer value. The space complexity is O(1) because no additional space is used beyond a few variables.",
				"answer": "b",
				"topics": ["Math", "Time Complexity", "Space Complexity"]
			}
		]
	},
	{
		"slug": "string-to-integer-atoi",
		"title": "String to Integer (atoi)",
		"leetcodeUrl": "https://leetcode.com/problems/string-to-integer-atoi",
		"difficulty": "Medium",
		"topics": ["String", "Math"],
		"content": "Implement the `myAtoi(strings)` function, which converts a string to a 32-bits signed integer (similar to C/C++'s `atoi` function). The algorithm for `myAtoi(strings)` is as follows:\n\n1. Read and ignore any leading whitespace.\n\n2. Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n\n3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n\n4. Convert these digits into an integer (i.e., `\"123\" -> 123`, `\"0032\" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n\n5. If the integer is out of the 32-bits signed integer range `[-2^31, 2^31 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-2^31` should be clamped to `-2^31`, and integers greater than `2^31 - 1` should be clamped to `2^31 - 1`.\n\n6. Return the integer as the final result.\n\n**Note:** Only the space character `' '` is considered a whitespace character. Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n\n**Example 1:**\n```\nInput: s = \"42\"\nOutput: 42\n```\n\n**Example 2:**\n```\nInput: s = \"-42\"\nOutput: -42\n```\n\n**Example 3:**\n```\nInput: s = \"4193 with words\"\nOutput: 4193\n```\n\n**Constraints:**\n- `0 <= s.length <= 200`\n- `s` consists of English letters (lower-case and upper-case), digits (0-9), `' '`, `'+'`, `'-'`, and `'.'.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a core concept in implementing the `myAtoi` function?",
				"options": [
					"Handling leading whitespace and optional sign",
					"Using a stack to store digits",
					"Implementing a binary search to find the integer",
					"Utilizing a hash map to map characters to digits"
				],
				"explanation": "The `myAtoi` function requires handling leading whitespace and an optional sign ('+' or '-'). It then reads digits until a non-digit character is encountered. The other options do not apply to this problem as it does not involve data structures like stacks or hash maps, nor does it require binary search.",
				"answer": "a",
				"topics": ["String", "Math"]
			},
			{
				"question": "Given the following implementation of `myAtoi`, which line contains a bug that could cause incorrect results?\n```python\n1. def myAtoi(s):\n2.     s = s.strip()\n3.     if not s:\n4.         return 0\n5.     sign = 1\n6.     index = 0\n7.     if s[0] == '-':\n8.         sign = -1\n9.         index += 1\n10.    elif s[0] == '+':\n11.        index += 1\n12.    result = 0\n13.    while index < len(s) and s[index].isdigit():\n14.        result = result * 10 + int(s[index])\n15.        index += 1\n16.    result *= sign\n17.    return max(min(result, 2**31 - 1), -2**31)\n```",
				"options": [
					"Line 2: s = s.strip()",
					"Line 13: while index < len(s) and s[index].isdigit():",
					"Line 14: result = result * 10 + int(s[index])",
					"Line 17: return max(min(result, 2**31 - 1), -2**31)"
				],
				"explanation": "The bug is in line 17. The clamping logic is correct, but it should be applied before multiplying by the sign. If the result is clamped after applying the sign, it could incorrectly clamp negative numbers to positive limits.",
				"answer": "d",
				"topics": ["String", "Math", "Implementation Analysis"]
			},
			{
				"question": "In the `myAtoi` function, what is the time complexity of converting the string to an integer?",
				"options": [
					"O(n), where n is the length of the string",
					"O(log n), where n is the length of the string",
					"O(1), constant time regardless of input size",
					"O(n^2), due to nested operations"
				],
				"explanation": "The time complexity is O(n) because the function processes each character of the string at most once, iterating through the string to handle whitespace, sign, and digits.",
				"answer": "a",
				"topics": ["String", "Math", "Complexity Analysis"]
			},
			{
				"question": "Consider the following scenarios. Which one would cause the `myAtoi` function to return 0?",
				"options": [
					"The input string is \"   \".",
					"The input string is \"-\".",
					"The input string is \"+\".",
					"All of the above."
				],
				"explanation": "All the given scenarios would cause the `myAtoi` function to return 0. An input string with only whitespace, or just a sign without any digits, results in no valid integer being parsed, leading to a return value of 0.",
				"answer": "d",
				"topics": ["String", "Math", "Edge Cases"]
			},
			{
				"question": "Which of the following modifications would optimize the `myAtoi` function to handle very large input strings more efficiently?",
				"options": [
					"Use a deque to store digits for faster access",
					"Implement early termination if the result exceeds 32-bit limits",
					"Use a hash map to store previously seen characters",
					"Convert the string to a list of characters for faster iteration"
				],
				"explanation": "Implementing early termination if the result exceeds 32-bit limits can optimize the function. Once the result is out of bounds, further processing is unnecessary, allowing the function to return early.",
				"answer": "b",
				"topics": ["String", "Math", "Optimization"]
			}
		]
	},
	{
		"slug": "palindrome-number",
		"title": "Palindrome Number",
		"leetcodeUrl": "https://leetcode.com/problems/palindrome-number",
		"difficulty": "Easy",
		"topics": ["Math"],
		"content": "Given an integer `x`, return `true` if `x` is a palindrome, and `false` otherwise.\n\n**Example 1:**\n```\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n```\n\n**Example 2:**\n```\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n```\n\n**Example 3:**\n```\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n```\n\n**Constraints:**\n- `-231 <= x <= 231 - 1`\n\n**Follow-up:**\nCould you solve it without converting the integer to a string?",
		"rating": 1200,
		"MCQs": [
			{
				"question": "Which of the following statements is true about checking if an integer is a palindrome without converting it to a string?",
				"options": [
					"You can reverse the integer and compare it to the original.",
					"You can use a stack to store digits and compare them.",
					"You can compare the first and last digits iteratively.",
					"You can use a queue to store digits and compare them."
				],
				"explanation": "To check if an integer is a palindrome without converting it to a string, you can reverse the integer and compare it to the original. This involves extracting digits from the end and building a new number. Using a stack or queue would require additional space and is not necessary for this problem.",
				"answer": "a",
				"topics": ["Math"]
			},
			{
				"question": "Given the following code to check if an integer is a palindrome, identify the bug:\n```python\n1. def isPalindrome(x):\n2.     if x < 0:\n3.         return False\n4.     original = x\n5.     reversed_num = 0\n6.     while x > 0:\n7.         reversed_num = reversed_num * 10 + x % 10\n8.         x //= 10\n9.     return original == reversed_num\n```\nWhat is the issue with this implementation?",
				"options": [
					"The code does not handle negative numbers correctly.",
					"The code does not handle numbers ending with zero correctly.",
					"The code does not handle very large numbers correctly.",
					"The code does not handle single-digit numbers correctly."
				],
				"explanation": "The code correctly handles negative numbers by returning False immediately. It also correctly handles single-digit numbers and large numbers. However, it does not handle numbers ending with zero correctly, as reversing such numbers will lose the leading zeros, making the comparison fail.",
				"answer": "b",
				"topics": ["Math", "Implementation"]
			},
			{
				"question": "Consider the following code snippet for checking if an integer is a palindrome:\n```python\n1. def isPalindrome(x):\n2.     if x < 0 or (x % 10 == 0 and x != 0):\n3.         return False\n4.     reversed_half = 0\n5.     while x > reversed_half:\n6.         reversed_half = reversed_half * 10 + x % 10\n7.         x //= 10\n8.     return x == reversed_half or x == reversed_half // 10\n```\nWhat is the purpose of the condition `x == reversed_half // 10` in line 8?",
				"options": [
					"To handle numbers with an odd number of digits.",
					"To handle numbers with an even number of digits.",
					"To handle negative numbers.",
					"To handle numbers ending with zero."
				],
				"explanation": "The condition `x == reversed_half // 10` is used to handle numbers with an odd number of digits. When the number of digits is odd, the middle digit does not affect the palindrome property, so it is removed by integer division by 10.",
				"answer": "a",
				"topics": ["Math", "Implementation"]
			},
			{
				"question": "What is the time complexity of the algorithm that checks if an integer is a palindrome by reversing half of its digits?",
				"options": [
					"O(n), where n is the number of digits in the integer.",
					"O(log n), where n is the integer value.",
					"O(n^2), where n is the number of digits in the integer.",
					"O(1), constant time complexity."
				],
				"explanation": "The time complexity of the algorithm is O(log n), where n is the integer value. This is because the number of digits in the integer is proportional to log n, and the algorithm processes each digit once.",
				"answer": "b",
				"topics": ["Math", "Complexity Analysis"]
			}
		]
	},
	{
		"slug": "regular-expression-matching",
		"title": "Regular Expression Matching",
		"leetcodeUrl": "https://leetcode.com/problems/regular-expression-matching",
		"difficulty": "Hard",
		"topics": ["Dynamic Programming", "String"],
		"content": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `.` and `*` where:\n- `.` Matches any single character.\n- `*` Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n**Example 1:**\n```\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n```\n\n**Example 2:**\n```\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: `*` means zero or more of the preceding element, `a`. Therefore, by repeating `a` once, it becomes \"aa\".\n```\n\n**Example 3:**\n```\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n```\n\n**Constraints:**\n- `1 <= s.length <= 20`\n- `1 <= p.length <= 20`\n- `s` contains only lowercase English letters.\n- `p` contains only lowercase English letters, '.', and '*'.\n- It is guaranteed that for each appearance of the character `*`, there will be a previous valid character to match.",
		"rating": 2400,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to solve the regular expression matching problem using dynamic programming?",
				"options": [
					"a) Use a 2D DP table where dp[i][j] represents if s[0:i] matches p[0:j].",
					"b) Use a 1D DP array where dp[i] represents if s[0:i] matches p[0:i].",
					"c) Use a recursive approach with memoization to store results of subproblems.",
					"d) Use a greedy approach to match characters one by one."
				],
				"explanation": "The correct approach is to use a 2D DP table where dp[i][j] represents if the substring s[0:i] matches the substring p[0:j]. This allows us to consider all possible matches and handle the '*' operator correctly by considering zero or more occurrences of the preceding element. A 1D DP array would not be sufficient to capture the dependencies between different parts of the pattern and string. A recursive approach with memoization is also valid but typically less efficient than a DP table for this problem. A greedy approach would not work due to the complexity introduced by the '*' operator.",
				"answer": "a",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "In the following code for regular expression matching, which line contains a bug?\n```python\n1. def isMatch(s, p):\n2.     dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n3.     dp[0][0] = True\n4.     for i in range(1, len(p) + 1):\n5.         if p[i-1] == '*':\n6.             dp[0][i] = dp[0][i-2]\n7.     for i in range(1, len(s) + 1):\n8.         for j in range(1, len(p) + 1):\n9.             if p[j-1] == '.' or p[j-1] == s[i-1]:\n10.                dp[i][j] = dp[i-1][j-1]\n11.            elif p[j-1] == '*':\n12.                dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (p[j-2] == s[i-1] or p[j-2] == '.'))\n13.    return dp[len(s)][len(p)]\n```",
				"options": [
					"a) Line 5: if p[i-1] == '*': because it should check for valid preceding character.",
					"b) Line 6: dp[0][i] = dp[0][i-2] because it assumes '*' can match zero elements without checking bounds.",
					"c) Line 12: dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (p[j-2] == s[i-1] or p[j-2] == '.')) because it incorrectly handles the '*' operator.",
					"d) Line 10: dp[i][j] = dp[i-1][j-1] because it doesn't account for all matching scenarios."
				],
				"explanation": "The bug is in line 6: dp[0][i] = dp[0][i-2]. This line assumes that '*' can match zero elements without checking if i-2 is a valid index, which can lead to an index out of bounds error. The correct approach should ensure that i-2 is non-negative before accessing dp[0][i-2].",
				"answer": "b",
				"topics": ["Dynamic Programming", "String", "Implementation Analysis"]
			},
			{
				"question": "Consider the following recursive solution for regular expression matching with memoization:\n```python\n@lru_cache(None)\n1. def isMatch(s, p):\n2.     if not p:\n3.         return not s\n4.     first_match = bool(s) and p[0] in {s[0], '.'}\n5.     if len(p) >= 2 and p[1] == '*':\n6.         return (isMatch(s, p[2:]) or\n7.                 (first_match and isMatch(s[1:], p)))\n8.     else:\n9.         return first_match and isMatch(s[1:], p[1:])\n```\nWhat is the time and space complexity of this solution?",
				"options": [
					"a) Time: O(2^n), Space: O(n) - due to recursion depth.",
					"b) Time: O(n*m), Space: O(n*m) - due to memoization storing all subproblems.",
					"c) Time: O(n*m), Space: O(n) - memoization reuses space but stack grows linearly.",
					"d) Time: O(n^2), Space: O(n^2) - both recursion stack and cache grow quadratically."
				],
				"explanation": "The time complexity is O(n*m) because each subproblem is solved once and stored in the cache, where n is the length of s and m is the length of p. The space complexity is also O(n*m) because the cache stores results for each combination of indices in s and p. The recursion stack space is not significant due to memoization, which prevents redundant recursive calls.",
				"answer": "b",
				"topics": ["Dynamic Programming", "String", "Complexity Analysis"]
			},
			{
				"question": "Which of the following modifications would optimize the space usage of a dynamic programming solution for regular expression matching?",
				"options": [
					"a) Use a 1D DP array instead of a 2D DP table, updating it in place.",
					"b) Use a stack to simulate the recursion and avoid using a DP table.",
					"c) Use bit manipulation to store multiple states in a single integer.",
					"d) Use a rolling array technique to reduce space complexity from O(n*m) to O(n)."
				],
				"explanation": "Using a rolling array technique can reduce the space complexity from O(n*m) to O(n) by only keeping track of the current and previous row of the DP table. This is possible because each state in the DP table only depends on the current and previous states, allowing us to overwrite the previous row as we compute the current row.",
				"answer": "d",
				"topics": ["Dynamic Programming", "String", "Optimization"]
			},
			{
				"question": "Given the following pattern and string, which solution would perform best in terms of time complexity?\nPattern: \"a*b*c*\"\nString: \"aaabbbccc\"\nOptions:\nA) Recursive solution with memoization\nB) Iterative DP solution with a 2D table\nC) Greedy approach\nD) Backtracking without memoization",
				"options": [
					"a) A) Recursive solution with memoization",
					"b) B) Iterative DP solution with a 2D table",
					"c) C) Greedy approach",
					"d) D) Backtracking without memoization"
				],
				"explanation": "The iterative DP solution with a 2D table (option B) would perform best in terms of time complexity for this specific pattern and string. The pattern \"a*b*c*\" can be efficiently matched using a DP table, which systematically checks all possible matches and handles the '*' operator correctly. The recursive solution with memoization (option A) is also efficient but typically has higher overhead due to recursion. The greedy approach (option C) and backtracking without memoization (option D) are less efficient due to potential redundant checks and lack of systematic state storage.",
				"answer": "b",
				"topics": ["Dynamic Programming", "String", "Solution Comparison"]
			}
		]
	},
	{
		"slug": "container-with-most-water",
		"title": "Container With Most Water",
		"leetcodeUrl": "https://leetcode.com/problems/container-with-most-water",
		"difficulty": "Medium",
		"topics": ["Array", "Two Pointers"],
		"content": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `i-th` line are (`i`, `0`) and (`i`, `height[i]`). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container.\n\n**Example 1:**\n```\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n```\n\n**Example 2:**\n```\nInput: height = [1,1]\nOutput: 1\n```\n\n**Constraints:**\n- `n == height.length`\n- `2 <= n <= 10^5`\n- `0 <= height[i] <= 10^4`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is the most efficient approach to solve the 'Container With Most Water' problem?",
				"options": [
					"a) Brute force approach with two nested loops",
					"b) Dynamic programming approach",
					"c) Two pointers approach",
					"d) Binary search approach"
				],
				"explanation": "The most efficient approach to solve the 'Container With Most Water' problem is the two pointers approach. This method involves initializing two pointers at the beginning and end of the array and moving them towards each other, calculating the area at each step, and updating the maximum area found. This approach works in O(n) time complexity, which is optimal for this problem.",
				"answer": "c",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following implementation of the 'Container With Most Water' problem, identify the bug:\n```python\n1. def maxArea(height):\n2.     max_area = 0\n3.     left, right = 0, len(height) - 1\n4.     while left < right:\n5.         width = right - left\n6.         current_area = min(height[left], height[right]) * width\n7.         max_area = max(max_area, current_area)\n8.         if height[left] < height[right]:\n9.             left += 1\n10.        else:\n11.            right -= 1\n12.    return max_area\n```\nWhy might this implementation fail for some test cases?",
				"options": [
					"a) The condition in line 8 should be 'height[left] <= height[right]'",
					"b) The calculation of 'current_area' in line 6 is incorrect",
					"c) The loop condition in line 4 should be 'left <= right'",
					"d) The initialization of 'max_area' in line 2 should be 'float('-inf')'"
				],
				"explanation": "The implementation is correct as it stands. The condition in line 8 'height[left] < height[right]' is appropriate because it ensures that the pointer moves past the shorter line, which is necessary to potentially find a larger area. The other options suggest changes that would either not affect the correctness or would introduce errors.",
				"answer": "a",
				"topics": ["Array", "Two Pointers", "Implementation Analysis"]
			},
			{
				"question": "Consider the following code snippet for solving the 'Container With Most Water' problem. Which line should be added to ensure the function returns the correct maximum area?\n```python\n1. def maxArea(height):\n2.     max_area = 0\n3.     left, right = 0, len(height) - 1\n4.     while left < right:\n5.         width = right - left\n6.         current_area = min(height[left], height[right]) * width\n7.         max_area = max(max_area, current_area)\n8.         ???\n9.     return max_area\n```",
				"options": [
					"a) if height[left] < height[right]: left += 1 else: right -= 1",
					"b) if height[left] > height[right]: left += 1 else: right -= 1",
					"c) if height[left] <= height[right]: left += 1 else: right -= 1",
					"d) if height[left] >= height[right]: left += 1 else: right -= 1"
				],
				"explanation": "The correct line to add is 'if height[left] < height[right]: left += 1 else: right -= 1'. This ensures that the pointer moves past the shorter line, which is necessary to potentially find a larger area. Moving the pointer past the taller line would not help in finding a larger area.",
				"answer": "a",
				"topics": ["Array", "Two Pointers", "Missing Line Completion"]
			},
			{
				"question": "Analyze the time complexity of the two pointers approach for the 'Container With Most Water' problem. What is the time complexity?",
				"options": ["a) O(n^2)", "b) O(n log n)", "c) O(n)", "d) O(log n)"],
				"explanation": "The time complexity of the two pointers approach is O(n). This is because each element in the array is visited at most once by either the left or the right pointer, resulting in a linear time complexity.",
				"answer": "c",
				"topics": ["Array", "Two Pointers", "Complexity Analysis"]
			},
			{
				"question": "In the 'Container With Most Water' problem, why is the two pointers approach more efficient than a brute force approach?",
				"options": [
					"a) It reduces the time complexity from O(n^2) to O(n) by avoiding unnecessary comparisons.",
					"b) It uses additional space to store intermediate results, which speeds up the computation.",
					"c) It leverages sorting to quickly find the maximum area.",
					"d) It uses recursion to break down the problem into smaller subproblems."
				],
				"explanation": "The two pointers approach is more efficient because it reduces the time complexity from O(n^2) to O(n) by avoiding unnecessary comparisons. Instead of checking all possible pairs of lines, it strategically moves the pointers to find the maximum area in a single pass through the array.",
				"answer": "a",
				"topics": ["Array", "Two Pointers", "Solution Comparison"]
			}
		]
	},
	{
		"slug": "integer-to-roman",
		"title": "12. Integer to Roman",
		"leetcodeUrl": "https://leetcode.com/problems/integer-to-roman",
		"difficulty": "Medium",
		"topics": ["Math"],
		"content": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n| Symbol | Value |\n|--------|-------|\n| `I`    | 1     |\n| `V`    | 5     |\n| `X`    | 10    |\n| `L`    | 50    |\n| `C`    | 100   |\n| `D`    | 500   |\n| `M`    | 1000  |\n\nFor example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X` + `II`. The number `27` is written as `XXVII`, which is `XX` + `V` + `II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`.\n\nThere are six instances where subtraction is used:\n- `I` can be placed before `V` (5) and `X` (10) to make `4` and `9`.\n- `X` can be placed before `L` (50) and `C` (100) to make `40` and `90`.\n- `C` can be placed before `D` (500) and `M` (1000) to make `400` and `900`.\n\nGiven an integer, convert it to a roman numeral.\n\n**Example 1:**\n```\nInput: num = 3\nOutput: \"III\"\nExplanation: 3 is represented as 3 ones.\n```\n\n**Example 2:**\n```\nInput: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.\n```\n\n**Example 3:**\n```\nInput: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n```\n\n**Constraints:**\n- `1 <= num <= 3999`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct implementation for converting an integer to a Roman numeral?",
				"options": [
					"a) Use a dictionary to map each integer to its Roman numeral and iterate from 1 to num.",
					"b) Use a list of tuples with integer values and corresponding Roman numerals, iterating from largest to smallest.",
					"c) Use a recursive function to break down the number into its Roman numeral components.",
					"d) Use a stack to push Roman numeral symbols and pop them to form the final string."
				],
				"explanation": "The correct approach is to use a list of tuples with integer values and corresponding Roman numerals, iterating from largest to smallest. This allows you to subtract the largest possible value from the number and append the corresponding Roman numeral to the result string until the number is reduced to zero. This method efficiently handles the subtraction cases like IV, IX, etc.",
				"answer": "b",
				"topics": ["Math", "Greedy Algorithms"]
			},
			{
				"question": "In the following implementation of integer to Roman numeral conversion, which line contains a bug?\n```python\n1. def intToRoman(num):\n2.     val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n3.     syms = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n4.     roman_num = ''\n5.     i = 0\n6.     while num > 0:\n7.         for _ in range(num // val[i]):\n8.             roman_num += syms[i]\n9.             num -= val[i]\n10.        i += 1\n11.    return roman_num\n```",
				"options": [
					"a) Line 7: for _ in range(num // val[i]): because it may not handle zero correctly.",
					"b) Line 8: roman_num += syms[i] because it might append incorrect symbols.",
					"c) Line 9: num -= val[i] because it might not decrement num correctly.",
					"d) Line 10: i += 1 because it might skip necessary values."
				],
				"explanation": "The implementation is correct. The loop in line 7 correctly iterates the number of times the current value fits into num, appending the corresponding Roman numeral symbol and decrementing num accordingly. The index i is incremented to move to the next largest Roman numeral value.",
				"answer": "b",
				"topics": ["Math", "Implementation"]
			},
			{
				"question": "Given these three solutions for converting an integer to a Roman numeral:\nA) Iterative approach using a list of tuples\nB) Recursive approach breaking down the number\nC) Using a dictionary for direct mapping\n\nWhich solution is most efficient for large numbers close to 3999?",
				"options": [
					"a) Solution A, because it iterates over a fixed list of tuples, minimizing operations.",
					"b) Solution B, because recursion efficiently breaks down the number.",
					"c) Solution C, because direct mapping is the fastest for any number.",
					"d) All solutions have similar efficiency for large numbers."
				],
				"explanation": "Solution A is the most efficient for large numbers close to 3999 because it uses a fixed list of tuples to iteratively subtract the largest possible values, minimizing the number of operations. Recursive approaches can introduce overhead due to function calls, and direct mapping is not feasible for numbers with complex Roman numeral representations.",
				"answer": "a",
				"topics": ["Math", "Greedy Algorithms"]
			},
			{
				"question": "In the context of converting integers to Roman numerals, which of the following statements about time complexity is true?",
				"options": [
					"a) The time complexity is O(n) where n is the value of the integer.",
					"b) The time complexity is O(1) because the number of Roman numeral symbols is fixed.",
					"c) The time complexity is O(log n) due to the division operations involved.",
					"d) The time complexity is O(n^2) because of nested loops."
				],
				"explanation": "The time complexity is O(1) because the number of Roman numeral symbols is fixed and does not depend on the size of the input number. The algorithm iterates over a constant list of values and symbols, making the operations constant time.",
				"answer": "b",
				"topics": ["Math", "Complexity Analysis"]
			},
			{
				"question": "What is the primary reason for using a greedy algorithm in converting integers to Roman numerals?",
				"options": [
					"a) To ensure the smallest possible Roman numeral representation.",
					"b) To maximize the use of subtraction cases like IV and IX.",
					"c) To efficiently reduce the number by the largest possible Roman numeral values first.",
					"d) To handle edge cases like 0 and negative numbers."
				],
				"explanation": "The primary reason for using a greedy algorithm is to efficiently reduce the number by the largest possible Roman numeral values first. This approach ensures that the conversion is done in the fewest steps possible, adhering to the Roman numeral system's rules.",
				"answer": "c",
				"topics": ["Math", "Greedy Algorithms"]
			}
		]
	},
	{
		"slug": "roman-to-integer",
		"title": "Roman to Integer",
		"leetcodeUrl": "https://leetcode.com/problems/roman-to-integer",
		"difficulty": "Easy",
		"topics": ["Math", "String"],
		"content": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n| Symbol | Value |\n|--------|-------|\n| `I`    | 1     |\n| `V`    | 5     |\n| `X`    | 10    |\n| `L`    | 50    |\n| `C`    | 100   |\n| `D`    | 500   |\n| `M`    | 1000  |\n\nFor example, `2` is written as `II` in Roman numeral, just two ones added together. `12` is written as `XII`, which is simply `X` + `II`. The number `27` is written as `XXVII`, which is `XX` + `V` + `II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`.\n\nThere are six instances where subtraction is used:\n- `I` can be placed before `V` (5) and `X` (10) to make `4` and `9`.\n- `X` can be placed before `L` (50) and `C` (100) to make `40` and `90`.\n- `C` can be placed before `D` (500) and `M` (1000) to make `400` and `900`.\n\nGiven a roman numeral, convert it to an integer.\n\n**Example 1:**\n```\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\n```\n\n**Example 2:**\n```\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V = 5, III = 3.\n```\n\n**Example 3:**\n```\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n```\n\n**Constraints:**\n- `1 <= s.length <= 15`\n- `s` contains only the characters (`'I'`, `'V'`, `'X'`, `'L'`, `'C'`, `'D'`, `'M'`).\n- It is guaranteed that `s` is a valid roman numeral in the range `[1, 3999]`.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of converting a Roman numeral string to an integer using a single pass algorithm?",
				"options": ["O(n)", "O(n^2)", "O(log n)", "O(1)"],
				"explanation": "The time complexity is O(n) because the algorithm processes each character in the string exactly once, where n is the length of the string.",
				"answer": "a",
				"topics": ["Math", "String"]
			},
			{
				"question": "Given the following code snippet for converting a Roman numeral to an integer, identify the bug:\n```python\n1. def romanToInt(s):\n2.     roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n3.     total = 0\n4.     prev_value = 0\n5.     for char in s:\n6.         value = roman_map[char]\n7.         if value > prev_value:\n8.             total += value - 2 * prev_value\n9.         else:\n10.            total += value\n11.        prev_value = value\n12.    return total\n```\nWhich line contains the bug and why does it still pass many test cases?",
				"options": [
					"Line 7: The condition should be value >= prev_value",
					"Line 8: The subtraction should be value - prev_value",
					"Line 8: The subtraction should be value + prev_value",
					"Line 10: The addition should be total -= value"
				],
				"explanation": "Line 8 contains the bug. The subtraction should be value - prev_value, not value - 2 * prev_value. However, it still passes many test cases because the subtraction logic is only triggered when a smaller numeral precedes a larger one, which is rare compared to the normal addition cases.",
				"answer": "b",
				"topics": ["Math", "String", "Implementation"]
			},
			{
				"question": "Consider the following code for converting a Roman numeral to an integer. Which line should replace the ??? to correctly handle the subtraction cases?\n```python\n1. def romanToInt(s):\n2.     roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n3.     total = 0\n4.     i = 0\n5.     while i < len(s):\n6.         if ???:\n7.             total += roman_map[s[i+1]] - roman_map[s[i]]\n8.             i += 2\n9.         else:\n10.            total += roman_map[s[i]]\n11.            i += 1\n12.    return total\n```",
				"options": [
					"i < len(s) - 1 and roman_map[s[i]] < roman_map[s[i+1]]",
					"i < len(s) and roman_map[s[i]] < roman_map[s[i+1]]",
					"i < len(s) - 1 and roman_map[s[i]] > roman_map[s[i+1]]",
					"i < len(s) and roman_map[s[i]] > roman_map[s[i+1]]"
				],
				"explanation": "The correct line is 'i < len(s) - 1 and roman_map[s[i]] < roman_map[s[i+1]]'. This checks if there is a next character and if the current character is less than the next, indicating a subtraction case.",
				"answer": "a",
				"topics": ["Math", "String", "Implementation"]
			},
			{
				"question": "Analyze the space complexity of the following Roman numeral to integer conversion algorithm:\n```python\n1. def romanToInt(s):\n2.     roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n3.     total = 0\n4.     prev_value = 0\n5.     for char in s:\n6.         value = roman_map[char]\n7.         if value > prev_value:\n8.             total += value - 2 * prev_value\n9.         else:\n10.            total += value\n11.        prev_value = value\n12.    return total\n```\nWhat is the space complexity of this algorithm?",
				"options": [
					"O(n) due to the input string",
					"O(1) because only a fixed amount of extra space is used",
					"O(n) due to the dictionary",
					"O(log n) due to the input string"
				],
				"explanation": "The space complexity is O(1) because the algorithm uses a fixed amount of extra space regardless of the input size. The dictionary is constant in size and the input string does not count towards auxiliary space complexity.",
				"answer": "b",
				"topics": ["Math", "String", "Complexity"]
			},
			{
				"question": "Which of the following data structures is most appropriate for storing the mapping of Roman numeral characters to their integer values in a conversion algorithm?",
				"options": ["Array", "Linked List", "Hash Map", "Stack"],
				"explanation": "A Hash Map (or dictionary in Python) is most appropriate for storing the mapping because it allows for O(1) average time complexity for lookups, which is efficient for converting each character in the Roman numeral string to its integer value.",
				"answer": "c",
				"topics": ["Math", "String", "Data Structures"]
			}
		]
	},
	{
		"slug": "longest-common-prefix",
		"title": "Longest Common Prefix",
		"leetcodeUrl": "https://leetcode.com/problems/longest-common-prefix",
		"difficulty": "Easy",
		"topics": ["String"],
		"content": "Write a function to find the longest common prefix string among an array of strings. If there is no common prefix, return an empty string `\"\"`.\n\n**Example 1:**\n```\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n```\n\n**Example 2:**\n```\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n```\n\n**Constraints:**\n- `1 <= strs.length <= 200`\n- `0 <= strs[i].length <= 200`\n- `strs[i]` consists of only lowercase English letters.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of the straightforward approach to find the longest common prefix by comparing characters of each string one by one?",
				"options": [
					"O(n * m) where n is the number of strings and m is the length of the shortest string",
					"O(n^2) where n is the number of strings",
					"O(m^2) where m is the length of the shortest string",
					"O(n + m) where n is the number of strings and m is the length of the shortest string"
				],
				"explanation": "The straightforward approach involves comparing each character of the strings one by one until a mismatch is found. This results in a time complexity of O(n * m), where n is the number of strings and m is the length of the shortest string, as we may need to compare each character of the shortest string with all other strings.",
				"answer": "a",
				"topics": ["String", "Time Complexity"]
			},
			{
				"question": "Given the following implementation of finding the longest common prefix, which line contains a bug?\n```python\n1. def longestCommonPrefix(strs):\n2.     if not strs:\n3.         return \"\"\n4.     prefix = strs[0]\n5.     for s in strs[1:]:\n6.         while not s.startswith(prefix):\n7.             prefix = prefix[:-1]\n8.             if not prefix:\n9.                 return \"\"\n10.    return prefix\n```\nWhy does it still pass many test cases?",
				"options": [
					"Line 6: while not s.startswith(prefix): because it may not handle empty strings correctly",
					"Line 7: prefix = prefix[:-1] because it modifies the prefix incorrectly",
					"Line 8: if not prefix: because it checks for an empty prefix too late",
					"Line 4: prefix = strs[0] because it assumes the first string is non-empty"
				],
				"explanation": "The bug is in Line 6: while not s.startswith(prefix): because it may not handle empty strings correctly. If any string in the list is empty, the function should immediately return an empty string. However, it still passes many test cases because most test cases do not include empty strings.",
				"answer": "a",
				"topics": ["String", "Implementation Analysis"]
			},
			{
				"question": "In the context of finding the longest common prefix, which data structure would be most efficient for storing and comparing prefixes of multiple strings?",
				"options": ["Trie", "HashMap", "Array", "LinkedList"],
				"explanation": "A Trie (prefix tree) is the most efficient data structure for storing and comparing prefixes of multiple strings. It allows for efficient insertion and search operations, which are useful for finding common prefixes.",
				"answer": "a",
				"topics": ["String", "Data Structures"]
			},
			{
				"question": "Consider the following code snippet for finding the longest common prefix:\n```python\n1. def longestCommonPrefix(strs):\n2.     if not strs:\n3.         return \"\"\n4.     prefix = strs[0]\n5.     for s in strs[1:]:\n6.         while not s.startswith(prefix):\n7.             prefix = prefix[:-1]\n8.             if not prefix:\n9.                 return \"\"\n10.    return prefix\n```\nWhat is the space complexity of this implementation?",
				"options": [
					"O(1) because it uses a constant amount of extra space",
					"O(n) where n is the number of strings",
					"O(m) where m is the length of the longest string",
					"O(n * m) where n is the number of strings and m is the length of the longest string"
				],
				"explanation": "The space complexity of this implementation is O(1) because it uses a constant amount of extra space. The only additional space used is for the 'prefix' variable, which is a substring of the input strings and does not depend on the number of strings or their lengths.",
				"answer": "a",
				"topics": ["String", "Space Complexity"]
			},
			{
				"question": "Which of the following modifications would optimize the given solution to handle cases with very large input sizes more efficiently?",
				"options": [
					"Use a Trie to store all strings and find the common prefix",
					"Sort the strings and compare only the first and last strings",
					"Use a HashMap to store character frequencies",
					"Iterate over each character position and compare across all strings"
				],
				"explanation": "Sorting the strings and comparing only the first and last strings can optimize the solution. This is because the first and last strings will have the least commonality, and finding their common prefix will be the same as finding the common prefix of the entire list.",
				"answer": "b",
				"topics": ["String", "Optimization"]
			}
		]
	},
	{
		"slug": "3-sum",
		"title": "3Sum",
		"leetcodeUrl": "https://leetcode.com/problems/3-sum",
		"difficulty": "Medium",
		"topics": ["Array", "Two Pointers"],
		"content": "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. Notice that the solution set must not contain duplicate triplets.\n\n**Example 1:**\n```\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter.\n```\n\n**Example 2:**\n```\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n```\n\n**Example 3:**\n```\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n```\n\n**Constraints:**\n- `3 <= nums.length <= 3000`\n- `-10^5 <= nums[i] <= 10^5`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to solve the 3Sum problem efficiently?",
				"options": [
					"Use three nested loops to check all possible triplets.",
					"Sort the array and use two pointers to find pairs for each element.",
					"Use a hash map to store all pairs and check for the third element.",
					"Use dynamic programming to store results of subproblems."
				],
				"explanation": "The most efficient approach to solve the 3Sum problem is to first sort the array and then use two pointers to find pairs that sum up to the negative of the current element. This reduces the time complexity to O(n^2), which is efficient given the constraints.",
				"answer": "b",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following implementation of the 3Sum problem, which line contains a bug that could lead to incorrect results?\n```python\n1. def threeSum(nums):\n2.     nums.sort()\n3.     result = []\n4.     for i in range(len(nums) - 2):\n5.         if i > 0 and nums[i] == nums[i - 1]:\n6.             continue\n7.         left, right = i + 1, len(nums) - 1\n8.         while left < right:\n9.             total = nums[i] + nums[left] + nums[right]\n10.            if total < 0:\n11.                left += 1\n12.            elif total > 0:\n13.                right -= 1\n14.            else:\n15.                result.append([nums[i], nums[left], nums[right]])\n16.                while left < right and nums[left] == nums[left + 1]:\n17.                    left += 1\n18.                while left < right and nums[right] == nums[right - 1]:\n19.                    right -= 1\n20.                left += 1\n21.                right -= 1\n22.     return result\n```",
				"options": [
					"Line 5: The condition to skip duplicates is incorrect.",
					"Line 9: The calculation of total is incorrect.",
					"Line 16: The loop to skip duplicates on the left is incorrect.",
					"Line 18: The loop to skip duplicates on the right is incorrect."
				],
				"explanation": "The implementation is correct. However, if there were a bug, it would likely be in the duplicate skipping logic. In this case, the code correctly skips duplicates after finding a valid triplet, ensuring no duplicate triplets are added to the result.",
				"answer": "c",
				"topics": ["Array", "Two Pointers", "Implementation Analysis"]
			},
			{
				"question": "In the 3Sum problem, what is the time complexity of the optimal solution using sorting and two pointers?",
				"options": ["O(n^3)", "O(n^2)", "O(n log n)", "O(n)"],
				"explanation": "The optimal solution involves sorting the array, which takes O(n log n), and then using a two-pointer technique for each element, which takes O(n^2) in total. Thus, the overall time complexity is O(n^2).",
				"answer": "b",
				"topics": ["Array", "Two Pointers", "Complexity Analysis"]
			},
			{
				"question": "Consider the following scenario: You have an array of size 3000 with all elements being zero. How many unique triplets will the 3Sum algorithm find?",
				"options": ["0", "1", "3000", "C(3000, 3)"],
				"explanation": "If all elements are zero, the only triplet that sums to zero is [0, 0, 0]. The algorithm will find this triplet once, regardless of the number of zeros, because it skips duplicates after finding a valid triplet.",
				"answer": "b",
				"topics": ["Array", "Edge Cases"]
			},
			{
				"question": "Which of the following modifications would allow the 3Sum algorithm to work in-place, without using extra space for the result?",
				"options": [
					"Store the results in the input array itself by overwriting elements.",
					"Use a linked list to store results instead of a list.",
					"Modify the input array to mark used elements with a special value.",
					"Use a set to store results to avoid duplicates."
				],
				"explanation": "Storing results in the input array by overwriting elements is not feasible as it would destroy the input data. Using a set to store results is a common approach to avoid duplicates, but it still uses extra space. The problem inherently requires extra space to store results, so in-place modification is not practical without losing data.",
				"answer": "a",
				"topics": ["Array", "Optimization Modifications"]
			},
			{
				"question": "Analyze the space complexity of the 3Sum algorithm using sorting and two pointers. Consider both the input and any auxiliary space used.",
				"options": [
					"O(n) due to the input array and sorting.",
					"O(1) as no extra space is used beyond input storage.",
					"O(n^2) due to storing all possible triplets.",
					"O(n log n) due to sorting."
				],
				"explanation": "The space complexity is O(1) beyond the input storage because the algorithm only uses a constant amount of extra space for pointers and variables. Sorting is done in-place, and the result list is not considered auxiliary space as it is part of the output.",
				"answer": "b",
				"topics": ["Array", "Space Complexity"]
			}
		]
	},
	{
		"slug": "3-sum-closest",
		"title": "3 Sum Closest",
		"leetcodeUrl": "https://leetcode.com/problems/3-sum-closest",
		"difficulty": "Medium",
		"topics": ["Array", "Two Pointers"],
		"content": "Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers.\n\nYou may assume that each input would have exactly one solution.\n\n**Example 1:**\n```\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n```\n\n**Example 2:**\n```\nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n```\n\n**Constraints:**\n- `3 <= nums.length <= 500`\n- `-1000 <= nums[i] <= 1000`\n- `-10^4 <= target <= 10^4`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to solve the 3 Sum Closest problem efficiently?",
				"options": [
					"Sort the array and use a two-pointer technique for each element.",
					"Use a hash map to store sums and check for the closest sum.",
					"Iterate through all possible triplets and calculate their sums.",
					"Use dynamic programming to store intermediate results."
				],
				"explanation": "The most efficient approach is to first sort the array and then use a two-pointer technique for each element. This allows us to efficiently find the closest sum by adjusting the pointers based on the current sum compared to the target. This approach has a time complexity of O(n^2), which is optimal for this problem.",
				"answer": "a",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following implementation of the 3 Sum Closest problem, which line contains a bug?\n```python\n1. def threeSumClosest(nums, target):\n2.     nums.sort()\n3.     closest_sum = float('inf')\n4.     for i in range(len(nums) - 2):\n5.         left, right = i + 1, len(nums) - 1\n6.         while left < right:\n7.             current_sum = nums[i] + nums[left] + nums[right]\n8.             if abs(current_sum - target) < abs(closest_sum - target):\n9.                 closest_sum = current_sum\n10.            if current_sum < target:\n11.                left += 1\n12.            elif current_sum > target:\n13.                right -= 1\n14.            else:\n15.                return current_sum\n16.     return closest_sum\n```",
				"options": [
					"Line 3: closest_sum should be initialized to a valid sum.",
					"Line 8: The condition should be <= to handle equal distances.",
					"Line 10: The condition should be current_sum <= target.",
					"Line 15: The return statement should be outside the loop."
				],
				"explanation": "The bug is in Line 3. Initializing closest_sum to float('inf') is incorrect because it should be initialized to a valid sum of the first three elements to ensure a valid comparison. The other lines are correct as they handle the logic for adjusting the pointers and checking the closest sum.",
				"answer": "a",
				"topics": ["Array", "Two Pointers", "Implementation Analysis"]
			},
			{
				"question": "What is the time complexity of the optimal solution for the 3 Sum Closest problem?",
				"options": ["O(n^3)", "O(n^2)", "O(n log n)", "O(n)"],
				"explanation": "The optimal solution involves sorting the array, which takes O(n log n), and then using a two-pointer technique for each element, which takes O(n^2) in total. Therefore, the overall time complexity is O(n^2).",
				"answer": "b",
				"topics": ["Array", "Two Pointers", "Complexity Analysis"]
			},
			{
				"question": "In the 3 Sum Closest problem, why is sorting the array a necessary step before applying the two-pointer technique?",
				"options": [
					"Sorting helps in reducing the number of elements to consider.",
					"Sorting allows us to use binary search to find the closest sum.",
					"Sorting ensures that we can efficiently adjust pointers to find the closest sum.",
					"Sorting is not necessary; it just simplifies the implementation."
				],
				"explanation": "Sorting the array is necessary because it allows us to efficiently adjust the two pointers based on the current sum compared to the target. This is crucial for the two-pointer technique to work correctly, as it relies on the order of elements to decide whether to move the left or right pointer.",
				"answer": "c",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Which of the following modifications would improve the space complexity of the 3 Sum Closest solution?",
				"options": [
					"Use a hash map to store previously computed sums.",
					"Avoid sorting the array to save space.",
					"Use in-place operations to avoid additional data structures.",
					"The current solution already uses O(1) extra space."
				],
				"explanation": "The current solution already uses O(1) extra space because it only uses a few variables to keep track of indices and the closest sum. Sorting the array is done in-place, so no additional space is required beyond the input array.",
				"answer": "d",
				"topics": ["Array", "Two Pointers", "Space Complexity"]
			}
		]
	},
	{
		"slug": "letter-combinations-of-a-phone-number",
		"title": "17. Letter Combinations of a Phone Number",
		"leetcodeUrl": "https://leetcode.com/problems/letter-combinations-of-a-phone-number",
		"difficulty": "Medium",
		"topics": ["Backtracking", "String"],
		"content": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that `1` does not map to any letters.\n\n**Example 1:**\n```\nInput: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n```\n\n**Example 2:**\n```\nInput: digits = \"\"\nOutput: []\n```\n\n**Example 3:**\n```\nInput: digits = \"2\"\nOutput: [\"a\",\"b\",\"c\"]\n```\n\n**Constraints:**\n- `0 <= digits.length <= 4`\n- `digits[i]` is a digit in the range [`2`, `9`].",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is the most efficient approach to generate all possible letter combinations for a given string of digits from '2' to '9'?",
				"options": [
					"a) Use a recursive backtracking approach to explore all combinations.",
					"b) Use a dynamic programming approach to build combinations iteratively.",
					"c) Use a breadth-first search to explore combinations level by level.",
					"d) Use a depth-first search with memoization to avoid recomputation."
				],
				"explanation": "The most efficient approach to generate all possible letter combinations for a given string of digits is to use a recursive backtracking approach. This method allows you to explore all possible combinations by recursively building each combination and backtracking when necessary. It is well-suited for problems where you need to explore all possible configurations, such as generating combinations or permutations.",
				"answer": "a",
				"topics": ["Backtracking", "String"]
			},
			{
				"question": "Given the following code snippet for generating letter combinations of a phone number, identify the bug:\n```python\n1. def letterCombinations(digits):\n2.     if not digits:\n3.         return []\n4.     phone_map = {\n5.         '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n6.         '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n7.     }\n8.     result = []\n9.     def backtrack(index, path):\n10.        if len(path) == len(digits):\n11.            result.append(path)\n12.            return\n13.        for letter in phone_map[digits[index]]:\n14.            backtrack(index + 1, path + letter)\n15.    backtrack(0, '')\n16.    return result\n```\nWhat is the bug in the code?",
				"options": [
					"a) The base case in line 10 should check if index == len(digits).",
					"b) The phone_map dictionary is missing mappings for digits '0' and '1'.",
					"c) The result list is not initialized correctly, it should be a set to avoid duplicates.",
					"d) The function should return None if digits is empty, not an empty list."
				],
				"explanation": "The bug in the code is in the base case condition on line 10. It should check if the current index is equal to the length of the digits, not the length of the path. The correct condition should be `if index == len(digits):`. This ensures that the function appends a complete combination to the result list when it has processed all digits.",
				"answer": "a",
				"topics": ["Backtracking", "String"]
			},
			{
				"question": "Consider the following recursive solution for generating letter combinations of a phone number. What is the time complexity of this solution?\n```python\n1. def letterCombinations(digits):\n2.     if not digits:\n3.         return []\n4.     phone_map = {\n5.         '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n6.         '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n7.     }\n8.     result = []\n9.     def backtrack(index, path):\n10.        if index == len(digits):\n11.            result.append(path)\n12.            return\n13.        for letter in phone_map[digits[index]]:\n14.            backtrack(index + 1, path + letter)\n15.    backtrack(0, '')\n16.    return result\n```\nWhat is the time complexity of this solution?",
				"options": [
					"a) O(3^n) where n is the length of the digits string.",
					"b) O(4^n) where n is the length of the digits string.",
					"c) O(n * 4^n) where n is the length of the digits string.",
					"d) O(n * 3^n) where n is the length of the digits string."
				],
				"explanation": "The time complexity of this solution is O(4^n), where n is the length of the digits string. This is because each digit can map to up to 4 letters (e.g., '7' and '9' map to 4 letters), and the algorithm explores all possible combinations of these letters. Therefore, in the worst case, the number of combinations is 4^n.",
				"answer": "b",
				"topics": ["Backtracking", "String"]
			},
			{
				"question": "In the context of generating letter combinations of a phone number, which of the following optimizations can reduce the space complexity of the recursive solution?",
				"options": [
					"a) Use an iterative approach with a stack to simulate recursion.",
					"b) Use a queue to store intermediate results instead of a list.",
					"c) Use a single string variable to build combinations instead of a list.",
					"d) Use memoization to store previously computed results."
				],
				"explanation": "Using an iterative approach with a stack to simulate recursion can reduce the space complexity of the recursive solution. This is because recursion inherently uses the call stack, which can grow with the depth of the recursion. By using an explicit stack, you can manage the space usage more efficiently and avoid the overhead of recursive function calls.",
				"answer": "a",
				"topics": ["Backtracking", "String"]
			},
			{
				"question": "Which of the following scenarios would make a heap-based solution more efficient than a backtracking solution for generating letter combinations of a phone number?",
				"options": [
					"a) When the input string is very short (length < 2).",
					"b) When the input string is very long (length > 10).",
					"c) When the input string contains only digits that map to 3 letters.",
					"d) When the input string contains only digits that map to 4 letters."
				],
				"explanation": "A heap-based solution is not typically used for generating letter combinations of a phone number, as the problem is inherently combinatorial and best suited for backtracking. However, if the input string is very long, a heap-based solution might be considered to manage memory usage more efficiently, but it would not necessarily be more efficient in terms of time complexity compared to backtracking.",
				"answer": "b",
				"topics": ["Backtracking", "String"]
			}
		]
	},
	{
		"slug": "4sum",
		"title": "4 Sum",
		"leetcodeUrl": "https://leetcode.com/problems/4sum",
		"difficulty": "Medium",
		"topics": ["Array", "Hash Table", "Two Pointers"],
		"content": "Given an array `nums` of `n` integers, return an array of all the unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that:\n\n- `0 <= a, b, c, d < n`\n- `a, b, c, and d` are distinct.\n- `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\nYou may return the answer in any order.\n\n**Example 1:**\n```\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n```\n\n**Example 2:**\n```\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n```\n\n**Constraints:**\n- `1 <= nums.length <= 200`\n- `-10^9 <= nums[i] <= 10^9`\n- `-10^9 <= target <= 10^9`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to solve the 4 Sum problem efficiently?",
				"options": [
					"Use a hash table to store all pairs of sums and then check for complementary pairs.",
					"Sort the array and use a two-pointer technique to find quadruplets.",
					"Use a brute force approach to check all possible quadruplets.",
					"Use dynamic programming to store intermediate results of sums."
				],
				"explanation": "The most efficient approach to solve the 4 Sum problem is to first sort the array and then use a two-pointer technique to find quadruplets. This reduces the complexity compared to checking all possible quadruplets, which would be inefficient. Using a hash table for pairs can also work but is less efficient than the two-pointer method after sorting.",
				"answer": "b",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following code snippet for solving the 4 Sum problem, identify the bug:\n```python\n1. def fourSum(nums, target):\n2.     nums.sort()\n3.     result = []\n4.     for i in range(len(nums) - 3):\n5.         if i > 0 and nums[i] == nums[i-1]:\n6.             continue\n7.         for j in range(i + 1, len(nums) - 2):\n8.             if j > i + 1 and nums[j] == nums[j-1]:\n9.                 continue\n10.            left, right = j + 1, len(nums) - 1\n11.            while left < right:\n12.                total = nums[i] + nums[j] + nums[left] + nums[right]\n13.                if total == target:\n14.                    result.append([nums[i], nums[j], nums[left], nums[right]])\n15.                    while left < right and nums[left] == nums[left + 1]:\n16.                        left += 1\n17.                    while left < right and nums[right] == nums[right - 1]:\n18.                        right -= 1\n19.                    left += 1\n20.                    right -= 1\n21.                elif total < target:\n22.                    left += 1\n23.                else:\n24.                    right -= 1\n25.    return result\n```\nWhat is the bug in this code?",
				"options": [
					"The code does not handle duplicate quadruplets correctly.",
					"The code does not sort the array before processing.",
					"The code does not check for out-of-bound errors in the while loop.",
					"The code does not update the pointers correctly after finding a quadruplet."
				],
				"explanation": "The code correctly handles duplicate quadruplets by skipping over duplicates with the while loops on lines 15-18. It also sorts the array on line 2 and updates pointers correctly after finding a quadruplet. There are no out-of-bound errors in the while loop. Therefore, there is no bug in the code as presented.",
				"answer": "a",
				"topics": ["Array", "Two Pointers", "Implementation"]
			},
			{
				"question": "Consider the time complexity of the 4 Sum problem using the two-pointer technique after sorting the array. What is the time complexity?",
				"options": ["O(n^2)", "O(n^3)", "O(n^4)", "O(n log n)"],
				"explanation": "The time complexity of the 4 Sum problem using the two-pointer technique after sorting the array is O(n^3). This is because for each pair of elements, we use a two-pointer approach to find the remaining two elements, leading to a cubic complexity.",
				"answer": "b",
				"topics": ["Array", "Two Pointers", "Complexity Analysis"]
			},
			{
				"question": "In the 4 Sum problem, which data structure is most appropriate for storing and checking for duplicate quadruplets efficiently?",
				"options": ["Array", "Hash Set", "Linked List", "Stack"],
				"explanation": "A hash set is most appropriate for storing and checking for duplicate quadruplets efficiently because it allows for average O(1) time complexity for insertions and lookups, which is crucial for ensuring that only unique quadruplets are stored.",
				"answer": "b",
				"topics": ["Array", "Hash Table"]
			},
			{
				"question": "Given the constraints of the 4 Sum problem, what is the maximum number of quadruplets that can be formed from an array of length 200?",
				"options": [
					"Approximately 1.6 million",
					"Approximately 1.2 million",
					"Approximately 2.5 million",
					"Approximately 3.2 million"
				],
				"explanation": "The maximum number of quadruplets that can be formed from an array of length 200 is given by the combination formula C(n, 4) = n! / (4!(n-4)!) = 200! / (4! * 196!) = 1,960,200, which is approximately 1.6 million.",
				"answer": "a",
				"topics": ["Array", "Combinatorics"]
			}
		]
	},
	{
		"slug": "remove-nth-node-from-end-of-list",
		"title": "Remove Nth Node From End of List",
		"leetcodeUrl": "https://leetcode.com/problems/remove-nth-node-from-end-of-list",
		"difficulty": "Medium",
		"topics": ["Linked List", "Two Pointers"],
		"content": "Given the head of a linked list, remove the `n`-th node from the end of the list and return its head.\n\n**Example 1:**\n```\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n```\n\n**Example 2:**\n```\nInput: head = [1], n = 1\nOutput: []\n```\n\n**Example 3:**\n```\nInput: head = [1,2], n = 1\nOutput: [1]\n```\n\n**Constraints:**\n- The number of nodes in the list is `sz`.\n- `1 <= sz <= 30`\n- `0 <= Node.val <= 100`\n- `1 <= n <= sz`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the optimal solution for removing the nth node from the end of a linked list?",
				"options": ["O(n)", "O(n^2)", "O(log n)", "O(1)"],
				"explanation": "The optimal solution involves two passes through the linked list. The first pass is to determine the length of the list, and the second pass is to remove the nth node from the end. This results in a time complexity of O(n), where n is the number of nodes in the list.",
				"answer": "a",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "In the following code for removing the nth node from the end of a linked list, which line contains a bug?\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeNthFromEnd(head, n):\n    dummy = ListNode(0, head)\n    first = dummy\n    second = dummy\n    for _ in range(n):\n        first = first.next\n    while first.next:\n        first = first.next\n        second = second.next\n    second.next = second.next.next\n    return dummy.next\n```\nWhich line contains the bug and why?",
				"options": [
					"Line 7: for _ in range(n): because it should iterate n+1 times",
					"Line 9: while first.next: because it should be while first:",
					"Line 11: second.next = second.next.next because it may cause a null pointer exception",
					"Line 12: return dummy.next because it should return head"
				],
				"explanation": "The bug is in Line 7: `for _ in range(n):` because it should iterate n+1 times to position the `first` pointer correctly for the two-pointer technique. This ensures that the `second` pointer is at the node just before the one to be removed.",
				"answer": "a",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "Consider the following three solutions for removing the nth node from the end of a linked list:\nA) Two-pass algorithm\nB) One-pass algorithm using two pointers\nC) Recursive approach\n\nWhich solution is most space-efficient and why?",
				"options": [
					"A) Two-pass algorithm because it uses O(1) extra space",
					"B) One-pass algorithm using two pointers because it uses O(1) extra space",
					"C) Recursive approach because it uses O(n) space for the recursion stack",
					"All solutions have the same space complexity"
				],
				"explanation": "The one-pass algorithm using two pointers (B) is the most space-efficient because it only uses a constant amount of extra space, O(1). The recursive approach (C) uses O(n) space due to the recursion stack, and the two-pass algorithm (A) also uses O(1) extra space, but B is more efficient in terms of time complexity.",
				"answer": "b",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "In the context of removing the nth node from the end of a linked list, what is the main advantage of using a dummy node?",
				"options": [
					"It simplifies edge cases such as removing the head node",
					"It reduces the time complexity from O(n) to O(1)",
					"It allows the algorithm to work without knowing the list's length",
					"It prevents null pointer exceptions when accessing the list"
				],
				"explanation": "Using a dummy node simplifies edge cases, such as when the head node needs to be removed. By having a dummy node, the algorithm can uniformly handle the removal of any node, including the head, without additional checks or modifications.",
				"answer": "a",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "Which of the following modifications would allow the given solution to remove the nth node from the end of a linked list in a single pass?\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeNthFromEnd(head, n):\n    dummy = ListNode(0, head)\n    first = dummy\n    second = dummy\n    for _ in range(n):\n        first = first.next\n    while first.next:\n        first = first.next\n        second = second.next\n    second.next = second.next.next\n    return dummy.next\n```\n",
				"options": [
					"Initialize first pointer n+1 steps ahead of the second pointer",
					"Use a stack to store nodes and pop n nodes",
					"Count the total number of nodes and subtract n",
					"Reverse the list, remove the nth node, and reverse again"
				],
				"explanation": "To remove the nth node from the end in a single pass, initialize the first pointer n+1 steps ahead of the second pointer. This way, when the first pointer reaches the end, the second pointer will be just before the node to be removed.",
				"answer": "a",
				"topics": ["Linked List", "Two Pointers"]
			}
		]
	},
	{
		"slug": "valid-parentheses",
		"title": "Valid Parentheses",
		"leetcodeUrl": "https://leetcode.com/problems/valid-parentheses",
		"difficulty": "Easy",
		"topics": ["Stack"],
		"content": "Given a string containing just the characters `(`, `)`, `{`, `}`, `[`, and `]`, determine if the input string is valid.\n\nAn input string is valid if:\n\n- Open brackets must be closed by the same type of brackets.\n- Open brackets must be closed in the correct order.\n- Every close bracket has a corresponding open bracket of the same type.\n\n**Example 1:**\n```\nInput: s = \"()\"\nOutput: true\n```\n\n**Example 2:**\n```\nInput: s = \"()[]{}\"\nOutput: true\n```\n\n**Example 3:**\n```\nInput: s = \"(]\"\nOutput: false\n```\n\n**Constraints:**\n- `1 <= s.length <= 10^4`\n- `s` consists of parentheses only `()[]{}`.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "Which data structure is most appropriate for solving the 'Valid Parentheses' problem efficiently?",
				"options": ["Queue", "Stack", "HashMap", "Linked List"],
				"explanation": "A stack is the most appropriate data structure for this problem because it allows us to efficiently track the most recent opening bracket and ensure that it is closed correctly. As we iterate through the string, we push opening brackets onto the stack and pop them when we encounter a matching closing bracket. This ensures that brackets are closed in the correct order.",
				"answer": "b",
				"topics": ["Stack"]
			},
			{
				"question": "Consider the following implementation of the 'Valid Parentheses' problem:\n```python\n1. def isValid(s):\n2.     stack = []\n3.     mapping = {')': '(', '}': '{', ']': '['}\n4.     for char in s:\n5.         if char in mapping:\n6.             top_element = stack.pop() if stack else '#'\n7.             if mapping[char] != top_element:\n8.                 return False\n9.         else:\n10.            stack.append(char)\n11.    return not stack\n```\nWhat is the purpose of line 6 in this code?",
				"options": [
					"To handle the case where the stack is empty and a closing bracket is encountered.",
					"To ensure that the stack only contains opening brackets.",
					"To initialize the stack with a default value.",
					"To map each closing bracket to its corresponding opening bracket."
				],
				"explanation": "Line 6 handles the case where a closing bracket is encountered but the stack is empty, which means there is no corresponding opening bracket. By using a default value ('#'), the code can safely compare it with the expected opening bracket and return False if they don't match.",
				"answer": "a",
				"topics": ["Stack", "Implementation"]
			},
			{
				"question": "In the 'Valid Parentheses' problem, what is the time complexity of the provided solution?",
				"options": ["O(n^2)", "O(n)", "O(log n)", "O(1)"],
				"explanation": "The time complexity of the solution is O(n), where n is the length of the string. This is because each character in the string is processed exactly once, and stack operations (push and pop) are O(1).",
				"answer": "b",
				"topics": ["Stack", "Complexity Analysis"]
			},
			{
				"question": "Given the following code snippet for the 'Valid Parentheses' problem, identify the bug:\n```python\n1. def isValid(s):\n2.     stack = []\n3.     mapping = {')': '(', '}': '{', ']': '['}\n4.     for char in s:\n5.         if char in mapping:\n6.             top_element = stack.pop() if stack else '#'\n7.             if mapping[char] != top_element:\n8.                 return False\n9.         else:\n10.            stack.append(char)\n11.    return len(stack) == 0\n```\nWhich line contains the bug and why does it still pass many test cases?",
				"options": [
					"Line 6: The default value '#' might incorrectly match with an opening bracket.",
					"Line 7: The comparison might fail if the stack is empty.",
					"Line 11: The condition should be 'return not stack'.",
					"Line 10: It should check if the character is an opening bracket before appending."
				],
				"explanation": "Line 6 contains a subtle bug. The default value '#' is used when the stack is empty, which is correct for handling unmatched closing brackets. However, if the string starts with a closing bracket, it will still return False correctly, which is why it passes many test cases. The bug is subtle because it doesn't affect the correctness of the solution in typical cases.",
				"answer": "a",
				"topics": ["Stack", "Implementation Analysis"]
			},
			{
				"question": "Which of the following modifications would optimize the space usage of the 'Valid Parentheses' solution while maintaining the same time complexity?",
				"options": [
					"Use a fixed-size array instead of a dynamic list for the stack.",
					"Use a single integer to track the balance of parentheses.",
					"Use a hash set to store unmatched opening brackets.",
					"Use a bitmask to represent the stack state."
				],
				"explanation": "Using a single integer to track the balance of parentheses would not work for this problem because it doesn't account for the order and type of brackets. The stack is necessary to ensure that each type of bracket is matched correctly. Therefore, none of the options would optimize space without losing correctness.",
				"answer": "b",
				"topics": ["Stack", "Optimization"]
			}
		]
	},
	{
		"slug": "merge-two-sorted-lists",
		"title": "Merge Two Sorted Lists",
		"leetcodeUrl": "https://leetcode.com/problems/merge-two-sorted-lists",
		"difficulty": "Easy",
		"topics": ["Linked List"],
		"content": "You are given the heads of two sorted linked lists `list1` and `list2`. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.\n\n**Example 1:**\n```\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n```\n\n**Example 2:**\n```\nInput: list1 = [], list2 = []\nOutput: []\n```\n\n**Example 3:**\n```\nInput: list1 = [], list2 = [0]\nOutput: [0]\n```\n\n**Constraints:**\n- The number of nodes in both lists is in the range `[0,50]`.\n- `-100 <= Node.val <= 100`\n- Both `list1` and `list2` are sorted in non-decreasing order.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of merging two sorted linked lists of lengths m and n?",
				"options": ["O(m + n)", "O(m * n)", "O(max(m, n))", "O(min(m, n))"],
				"explanation": "The time complexity of merging two sorted linked lists is O(m + n) because each element from both lists is processed exactly once. The algorithm iterates through both lists, comparing elements and appending the smaller one to the result list, until all elements are processed.",
				"answer": "a",
				"topics": ["Linked List", "Complexity Analysis"]
			},
			{
				"question": "Given the following implementation of merging two sorted linked lists, which line contains a bug?\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeTwoLists(l1, l2):\n    dummy = ListNode()\n    current = dummy\n    while l1 and l2:\n        if l1.val < l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    if l1:\n        current.next = l1\n    elif l2:\n        current.next = l2\n    return dummy.next\n```\nWhich line contains the bug?",
				"options": [
					"Line 5: dummy = ListNode()",
					"Line 8: if l1.val < l2.val:",
					"Line 15: elif l2:",
					"No bug, the implementation is correct"
				],
				"explanation": "The implementation is correct. The code uses a dummy node to simplify the merging process and iterates through both lists, appending the smaller node to the result list. After the loop, it appends any remaining nodes from either list. The dummy node's next pointer is returned as the head of the merged list.",
				"answer": "d",
				"topics": ["Linked List", "Implementation Analysis"]
			},
			{
				"question": "In the context of merging two sorted linked lists, which data structure is most appropriate for storing the merged result?",
				"options": ["Array", "Stack", "Queue", "Linked List"],
				"explanation": "A linked list is the most appropriate data structure for storing the merged result because the input is already in the form of linked lists, and the problem requires merging them into another linked list. This allows for efficient splicing of nodes without additional space overhead.",
				"answer": "d",
				"topics": ["Linked List", "Data Structure Selection"]
			},
			{
				"question": "Consider the following scenario: You have two sorted linked lists, each with 50 nodes. What is the maximum number of comparisons needed to merge these lists?",
				"options": ["50", "100", "75", "25"],
				"explanation": "The maximum number of comparisons needed to merge two sorted linked lists, each with 50 nodes, is 100. In the worst case, every node from both lists needs to be compared before being added to the merged list, resulting in a total of 100 comparisons.",
				"answer": "b",
				"topics": ["Linked List", "Complexity Analysis"]
			}
		]
	},
	{
		"slug": "generate-parentheses",
		"title": "Generate Parentheses",
		"leetcodeUrl": "https://leetcode.com/problems/generate-parentheses",
		"difficulty": "Medium",
		"topics": ["Backtracking"],
		"content": "Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n**Example 1:**\n```\nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n```\n\n**Example 2:**\n```\nInput: n = 1\nOutput: [\"()\"]\n```\n\n**Constraints:**\n- `1 <= n <= 8`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to generate all combinations of well-formed parentheses for a given number of pairs `n`?",
				"options": [
					"a) Use a stack to simulate the process of adding parentheses and backtrack when invalid combinations are formed.",
					"b) Use a dynamic programming approach to build solutions incrementally by adding one pair of parentheses at a time.",
					"c) Use a greedy algorithm to add the most balanced parentheses at each step.",
					"d) Use a breadth-first search to explore all possible combinations of parentheses."
				],
				"explanation": "The correct approach is to use backtracking, which can be implemented using a stack to simulate the process of adding parentheses. This allows us to explore all possible combinations and backtrack when an invalid combination is formed. Dynamic programming and greedy algorithms are not suitable for this problem as they do not explore all possible combinations. Breadth-first search is not efficient for this problem as it would explore all combinations without pruning invalid ones early.",
				"answer": "a",
				"topics": ["Backtracking"]
			},
			{
				"question": "Consider the following code snippet for generating parentheses:\n```python\n1. def generateParenthesis(n):\n2.     def backtrack(S, left, right):\n3.         if len(S) == 2 * n:\n4.             result.append(\"\".join(S))\n5.             return\n6.         if left < n:\n7.             S.append('(')\n8.             backtrack(S, left+1, right)\n9.             S.pop()\n10.        if right < left:\n11.            S.append(')')\n12.            backtrack(S, left, right+1)\n13.            S.pop()\n14.    result = []\n15.    backtrack([], 0, 0)\n16.    return result\n```\nWhat is the purpose of the condition on line 10?",
				"options": [
					"a) To ensure that the number of right parentheses never exceeds the number of left parentheses.",
					"b) To ensure that the number of left parentheses never exceeds the number of right parentheses.",
					"c) To ensure that the total number of parentheses does not exceed `2 * n`.",
					"d) To ensure that the parentheses are added in a balanced manner."
				],
				"explanation": "The condition on line 10 ensures that the number of right parentheses never exceeds the number of left parentheses. This is crucial for maintaining the balance of the parentheses, as a valid sequence cannot have more right parentheses than left ones at any point.",
				"answer": "a",
				"topics": ["Backtracking"]
			},
			{
				"question": "In the context of generating parentheses, what is the time complexity of the backtracking approach?",
				"options": [
					"a) O(n!)",
					"b) O(2^n)",
					"c) O(4^n / sqrt(n))",
					"d) O(n^2)"
				],
				"explanation": "The time complexity of generating all combinations of well-formed parentheses using backtracking is O(4^n / sqrt(n)). This is because the Catalan number, which counts the number of valid parentheses sequences, is approximately 4^n / sqrt(n).",
				"answer": "c",
				"topics": ["Backtracking", "Complexity Analysis"]
			},
			{
				"question": "Given the backtracking solution for generating parentheses, which of the following modifications would allow the solution to work in-place without using additional space for the result list?",
				"options": [
					"a) Use a global variable to store the results instead of passing a list.",
					"b) Modify the input list to store both the current sequence and the results.",
					"c) Use a generator to yield each valid sequence instead of appending to a list.",
					"d) Store the results in a dictionary to avoid duplicates."
				],
				"explanation": "Using a generator to yield each valid sequence instead of appending to a list allows the solution to work in-place. This approach does not require additional space for storing all results at once, as each sequence is generated and returned one at a time.",
				"answer": "c",
				"topics": ["Backtracking", "Optimization"]
			},
			{
				"question": "Which of the following statements about the backtracking approach to generate parentheses is true?",
				"options": [
					"a) The approach guarantees that all generated sequences are unique without additional checks.",
					"b) The approach requires sorting the results to ensure they are in lexicographical order.",
					"c) The approach can be easily modified to generate sequences with additional constraints, such as a maximum depth of nested parentheses.",
					"d) The approach is inefficient for large values of `n` due to its exponential time complexity."
				],
				"explanation": "The backtracking approach is inefficient for large values of `n` due to its exponential time complexity, as it explores all possible combinations of parentheses. However, it guarantees that all generated sequences are unique and valid without additional checks, and the results are naturally in lexicographical order due to the order of exploration. Modifying the approach to handle additional constraints can be complex and may require significant changes to the logic.",
				"answer": "d",
				"topics": ["Backtracking", "Complexity Analysis"]
			}
		]
	},
	{
		"slug": "merge-k-sorted-lists",
		"title": "Merge k Sorted Lists",
		"leetcodeUrl": "https://leetcode.com/problems/merge-k-sorted-lists",
		"difficulty": "Medium",
		"topics": ["Linked List", "Heap"],
		"content": "Merge `k` sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n\n**Example 1:**\n```\nInput: [[1->4->5], [1->3->4], [2->6]]\nOutput: 1->1->2->3->4->4->5->6\n```\n\n**Constraints:**\n- `k == lists.length`\n- `0 <= k <= 10^4`\n- `0 <= lists[i].length <= 500`\n- `-10^4 <= lists[i][j] <= 10^4`\n- The input lists are guaranteed to be sorted in ascending order.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following algorithms is most efficient for merging k sorted linked lists?",
				"options": [
					"a) Merge sort",
					"b) Quick sort",
					"c) Min-heap",
					"d) Bubble sort"
				],
				"explanation": "The most efficient way to merge k sorted linked lists is to use a min-heap (priority queue). By inserting the first element of each list into the heap, we can repeatedly extract the smallest element and insert the next element from the same list into the heap. This approach has a time complexity of O(N log k), where N is the total number of nodes across all lists, and k is the number of lists.",
				"answer": "c",
				"topics": ["Linked List", "Heap"]
			},
			{
				"question": "Given the following code snippet for merging k sorted linked lists, which line contains a bug?\n```python\nimport heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        min_heap = []\n        for l in lists:\n            if l:\n                heapq.heappush(min_heap, (l.val, l))\n        dummy = ListNode(0)\n        current = dummy\n        while min_heap:\n            val, node = heapq.heappop(min_heap)\n            current.next = ListNode(val)\n            current = current.next\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, node.next))\n        return dummy.next\n```",
				"options": [
					"a) heapq.heappush(min_heap, (l.val, l))",
					"b) current.next = ListNode(val)",
					"c) if node.next:",
					"d) return dummy.next"
				],
				"explanation": "The bug is in option a) `heapq.heappush(min_heap, (l.val, l))`. The issue is that tuples are compared lexicographically, and if two nodes have the same value, the comparison will fail because ListNode objects are not directly comparable. A workaround is to include an index or use a custom comparator.",
				"answer": "a",
				"topics": ["Linked List", "Heap", "Implementation Analysis"]
			},
			{
				"question": "What is the time complexity of merging k sorted linked lists using a min-heap?",
				"options": [
					"a) O(N log N)",
					"b) O(N log k)",
					"c) O(k log N)",
					"d) O(N^2)"
				],
				"explanation": "The time complexity of merging k sorted linked lists using a min-heap is O(N log k), where N is the total number of nodes across all lists. This is because each insertion and extraction operation on the heap takes O(log k) time, and there are N such operations in total.",
				"answer": "b",
				"topics": ["Linked List", "Heap", "Complexity Analysis"]
			},
			{
				"question": "In the context of merging k sorted linked lists, which of the following scenarios would make a heap-based solution more efficient than a divide-and-conquer approach?",
				"options": [
					"a) When k is very large and each list has a small number of elements",
					"b) When k is small and each list has a large number of elements",
					"c) When all lists are of equal length",
					"d) When the lists are already partially merged"
				],
				"explanation": "A heap-based solution is more efficient when k is very large and each list has a small number of elements. This is because the heap operations are logarithmic in k, making it more efficient to handle a large number of lists. In contrast, a divide-and-conquer approach would involve more recursive merging steps, which can be less efficient when k is large.",
				"answer": "a",
				"topics": ["Linked List", "Heap", "Solution Comparison"]
			},
			{
				"question": "Consider the following recursive solution for merging k sorted linked lists. What is the time complexity of this approach?\n```python\ndef mergeKLists(lists):\n    if not lists:\n        return None\n    if len(lists) == 1:\n        return lists[0]\n    mid = len(lists) // 2\n    left = mergeKLists(lists[:mid])\n    right = mergeKLists(lists[mid:])\n    return mergeTwoLists(left, right)\n\n# Assume mergeTwoLists is a helper function that merges two sorted linked lists.\n```",
				"options": ["a) O(N log k)", "b) O(N^2)", "c) O(N log N)", "d) O(kN)"],
				"explanation": "The time complexity of this recursive divide-and-conquer approach is O(N log k). This is because the list of k lists is repeatedly divided in half, and merging two lists takes O(N) time, where N is the total number of nodes across all lists. The depth of the recursion is log k, leading to the overall complexity.",
				"answer": "a",
				"topics": ["Linked List", "Divide and Conquer", "Complexity Analysis"]
			}
		]
	},
	{
		"slug": "swap-nodes-in-pairs",
		"title": "Swap Nodes in Pairs",
		"leetcodeUrl": "https://leetcode.com/problems/swap-nodes-in-pairs",
		"difficulty": "Medium",
		"topics": ["Linked List"],
		"content": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n\n**Example 1:**\n```\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\n```\n\n**Example 2:**\n```\nInput: head = []\nOutput: []\n```\n\n**Example 3:**\n```\nInput: head = [1]\nOutput: [1]\n```\n\n**Constraints:**\n- `0 <= Node.val <= 100`\n- The number of nodes in the list is in the range `[0, 100]`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct implementation for swapping nodes in pairs in a linked list?",
				"options": [
					"a) Use a dummy node to simplify edge cases and iterate through the list, swapping pairs iteratively.",
					"b) Recursively swap pairs by swapping the first two nodes and then calling the function on the rest of the list.",
					"c) Use a stack to store nodes in pairs and then pop them to swap their order.",
					"d) Traverse the list and swap values of nodes instead of nodes themselves."
				],
				"explanation": "The correct approach is to use a dummy node to handle edge cases easily and iterate through the list, swapping pairs iteratively. This ensures that the node connections are properly maintained without modifying node values, which is a constraint of the problem. Recursion can also be used effectively, but the iterative approach with a dummy node is often more straightforward and avoids potential stack overflow issues with deep recursion.",
				"answer": "a",
				"topics": ["Linked List", "Implementation"]
			},
			{
				"question": "In the following code for swapping nodes in pairs, which line contains a bug?\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef swapPairs(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev, current = dummy, head\n    while current and current.next:\n        first = current\n        second = current.next\n        # Swap\n        prev.next = second\n        first.next = second.next\n        second.next = first\n        # Move pointers\n        prev = first\n        current = first.next\n    return dummy.next\n```\n",
				"options": [
					"a) prev.next = second",
					"b) first.next = second.next",
					"c) second.next = first",
					"d) current = first.next"
				],
				"explanation": "The bug is in line d) `current = first.next`. After swapping, `first.next` should point to the node after the pair, which is correct. However, if `first.next` is None (end of list), `current` should be set to None, which is handled correctly in the loop condition. Thus, there is no bug in this line. The code is correct as is.",
				"answer": "d",
				"topics": ["Linked List", "Bug Spotting"]
			},
			{
				"question": "What is the time complexity of the iterative solution for swapping nodes in pairs in a linked list?",
				"options": [
					"a) O(n) because each node is visited once.",
					"b) O(n^2) because each swap operation takes linear time.",
					"c) O(log n) because the list is divided into pairs.",
					"d) O(1) because swaps are constant time operations."
				],
				"explanation": "The time complexity is O(n) because each node in the linked list is visited exactly once during the iteration. The swap operation itself is constant time, but since we iterate through the entire list, the overall complexity is linear in terms of the number of nodes.",
				"answer": "a",
				"topics": ["Linked List", "Complexity Analysis"]
			},
			{
				"question": "Consider the recursive approach to swap nodes in pairs. What is a potential downside of using recursion for this problem?",
				"options": [
					"a) It may lead to stack overflow for very large lists due to deep recursion.",
					"b) It is more difficult to implement than the iterative approach.",
					"c) It cannot handle lists with an odd number of nodes.",
					"d) It requires additional space for a stack to store nodes."
				],
				"explanation": "The potential downside of using recursion is that it may lead to stack overflow for very large lists due to deep recursion. Each recursive call adds a new frame to the call stack, and for very large lists, this can exceed the stack size limit, causing a stack overflow error.",
				"answer": "a",
				"topics": ["Linked List", "Recursion", "Complexity Analysis"]
			},
			{
				"question": "Which of the following modifications would allow the recursive solution to swap nodes in pairs to work in-place?",
				"options": [
					"a) Use a helper function to manage the recursion stack manually.",
					"b) Pass additional parameters to keep track of previous nodes.",
					"c) Use tail recursion to optimize stack usage.",
					"d) The recursive solution already works in-place as it swaps nodes directly."
				],
				"explanation": "The recursive solution already works in-place as it swaps nodes directly without using any additional data structures to store nodes. The recursion itself does not require extra space for node storage, only for the call stack, which is inherent to recursion.",
				"answer": "d",
				"topics": ["Linked List", "Recursion", "In-place Algorithms"]
			}
		]
	},
	{
		"slug": "reverse-nodes-in-k-group",
		"title": "25. Reverse Nodes in k-Group",
		"leetcodeUrl": "https://leetcode.com/problems/reverse-nodes-in-k-group",
		"difficulty": "Medium",
		"topics": ["Linked List", "Two Pointers"],
		"content": "Given the head of a linked list, reverse the nodes of the list `k` at a time, and return the modified list. `k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n**Example 1:**\n```\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n```\n\n**Example 2:**\n```\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n```\n\n**Constraints:**\n- The number of nodes in the list is `n`.\n- `1 <= k <= n <= 5000`\n- `0 <= Node.val <= 1000`\n\n**Follow-up:** Can you solve the problem in O(1) extra memory space?",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to reverse nodes in k-group in a linked list?",
				"options": [
					"Iterate through the list, reversing every k nodes using a stack.",
					"Use a recursive function to reverse k nodes at a time, then connect the reversed part to the rest of the list.",
					"Reverse the entire list first, then reverse every k nodes to restore the order.",
					"Use a queue to store nodes and reverse them in groups of k."
				],
				"explanation": "The correct approach is to use a recursive function to reverse k nodes at a time. This method allows you to reverse the nodes in groups of k and then connect the reversed part to the rest of the list. Iterating with a stack or queue is not efficient for this problem, and reversing the entire list first would not achieve the desired result.",
				"answer": "b",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "In the following implementation of reversing nodes in k-group, which line contains a bug?\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseKGroup(head, k):\n    def reverseLinkedList(head, k):\n        prev, curr = None, head\n        while k > 0:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n            k -= 1\n        return prev\n\n    count = 0\n    ptr = head\n    while count < k and ptr:\n        ptr = ptr.next\n        count += 1\n\n    if count == k:\n        reversedHead = reverseLinkedList(head, k)\n        head.next = reverseKGroup(ptr, k)  # BUG: Should be reversedHead.next\n        return reversedHead\n    return head\n```\nWhich line contains the bug and why does it still pass many test cases?",
				"options": [
					"head.next = reverseKGroup(ptr, k): because it should connect the reversed head's next to the result of reverseKGroup.",
					"return prev: because it should return the current node instead of prev.",
					"while count < k and ptr: because it should check for ptr first.",
					"prev, curr = None, head: because it should initialize curr to None."
				],
				"explanation": "The bug is in the line `head.next = reverseKGroup(ptr, k)`. It should be `reversedHead.next = reverseKGroup(ptr, k)` to correctly connect the reversed part to the rest of the list. It might pass some test cases where the list length is exactly a multiple of k, as the final connection might not affect the result.",
				"answer": "a",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "What is the time complexity of the optimal solution for reversing nodes in k-group in a linked list?",
				"options": [
					"O(n^2) because each group reversal takes O(k) time and there are n/k groups.",
					"O(n) because each node is processed a constant number of times.",
					"O(n log n) due to the recursive nature of the solution.",
					"O(k) because only k nodes are reversed at a time."
				],
				"explanation": "The time complexity is O(n) because each node in the linked list is processed a constant number of times. The reversal of each group of k nodes takes O(k) time, and since there are n/k such groups, the overall complexity is O(n).",
				"answer": "b",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "Consider the following code snippet for reversing nodes in k-group:\n```python\ndef reverseKGroup(head, k):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    while True:\n        tail = prev\n        for i in range(k):\n            tail = tail.next\n            if not tail:\n                return dummy.next\n        next_group = tail.next\n        # Reverse the k nodes\n        prev.next, tail.next = reverse(prev.next, tail)\n        prev = tail\n        tail.next = next_group\n```\nWhich line should be modified to correctly reverse the k nodes?",
				"options": [
					"prev.next, tail.next = reverse(prev.next, tail)",
					"tail.next = next_group",
					"prev = tail",
					"for i in range(k):"
				],
				"explanation": "The line `prev.next, tail.next = reverse(prev.next, tail)` should be modified to correctly reverse the k nodes. The reverse function should return the new head and tail of the reversed segment, and the connections should be updated accordingly. The current line assumes the reverse function returns the correct nodes, but it might not handle the connections properly.",
				"answer": "a",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "Which of the following modifications would allow the reverse nodes in k-group algorithm to work in-place while maintaining O(1) extra space complexity?",
				"options": [
					"Use a stack to store nodes temporarily during reversal.",
					"Use a recursive approach to reverse nodes, which inherently uses the call stack.",
					"Iterate through the list and reverse pointers directly without using additional data structures.",
					"Use a queue to manage nodes during the reversal process."
				],
				"explanation": "To achieve O(1) extra space complexity, you should iterate through the list and reverse pointers directly without using additional data structures. This approach modifies the pointers in-place and does not require extra space beyond a few pointers for iteration and reversal.",
				"answer": "c",
				"topics": ["Linked List", "Two Pointers"]
			}
		]
	},
	{
		"slug": "remove-duplicates-from-sorted-array",
		"title": "Remove Duplicates from Sorted Array",
		"leetcodeUrl": "https://leetcode.com/problems/remove-duplicates-from-sorted-array",
		"difficulty": "Easy",
		"topics": ["Array", "Two Pointers"],
		"content": "Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in `nums`.\n\nConsider the number of unique elements of `nums` to be `k`, to get accepted, you need to do the following things:\n- Change the array `nums` such that the first `k` elements of `nums` contain the unique elements in the order they were present in `nums` initially.\n- The remaining elements of `nums` are not important as well as the size of `nums`.\n- Return `k`.\n\n**Custom Judge:**\nThe judge will test your solution with the following code:\n```python\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n```\nIf all assertions pass, then your solution will be accepted.\n\n**Example 1:**\n```\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).\n```\n\n**Example 2:**\n```\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).\n```\n\n**Constraints:**\n- `1 <= nums.length <= 3 * 10^4`\n- `-100 <= nums[i] <= 100`\n- `nums` is sorted in non-decreasing order.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of the optimal solution for removing duplicates from a sorted array in-place?",
				"options": ["O(n^2)", "O(n log n)", "O(n)", "O(log n)"],
				"explanation": "The optimal solution for removing duplicates from a sorted array in-place uses a two-pointer technique, which involves iterating through the array once. This results in a time complexity of O(n), where n is the number of elements in the array.",
				"answer": "c",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following implementation for removing duplicates from a sorted array, which line contains a bug?\n```python\n1. def removeDuplicates(nums):\n2.     if not nums:\n3.         return 0\n4.     k = 0\n5.     for i in range(1, len(nums)):\n6.         if nums[i] != nums[k]:\n7.             k += 1\n8.             nums[k] = nums[i]\n9.     return k\n```\nWhy does it still pass some test cases?",
				"options": [
					"Line 4: k should be initialized to 1",
					"Line 5: range should start from 0",
					"Line 6: should compare nums[i] with nums[k-1]",
					"Line 9: should return k + 1"
				],
				"explanation": "The bug is in Line 9. The function should return k + 1 because k is the index of the last unique element, and the number of unique elements is k + 1. It still passes some test cases because the array is modified correctly, but the return value is off by one.",
				"answer": "d",
				"topics": ["Array", "Two Pointers", "Implementation Analysis"]
			},
			{
				"question": "In the context of removing duplicates from a sorted array, which of the following modifications would allow the solution to work in-place while maintaining the same time complexity?",
				"options": [
					"Use a hash set to track seen elements",
					"Sort the array again after removing duplicates",
					"Use two pointers to overwrite duplicates",
					"Allocate a new array for unique elements"
				],
				"explanation": "Using two pointers to overwrite duplicates is the correct approach to maintain the solution in-place with O(n) time complexity. The first pointer iterates through the array, while the second pointer keeps track of the position to overwrite with unique elements.",
				"answer": "c",
				"topics": ["Array", "Two Pointers", "Optimization Modifications"]
			},
			{
				"question": "Consider the following code snippet for removing duplicates from a sorted array:\n```python\ndef removeDuplicates(nums):\n    if not nums:\n        return 0\n    k = 0\n    for i in range(1, len(nums)):\n        if nums[i] != nums[k]:\n            k += 1\n            nums[k] = nums[i]\n    return k + 1\n```\nWhat is the space complexity of this solution?",
				"options": ["O(n)", "O(1)", "O(log n)", "O(n^2)"],
				"explanation": "The space complexity of this solution is O(1) because it uses a constant amount of extra space. The algorithm modifies the input array in-place without using any additional data structures that scale with the input size.",
				"answer": "b",
				"topics": ["Array", "Space Complexity"]
			}
		]
	},
	{
		"slug": "remove-element",
		"title": "Remove Element",
		"leetcodeUrl": "https://leetcode.com/problems/remove-element",
		"difficulty": "Easy",
		"topics": ["Array", "Two Pointers"],
		"content": "Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in-place. The order of the elements may be changed. Then return the number of elements in `nums` which are not equal to `val`.\n\nConsider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:\n\n- Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.\n- Return `k`.\n\n**Custom Judge:**\nThe judge will test your solution with the following code:\n\n```python\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length. It is sorted with no values equal to val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n```\n\nIf all assertions pass, then your solution will be accepted.\n\n**Example 1:**\n```\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return `k = 2`, with the first two elements of `nums` being `2`. It does not matter what you leave beyond the returned `k` (hence they are underscores).\n```\n\n**Example 2:**\n```\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return `k = 5`, with the first five elements of `nums` containing `0,1,4,0,3`. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned `k` (hence they are underscores).\n```\n\n**Constraints:**\n- `0 <= nums.length <= 100`\n- `0 <= nums[i] <= 50`\n- `0 <= val <= 100`",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of the optimal solution for the 'Remove Element' problem, where you need to remove all occurrences of a given value from an array in-place?",
				"options": ["O(n^2)", "O(n log n)", "O(n)", "O(1)"],
				"explanation": "The optimal solution for the 'Remove Element' problem involves iterating through the array once, using a two-pointer technique to overwrite elements that are not equal to the given value. This results in a time complexity of O(n), where n is the number of elements in the array.",
				"answer": "c",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following implementation of the 'Remove Element' problem, identify the bug:\n```python\ndef removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i\n```\nWhat is the issue with this code?",
				"options": [
					"The code does not handle the case when nums is empty.",
					"The code incorrectly modifies elements beyond the first i elements.",
					"The code does not return the correct number of elements after removal.",
					"The code does not handle the case when all elements are equal to val."
				],
				"explanation": "The provided code correctly implements the two-pointer technique to remove elements equal to val. It iterates through the array, copying elements that are not equal to val to the front of the array. The code handles all edge cases, including when nums is empty or when all elements are equal to val. Therefore, there is no bug in this implementation.",
				"answer": "b",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Consider the following code snippet for removing elements from an array:\n```python\ndef removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i\n```\nWhat is the space complexity of this solution?",
				"options": ["O(n)", "O(1)", "O(log n)", "O(n^2)"],
				"explanation": "The space complexity of this solution is O(1) because it uses a constant amount of extra space. The algorithm modifies the input array in place and does not use any additional data structures that grow with the input size.",
				"answer": "b",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "In the 'Remove Element' problem, which of the following scenarios would make a heap-based solution less efficient than the two-pointer approach?",
				"options": [
					"The array is very large, and the value to remove is rare.",
					"The array is small, and the value to remove is frequent.",
					"The array is sorted, and the value to remove is at the end.",
					"The array is unsorted, and the value to remove is at the beginning."
				],
				"explanation": "A heap-based solution would involve additional overhead for maintaining the heap structure, which is unnecessary for this problem. The two-pointer approach is optimal because it directly modifies the array in place with a single pass. In scenarios where the array is small and the value to remove is frequent, the two-pointer approach is more efficient due to its simplicity and lower constant factors.",
				"answer": "b",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following code for removing elements from an array, which line should be added to ensure the function works correctly?\n```python\ndef removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    ???\n    return i\n```\nWhat should replace ??? to ensure the function correctly handles the array?",
				"options": [
					"nums = nums[:i]",
					"nums[i:] = [None] * (len(nums) - i)",
					"nums.sort()",
					"del nums[i:]"
				],
				"explanation": "The function already correctly modifies the array in place and returns the number of elements not equal to val. The line to replace ??? is not necessary for the function to work correctly, as the problem statement specifies that the elements beyond the first k elements are not important. However, if you want to explicitly clear the elements beyond the first k, you could use `del nums[i:]`, but this is not required by the problem.",
				"answer": "d",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Analyze the time and space complexity of the following solution for the 'Remove Element' problem:\n```python\ndef removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i\n```\nWhat are the complexities?",
				"options": [
					"Time: O(n), Space: O(n)",
					"Time: O(n^2), Space: O(1)",
					"Time: O(n), Space: O(1)",
					"Time: O(n log n), Space: O(1)"
				],
				"explanation": "The time complexity of this solution is O(n) because it involves a single pass through the array. The space complexity is O(1) because it uses a constant amount of extra space, modifying the array in place without using additional data structures.",
				"answer": "c",
				"topics": ["Array", "Two Pointers"]
			}
		]
	},
	{
		"slug": "find-the-index-of-the-first-occurrence-in-a-string",
		"title": "Find the Index of the First Occurrence in a String",
		"leetcodeUrl": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string",
		"difficulty": "Easy",
		"topics": ["String"],
		"content": "Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.\n\n**Example 1:**\n```\nInput: haystack = \"sadbutsad\", needle = \"sad\"\nOutput: 0\nExplanation: \"sad\" occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.\n```\n\n**Example 2:**\n```\nInput: haystack = \"leetcode\", needle = \"leeto\"\nOutput: -1\nExplanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n```\n\n**Constraints:**\n- `1 <= haystack.length, needle.length <= 10^4`\n- `haystack` and `needle` consist of only lowercase English characters.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of the naive approach to find the index of the first occurrence of a substring in a string?",
				"options": ["O(n + m)", "O(n * m)", "O(n^2)", "O(m^2)"],
				"explanation": "The naive approach involves checking each possible starting position in the haystack (length n) and comparing the substring of length m. This results in a time complexity of O(n * m), where n is the length of the haystack and m is the length of the needle.",
				"answer": "b",
				"topics": ["String", "Complexity Analysis"]
			},
			{
				"question": "Given the following implementation to find the index of the first occurrence of a substring, which line contains a bug?\n```python\n1. def strStr(haystack, needle):\n2.     if not needle:\n3.         return 0\n4.     for i in range(len(haystack) - len(needle) + 1):\n5.         if haystack[i:i+len(needle)] == needle:\n6.             return i\n7.     return -1\n```\nWhy does it still pass many test cases?",
				"options": [
					"Line 2: if not needle: because it should check for empty haystack",
					"Line 4: range(len(haystack) - len(needle) + 1) because it may cause index out of range",
					"Line 5: if haystack[i:i+len(needle)] == needle: because slicing may be incorrect",
					"Line 6: return i because it should return i + 1"
				],
				"explanation": "The code is correct and does not contain a bug. The check on line 2 correctly handles the case where the needle is empty, returning 0 as specified. The range on line 4 is correctly calculated to avoid index out of range errors. The slicing on line 5 is correct, and line 6 correctly returns the index of the first occurrence. The code passes all test cases because it is implemented correctly.",
				"answer": "a",
				"topics": ["String", "Implementation Analysis"]
			},
			{
				"question": "Which of the following algorithms is most efficient for finding the index of the first occurrence of a substring in a string, given large input sizes?",
				"options": [
					"Naive approach",
					"KMP (Knuth-Morris-Pratt) algorithm",
					"Rabin-Karp algorithm",
					"Brute force with early stopping"
				],
				"explanation": "The KMP algorithm is most efficient for this problem as it preprocesses the pattern to allow for linear time complexity O(n + m), where n is the length of the haystack and m is the length of the needle. This is more efficient than the naive approach, which has a time complexity of O(n * m). The Rabin-Karp algorithm is also efficient but can have issues with hash collisions.",
				"answer": "b",
				"topics": ["String", "Algorithm Efficiency"]
			},
			{
				"question": "In the KMP algorithm, what is the purpose of the prefix table (also known as the \"partial match\" table)?",
				"options": [
					"To store the indices of the first occurrence of each character",
					"To keep track of the number of comparisons made",
					"To determine the next position to check in the haystack",
					"To avoid unnecessary comparisons by storing the longest prefix which is also a suffix"
				],
				"explanation": "The prefix table in the KMP algorithm is used to avoid unnecessary comparisons by storing the length of the longest prefix of the pattern which is also a suffix. This allows the algorithm to skip over parts of the haystack that have already been matched, improving efficiency.",
				"answer": "d",
				"topics": ["String", "KMP Algorithm"]
			},
			{
				"question": "Consider the following code snippet for finding the index of the first occurrence of a substring using the Rabin-Karp algorithm. Which line should be modified to handle hash collisions correctly?\n```python\n1. def rabinKarp(haystack, needle):\n2.     if len(needle) > len(haystack):\n3.         return -1\n4.     base = 256\n5.     mod = 101\n6.     needle_hash = 0\n7.     haystack_hash = 0\n8.     for i in range(len(needle)):\n9.         needle_hash = (needle_hash * base + ord(needle[i])) % mod\n10.        haystack_hash = (haystack_hash * base + ord(haystack[i])) % mod\n11.    for i in range(len(haystack) - len(needle) + 1):\n12.        if needle_hash == haystack_hash:\n13.            if haystack[i:i+len(needle)] == needle:\n14.                return i\n15.        if i < len(haystack) - len(needle):\n16.            haystack_hash = (haystack_hash * base - ord(haystack[i]) * (base ** len(needle)) + ord(haystack[i + len(needle)])) % mod\n17.    return -1\n```",
				"options": [
					"Line 12: if needle_hash == haystack_hash: because it should check for hash collisions",
					"Line 13: if haystack[i:i+len(needle)] == needle: because it should not slice the string",
					"Line 16: haystack_hash = (haystack_hash * base - ord(haystack[i]) * (base ** len(needle)) + ord(haystack[i + len(needle)])) % mod because it should handle negative values",
					"Line 17: return -1 because it should return a different value"
				],
				"explanation": "Line 16 should be modified to handle negative values correctly. In some cases, the hash value can become negative due to the subtraction operation. To handle this, you can add mod to the result before taking the modulus again, ensuring the hash value remains positive.",
				"answer": "c",
				"topics": ["String", "Rabin-Karp Algorithm"]
			}
		]
	},
	{
		"slug": "divide-two-integers",
		"title": "Divide Two Integers",
		"leetcodeUrl": "https://leetcode.com/problems/divide-two-integers",
		"difficulty": "Medium",
		"topics": ["Math", "Bit Manipulation"],
		"content": "Given two integers `dividend` and `divisor`, divide two integers without using `multiplication`, `division`, and `mod` operator. The integer division should truncate toward zero, which means losing its fractional part. For example, `8.345` would be truncated to `8`, and `-2.7335` would be truncated to `-2`. Return the quotient after dividing `dividend` by `divisor`.\n\nNote: Assume we are dealing with an environment that could only store integers within the 32-bits signed integer range: `[−2^31, 2^31 − 1]`. For this problem, if the quotient is strictly greater than `2^31 − 1`, then return `2^31 − 1`, and if the quotient is strictly less than `-2^31`, then return `-2^31`.\n\n**Example 1:**\n```\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\n```\n\n**Example 2:**\n```\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\n```\n\n**Constraints:**\n- `-2^31 <= dividend, divisor <= 2^31 - 1`\n- `divisor != 0`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to divide two integers without using multiplication, division, or mod operators?",
				"options": [
					"a) Use repeated subtraction until the dividend is less than the divisor.",
					"b) Use bit manipulation to perform division by shifting bits.",
					"c) Use a loop to add the divisor repeatedly until it exceeds the dividend.",
					"d) Use a recursive function to subtract the divisor from the dividend."
				],
				"explanation": "The correct approach is to use bit manipulation to perform division by shifting bits. This method involves shifting the divisor left until it is less than or equal to the dividend, then subtracting it from the dividend and repeating the process. This approach is efficient and works within the constraints of the problem.",
				"answer": "b",
				"topics": ["Math", "Bit Manipulation"]
			},
			{
				"question": "Given the following code snippet for dividing two integers, which line contains a bug that could lead to incorrect results?\n```python\n1. def divide(dividend, divisor):\n2.     if dividend == 0:\n3.         return 0\n4.     if divisor == 0:\n5.         raise ValueError(\"Divisor cannot be zero\")\n6.     negative = (dividend < 0) != (divisor < 0)\n7.     dividend, divisor = abs(dividend), abs(divisor)\n8.     quotient = 0\n9.     while dividend >= divisor:\n10.        temp, multiple = divisor, 1\n11.        while dividend >= (temp << 1):\n12.            temp <<= 1\n13.            multiple <<= 1\n14.        dividend -= temp\n15.        quotient += multiple\n16.    return -quotient if negative else quotient\n```\nWhich line contains the bug?",
				"options": [
					"a) Line 4: if divisor == 0: because it should handle division by zero differently.",
					"b) Line 11: while dividend >= (temp << 1): because it may cause overflow.",
					"c) Line 16: return -quotient if negative else quotient because it doesn't handle overflow cases.",
					"d) Line 7: dividend, divisor = abs(dividend), abs(divisor) because it doesn't account for edge cases."
				],
				"explanation": "The bug is in line 16. The code does not handle the overflow case where the result exceeds the 32-bit signed integer range. Specifically, when the dividend is -2^31 and the divisor is -1, the result should be clamped to 2^31 - 1, but the current implementation does not account for this.",
				"answer": "c",
				"topics": ["Math", "Bit Manipulation"]
			},
			{
				"question": "In the context of dividing two integers using bit manipulation, what is the time complexity of the algorithm?",
				"options": [
					"a) O(n), where n is the value of the dividend.",
					"b) O(log n), where n is the value of the dividend.",
					"c) O(log n), where n is the number of bits in the dividend.",
					"d) O(n^2), where n is the value of the dividend."
				],
				"explanation": "The time complexity of the algorithm is O(log n), where n is the value of the dividend. This is because the algorithm uses bit manipulation to efficiently find the quotient by shifting bits, which is a logarithmic operation relative to the size of the dividend.",
				"answer": "b",
				"topics": ["Math", "Bit Manipulation"]
			},
			{
				"question": "Which of the following modifications would allow the integer division algorithm to handle the edge case where the dividend is -2^31 and the divisor is -1?",
				"options": [
					"a) Add a check at the beginning to return 2^31 - 1 if dividend is -2^31 and divisor is -1.",
					"b) Use a larger integer type to store the result temporarily.",
					"c) Adjust the final result by adding 1 if the result is negative.",
					"d) Use floating-point arithmetic to handle large numbers."
				],
				"explanation": "The correct modification is to add a check at the beginning of the function to return 2^31 - 1 if the dividend is -2^31 and the divisor is -1. This handles the overflow case explicitly, as the result of this division exceeds the 32-bit signed integer range.",
				"answer": "a",
				"topics": ["Math", "Bit Manipulation"]
			},
			{
				"question": "Consider the following recursive approach to divide two integers. What is the time complexity of this approach?\n```python\n1. def divide(dividend, divisor):\n2.     if dividend < divisor:\n3.         return 0\n4.     sum = divisor\n5.     multiple = 1\n6.     while (sum + sum) <= dividend:\n7.         sum += sum\n8.         multiple += multiple\n9.     return multiple + divide(dividend - sum, divisor)\n```\nWhat is the time complexity?",
				"options": [
					"a) O(n), where n is the value of the dividend.",
					"b) O(log n), where n is the value of the dividend.",
					"c) O(n log n), where n is the value of the dividend.",
					"d) O(log^2 n), where n is the value of the dividend."
				],
				"explanation": "The time complexity of this recursive approach is O(log^2 n), where n is the value of the dividend. This is because each recursive call reduces the problem size by a factor of at least 2, leading to a logarithmic number of calls, and each call itself involves a logarithmic number of operations due to the doubling process.",
				"answer": "d",
				"topics": ["Math", "Bit Manipulation"]
			}
		]
	},
	{
		"slug": "substring-with-concatenation-of-all-words",
		"title": "Substring with Concatenation of All Words",
		"leetcodeUrl": "https://leetcode.com/problems/substring-with-concatenation-of-all-words",
		"difficulty": "Hard",
		"topics": ["String", "Sliding Window", "Hash Table", "Two Pointers"],
		"content": "You are given a string `s` and an array of strings `words`. All the strings of `words` are of the same length. A concatenated substring in `s` is a substring that contains all the strings of any permutation of `words` concatenated.\n\nFor example, if `words = [\"ab\", \"cd\", \"ef\"]`, then `\"abcdef\"`, `\"abefcd\"`, `\"cdabef\"`, `\"cdefab\"`, `\"efabcd\"`, and `\"efcdab\"` are all concatenated strings. `\"acdbef\"` is not a concatenated substring because it is not the concatenation of any permutation of `words`.\n\nReturn the starting indices of all the concatenated substrings in `s`. You can return the answer in any order.\n\n**Example 1:**\n```\nInput: s = \"barfoothefoobarman\", words = [\"foo\", \"bar\"]\nOutput: [0, 9]\nExplanation: Since `words.length == 2` and `words[i].length == 3`, the concatenated substring has to be of length `6`. The substring starting at `0` is `\"barfoo\"`. It is the concatenation of [`\"bar\"`, `\"foo\"`] which is a permutation of `words`. The substring starting at `9` is `\"foobar\"`. It is the concatenation of [`\"foo\"`, `\"bar\"`] which is a permutation of `words`. The output order does not matter. Returning `[9, 0]` is fine too.\n```\n\n**Example 2:**\n```\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\", \"good\", \"best\", \"word\"]\nOutput: []\nExplanation: Since `words.length == 4` and `words[i].length == 4`, the concatenated substring has to be of length `16`. There is no substring of length `16` in `s` that is equal to the concatenation of any permutation of `words`. We return an empty array.\n```\n\n**Example 3:**\n```\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\", \"foo\", \"the\"]\nOutput: [6, 9, 12]\nExplanation: Since `words.length == 3` and `words[i].length == 3`, the concatenated substring has to be of length `9`. The substring starting at `6` is `\"foobarthe\"`. It is the concatenation of [`\"foo\"`, `\"bar\"`, `\"the\"`] which is a permutation of `words`. The substring starting at `9` is `\"barthefoo\"`. It is the concatenation of [`\"bar\"`, `\"the\"`, `\"foo\"`] which is a permutation of `words`. The substring starting at `12` is `\"thefoobar\"`. It is the concatenation of [`\"the\"`, `\"foo\"`, `\"bar\"`] which is a permutation of `words`.\n```\n\n**Constraints:**\n- `1 <= s.length <= 10^4`\n- `1 <= words.length <= 5000`\n- `1 <= words[i].length <= 30`\n- `s` and `words[i]` consist of lowercase English letters.",
		"rating": 2400,
		"MCQs": [
			{
				"question": "What is the primary challenge in solving the 'Substring with Concatenation of All Words' problem efficiently?",
				"options": [
					"Handling overlapping substrings in the input string.",
					"Ensuring all permutations of words are considered.",
					"Managing the large number of possible substrings due to input size.",
					"Dealing with variable word lengths in the input array."
				],
				"explanation": "The primary challenge is managing the large number of possible substrings due to the input size. The problem requires checking all possible starting points in the string for a valid concatenation of the words, which can be computationally expensive given the constraints.",
				"answer": "c",
				"topics": ["String", "Sliding Window", "Hash Table"]
			},
			{
				"question": "Given the following code snippet for finding concatenated substrings, which line contains a bug?\n```python\n1. def findSubstring(s, words):\n2.     if not s or not words:\n3.         return []\n4.     word_len = len(words[0])\n5.     num_words = len(words)\n6.     total_len = word_len * num_words\n7.     word_count = Counter(words)\n8.     result = []\n9.     for i in range(len(s) - total_len + 1):\n10.        seen = defaultdict(int)\n11.        for j in range(num_words):\n12.            word = s[i + j * word_len:i + (j + 1) * word_len]\n13.            if word not in word_count:\n14.                break\n15.            seen[word] += 1\n16.            if seen[word] > word_count[word]:\n17.                break\n18.        else:\n19.            result.append(i)\n20.    return result\n```",
				"options": [
					"Line 10: seen = defaultdict(int)",
					"Line 12: word = s[i + j * word_len:i + (j + 1) * word_len]",
					"Line 13: if word not in word_count:",
					"Line 16: if seen[word] > word_count[word]:"
				],
				"explanation": "The bug is in line 12: `word = s[i + j * word_len:i + (j + 1) * word_len]`. This line assumes that the substring extraction will always yield a valid word, but it doesn't handle cases where the substring length is less than `word_len` due to reaching the end of the string. This can lead to incorrect results if the substring is not a complete word.",
				"answer": "b",
				"topics": ["String", "Sliding Window", "Hash Table"]
			},
			{
				"question": "In the 'Substring with Concatenation of All Words' problem, which data structure is most suitable for tracking the frequency of words?",
				"options": ["List", "Set", "Dictionary", "Stack"],
				"explanation": "A dictionary (or hash map) is most suitable for tracking the frequency of words because it allows for efficient counting and lookup operations, which are necessary for comparing the frequency of words in the substring with the required frequency.",
				"answer": "c",
				"topics": ["Hash Table", "String"]
			},
			{
				"question": "Consider the following solution for finding concatenated substrings. Which line should replace the ??? to correctly handle overlapping substrings?\n```python\n1. def findSubstring(s, words):\n2.     if not s or not words:\n3.         return []\n4.     word_len = len(words[0])\n5.     num_words = len(words)\n6.     total_len = word_len * num_words\n7.     word_count = Counter(words)\n8.     result = []\n9.     for i in range(word_len):\n10.        left = i\n11.        seen = defaultdict(int)\n12.        count = 0\n13.        for j in range(i, len(s) - word_len + 1, word_len):\n14.            word = s[j:j + word_len]\n15.            if word in word_count:\n16.                seen[word] += 1\n17.                count += 1\n18.                while ???:\n19.                    left_word = s[left:left + word_len]\n20.                    seen[left_word] -= 1\n21.                    count -= 1\n22.                    left += word_len\n23.                if count == num_words:\n24.                    result.append(left)\n25.            else:\n26.                seen.clear()\n27.                count = 0\n28.                left = j + word_len\n29.    return result\n```",
				"options": [
					"seen[word] > word_count[word]",
					"count > num_words",
					"left < j",
					"seen[word] < word_count[word]"
				],
				"explanation": "The correct condition is `seen[word] > word_count[word]`. This ensures that if the current word's frequency exceeds the required frequency, we move the left pointer to reduce the count of the leftmost word, effectively sliding the window to maintain a valid substring.",
				"answer": "a",
				"topics": ["Sliding Window", "Hash Table", "String"]
			},
			{
				"question": "Analyze the time complexity of the following solution for the 'Substring with Concatenation of All Words' problem:\n```python\n1. def findSubstring(s, words):\n2.     if not s or not words:\n3.         return []\n4.     word_len = len(words[0])\n5.     num_words = len(words)\n6.     total_len = word_len * num_words\n7.     word_count = Counter(words)\n8.     result = []\n9.     for i in range(word_len):\n10.        left = i\n11.        seen = defaultdict(int)\n12.        count = 0\n13.        for j in range(i, len(s) - word_len + 1, word_len):\n14.            word = s[j:j + word_len]\n15.            if word in word_count:\n16.                seen[word] += 1\n17.                count += 1\n18.                while seen[word] > word_count[word]:\n19.                    left_word = s[left:left + word_len]\n20.                    seen[left_word] -= 1\n21.                    count -= 1\n22.                    left += word_len\n23.                if count == num_words:\n24.                    result.append(left)\n25.            else:\n26.                seen.clear()\n27.                count = 0\n28.                left = j + word_len\n29.    return result\n```",
				"options": [
					"O(n * m), where n is the length of s and m is the number of words",
					"O(n * m * k), where n is the length of s, m is the number of words, and k is the word length",
					"O(n * k), where n is the length of s and k is the word length",
					"O(n), where n is the length of s"
				],
				"explanation": "The time complexity is O(n * m * k), where n is the length of the string s, m is the number of words, and k is the length of each word. This is because for each starting point in the string, we potentially check m words, and each check involves operations proportional to the word length k.",
				"answer": "b",
				"topics": ["Complexity Analysis", "String", "Sliding Window"]
			}
		]
	},
	{
		"slug": "next-permutation",
		"title": "Next Permutation",
		"leetcodeUrl": "https://leetcode.com/problems/next-permutation",
		"difficulty": "Medium",
		"topics": ["Array", "Two Pointers"],
		"content": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for `arr = [1,2,3]`, the following are all the permutations of `arr`: `[1,2,3]`, `[1,3,2]`, `[2,1,3]`, `[2,3,1]`, `[3,1,2]`, `[3,2,1]`. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`. Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`. While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographically larger rearrangement.\n\nGiven an array of integers `nums`, find the next permutation of `nums`. The replacement must be in place and use only constant extra memory.\n\n**Example 1:**\n```\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n```\n\n**Example 2:**\n```\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n```\n\n**Example 3:**\n```\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n```\n\n**Constraints:**\n- `1 <= nums.length <= 100`\n- `0 <= nums[i] <= 100`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the primary goal of the 'next permutation' algorithm?",
				"options": [
					"To find the next lexicographically smaller permutation of the array.",
					"To find the next lexicographically greater permutation of the array.",
					"To sort the array in descending order.",
					"To find the previous permutation of the array."
				],
				"explanation": "The 'next permutation' algorithm aims to find the next lexicographically greater permutation of the array. If no such permutation exists (i.e., the array is sorted in descending order), it rearranges the array to the lowest possible order (sorted in ascending order).",
				"answer": "b",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following code snippet for finding the next permutation, which line contains a bug?\n```python\n1. def nextPermutation(nums):\n2.     i = len(nums) - 2\n3.     while i >= 0 and nums[i] >= nums[i + 1]:\n4.         i -= 1\n5.     if i >= 0:\n6.         j = len(nums) - 1\n7.         while nums[j] <= nums[i]:\n8.             j -= 1\n9.         nums[i], nums[j] = nums[j], nums[i]\n10.    nums[i + 1:] = reversed(nums[i + 1:])\n```\nWhich line contains the bug and why?",
				"options": [
					"Line 3: The condition should be nums[i] > nums[i + 1]",
					"Line 7: The condition should be nums[j] < nums[i]",
					"Line 9: The swap should be nums[i], nums[j] = nums[j], nums[i] + 1",
					"Line 10: The reversal should start from i instead of i + 1"
				],
				"explanation": "The code correctly implements the next permutation algorithm. Line 3 checks for the first decreasing element from the end, and line 7 finds the smallest element larger than nums[i] to swap. Line 9 swaps these elements, and line 10 reverses the suffix to get the next permutation. There is no bug in the provided code.",
				"answer": "a",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "In the next permutation algorithm, why is it necessary to reverse the subarray after the swap?",
				"options": [
					"To ensure the subarray is sorted in descending order.",
					"To ensure the subarray is sorted in ascending order, forming the smallest possible permutation.",
					"To maintain the original order of the subarray.",
					"To maximize the lexicographical order of the subarray."
				],
				"explanation": "After swapping, the subarray to the right of the swapped element must be reversed to form the smallest possible permutation, ensuring the next permutation is the smallest lexicographical order greater than the current one.",
				"answer": "b",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Consider the following scenario: You have an array `nums = [1, 3, 2, 4]`. What will be the array after applying the next permutation algorithm?",
				"options": [
					"[1, 3, 4, 2]",
					"[1, 2, 3, 4]",
					"[1, 4, 2, 3]",
					"[2, 1, 3, 4]"
				],
				"explanation": "The next permutation algorithm will find the first decreasing element from the end, which is 2. It will then find the smallest element larger than 2, which is 4, and swap them. The subarray after the swap (3, 2) is reversed to form the smallest permutation, resulting in [1, 3, 4, 2].",
				"answer": "a",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Which of the following scenarios would result in the array being rearranged to its lowest possible order (sorted in ascending order) when applying the next permutation algorithm?",
				"options": [
					"The array is already sorted in ascending order.",
					"The array is sorted in descending order.",
					"The array has all identical elements.",
					"The array has a single element."
				],
				"explanation": "When the array is sorted in descending order, it is the largest possible permutation. Therefore, the next permutation is the smallest possible permutation, which is the array sorted in ascending order.",
				"answer": "b",
				"topics": ["Array", "Two Pointers"]
			}
		]
	},
	{
		"slug": "longest-valid-parentheses",
		"title": "Longest Valid Parentheses",
		"leetcodeUrl": "https://leetcode.com/problems/longest-valid-parentheses",
		"difficulty": "Medium",
		"topics": ["Dynamic Programming", "Stack"],
		"content": "Given a string containing just the characters `(` and `)`, return the length of the longest valid (well-formed) parentheses substring.\n\n**Example 1:**\n```\nInput: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".\n```\n\n**Example 2:**\n```\nInput: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".\n```\n\n**Example 3:**\n```\nInput: s = \"\"\nOutput: 0\n```\n\n**Constraints:**\n- `0 <= s.length <= 3 * 10^4`\n- `s[i]` is `(`, or `)`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following approaches can be used to solve the Longest Valid Parentheses problem efficiently?",
				"options": [
					"Using a stack to track indices of unmatched parentheses",
					"Using dynamic programming to store the length of valid substrings",
					"Using a two-pointer technique to count open and close parentheses",
					"All of the above"
				],
				"explanation": "All the mentioned approaches can be used to solve the Longest Valid Parentheses problem. A stack can be used to track indices of unmatched parentheses, dynamic programming can store the length of valid substrings ending at each index, and a two-pointer technique can count open and close parentheses from both directions to find valid substrings.",
				"answer": "d",
				"topics": ["Dynamic Programming", "Stack"]
			},
			{
				"question": "Given the following code snippet for finding the longest valid parentheses, which line contains a bug?\n```python\n1. def longestValidParentheses(s):\n2.     stack = [-1]\n3.     max_length = 0\n4.     for i, char in enumerate(s):\n5.         if char == '(': \n6.             stack.append(i)\n7.         else:\n8.             stack.pop()\n9.             if not stack:\n10.                stack.append(i)\n11.            else:\n12.                max_length = max(max_length, i - stack[-1])\n13.    return max_length\n```\n",
				"options": [
					"Line 6: stack.append(i) should be stack.append(char)",
					"Line 8: stack.pop() should be stack.pop(i)",
					"Line 10: stack.append(i) should be stack.append(-1)",
					"No bug, the code is correct"
				],
				"explanation": "The code is correct. The stack is used to store indices, not characters, so line 6 is correct. Line 8 correctly pops the last index, and line 10 correctly appends the current index when the stack is empty. The logic correctly calculates the length of valid parentheses.",
				"answer": "d",
				"topics": ["Stack", "Implementation"]
			},
			{
				"question": "Consider the following dynamic programming approach to solve the Longest Valid Parentheses problem. Which line should replace the ??? to correctly update the dp array?\n```python\n1. def longestValidParentheses(s):\n2.     if not s:\n3.         return 0\n4.     dp = [0] * len(s)\n5.     max_length = 0\n6.     for i in range(1, len(s)):\n7.         if s[i] == ')':\n8.             if s[i-1] == '(':  # Case \"...()\"\n9.                 dp[i] = ???\n10.            elif i - dp[i-1] > 0 and s[i - dp[i-1] - 1] == '(':  # Case \"...))\"\n11.                dp[i] = dp[i-1] + 2 + (dp[i - dp[i-1] - 2] if i - dp[i-1] >= 2 else 0)\n12.            max_length = max(max_length, dp[i])\n13.    return max_length\n```",
				"options": [
					"dp[i] = 2",
					"dp[i] = dp[i-1] + 2",
					"dp[i] = dp[i-2] + 2",
					"dp[i] = 2 + dp[i-2]"
				],
				"explanation": "The correct line is `dp[i] = 2` because when s[i] is ')' and s[i-1] is '(', it forms a valid pair '()', so the length of valid parentheses ending at i is 2.",
				"answer": "a",
				"topics": ["Dynamic Programming", "Implementation"]
			},
			{
				"question": "Analyze the time and space complexity of the stack-based solution for the Longest Valid Parentheses problem:\n```python\n1. def longestValidParentheses(s):\n2.     stack = [-1]\n3.     max_length = 0\n4.     for i, char in enumerate(s):\n5.         if char == '(': \n6.             stack.append(i)\n7.         else:\n8.             stack.pop()\n9.             if not stack:\n10.                stack.append(i)\n11.            else:\n12.                max_length = max(max_length, i - stack[-1])\n13.    return max_length\n```",
				"options": [
					"Time: O(n), Space: O(n)",
					"Time: O(n^2), Space: O(n)",
					"Time: O(n), Space: O(1)",
					"Time: O(n^2), Space: O(1)"
				],
				"explanation": "The time complexity is O(n) because we iterate through the string once, and each operation on the stack (push and pop) is O(1). The space complexity is O(n) because in the worst case, the stack can store all indices of the string.",
				"answer": "a",
				"topics": ["Stack", "Complexity Analysis"]
			},
			{
				"question": "Which of the following modifications would optimize the space usage of the dynamic programming solution for the Longest Valid Parentheses problem while maintaining the same time complexity?",
				"options": [
					"Use a single integer to track the current valid length",
					"Use a two-pointer technique instead of a dp array",
					"Store only the last two values of the dp array",
					"Use a stack to track indices instead of a dp array"
				],
				"explanation": "Using a two-pointer technique instead of a dp array would optimize space usage to O(1) while maintaining the same O(n) time complexity. The two-pointer technique counts open and close parentheses from both directions to find valid substrings.",
				"answer": "b",
				"topics": ["Dynamic Programming", "Optimization"]
			}
		]
	},
	{
		"slug": "search-in-rotated-sorted-array",
		"title": "Search in Rotated Sorted Array",
		"leetcodeUrl": "https://leetcode.com/problems/search-in-rotated-sorted-array",
		"difficulty": "Medium",
		"topics": ["Array", "Binary Search"],
		"content": "There is an integer array `nums` sorted in ascending order (with distinct values). Prior to being passed to your function, `nums` is possibly rotated at an unknown pivot index `k` (1 <= k < nums.length) such that the resulting array is `[nums[k], nums[k+1],...,nums[n-1],nums[0],nums[1],...,nums[k-1]]` (0-indexed). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index 3 and become `[4,5,6,7,0,1,2]`. Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.  \n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n**Example 1:**\n```\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n```\n\n**Example 2:**\n```\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\n```\n\n**Example 3:**\n```\nInput: nums = [1], target = 0\nOutput: -1\n```\n\n**Constraints:**\n- `1 <= nums.length <= 5000`\n- `-10^4 <= nums[i] <= 10^4`\n- All values of `nums` are unique.\n- `nums` is an ascending array that is possibly rotated.\n- `-10^4 <= target <= 10^4`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following statements is true about the binary search algorithm when applied to a rotated sorted array?",
				"options": [
					"Binary search can be directly applied without modifications.",
					"The array must be unrotated before applying binary search.",
					"Binary search can be applied with modifications to handle the rotation.",
					"Binary search is not applicable to rotated sorted arrays."
				],
				"explanation": "Binary search can be applied to a rotated sorted array with modifications. The key is to determine which part of the array (left or right of the mid-point) is sorted and then decide which part to discard based on the target value.",
				"answer": "c",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "Given the following code snippet for searching in a rotated sorted array, which line contains a bug?\n```python\n1. def search(nums, target):\n2.     left, right = 0, len(nums) - 1\n3.     while left <= right:\n4.         mid = (left + right) // 2\n5.         if nums[mid] == target:\n6.             return mid\n7.         if nums[left] <= nums[mid]:\n8.             if nums[left] <= target < nums[mid]:\n9.                 right = mid - 1\n10.            else:\n11.                left = mid + 1\n12.        else:\n13.            if nums[mid] < target <= nums[right]:\n14.                left = mid + 1\n15.            else:\n16.                right = mid - 1\n17.    return -1\n```",
				"options": [
					"Line 7: if nums[left] <= nums[mid]:",
					"Line 8: if nums[left] <= target < nums[mid]:",
					"Line 13: if nums[mid] < target <= nums[right]:",
					"Line 16: right = mid - 1"
				],
				"explanation": "The code correctly implements binary search on a rotated sorted array. The conditions in lines 7, 8, and 13 correctly identify the sorted half of the array and adjust the search range accordingly. There is no bug in the provided code snippet.",
				"answer": "d",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "In the context of searching in a rotated sorted array, which of the following scenarios would cause the binary search to perform more comparisons than usual?",
				"options": [
					"The array is rotated at the middle index.",
					"The target is the smallest element in the array.",
					"The array is not rotated at all.",
					"The target is not present in the array."
				],
				"explanation": "When the target is not present in the array, the binary search will have to explore all possible paths until the search range is exhausted, leading to more comparisons than if the target were found early.",
				"answer": "d",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "Consider the following code for searching in a rotated sorted array. What is the time complexity of this algorithm?\n```python\n1. def search(nums, target):\n2.     left, right = 0, len(nums) - 1\n3.     while left <= right:\n4.         mid = (left + right) // 2\n5.         if nums[mid] == target:\n6.             return mid\n7.         if nums[left] <= nums[mid]:\n8.             if nums[left] <= target < nums[mid]:\n9.                 right = mid - 1\n10.            else:\n11.                left = mid + 1\n12.        else:\n13.            if nums[mid] < target <= nums[right]:\n14.                left = mid + 1\n15.            else:\n16.                right = mid - 1\n17.    return -1\n```",
				"options": ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
				"explanation": "The algorithm uses a modified binary search approach, which divides the search space in half at each step, leading to a time complexity of O(log n).",
				"answer": "b",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "Which of the following modifications would allow the search algorithm to handle arrays with duplicate elements while maintaining O(log n) complexity?",
				"options": [
					"Use a linear search instead of binary search.",
					"Modify the conditions to handle equal elements by adjusting both left and right pointers.",
					"Sort the array before applying binary search.",
					"Use a hash map to store element indices."
				],
				"explanation": "To handle duplicates while maintaining O(log n) complexity, you can modify the conditions to adjust both left and right pointers when encountering equal elements, ensuring the search space is reduced appropriately.",
				"answer": "b",
				"topics": ["Array", "Binary Search"]
			}
		]
	},
	{
		"slug": "find-first-and-last-position-of-element-in-sorted-array",
		"title": "Find First and Last Position of Element in Sorted Array",
		"leetcodeUrl": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array",
		"difficulty": "Medium",
		"topics": ["Array", "Binary Search"],
		"content": "Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given target value. If the target is not found in the array, return `[-1,-1]`. You must write an algorithm with `O(log n)` runtime complexity.\n\n**Example 1:**\n```\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\n```\n\n**Example 2:**\n```\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\n```\n\n**Example 3:**\n```\nInput: nums = [], target = 0\nOutput: [-1,-1]\n```\n\n**Constraints:**\n- `0 <= nums.length <= 10^5`\n- `-10^9 <= nums[i] <= 10^9`\n- `nums` is a non-decreasing array.\n- `-10^9 <= target <= 10^9`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following algorithms is most suitable for finding the first and last position of a target element in a sorted array with O(log n) complexity?",
				"options": ["Linear Search", "Binary Search", "Hash Map", "Merge Sort"],
				"explanation": "Binary Search is the most suitable algorithm for this problem because it can efficiently find the target element's position in a sorted array with O(log n) complexity. Linear Search would take O(n) time, Hash Map is not applicable here, and Merge Sort is a sorting algorithm, not a searching one.",
				"answer": "b",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "Given the following code snippet for finding the first and last position of a target in a sorted array, which line contains a bug?\n```python\n1. def searchRange(nums, target):\n2.     def findLeft(nums, target):\n3.         left, right = 0, len(nums) - 1\n4.         while left < right:\n5.             mid = (left + right) // 2\n6.             if nums[mid] < target:\n7.                 left = mid + 1\n8.             else:\n9.                 right = mid\n10.        return left\n11.    \n12.    def findRight(nums, target):\n13.        left, right = 0, len(nums) - 1\n14.        while left < right:\n15.            mid = (left + right) // 2\n16.            if nums[mid] <= target:\n17.                left = mid + 1\n18.            else:\n19.                right = mid\n20.        return right - 1\n21.    \n22.    left, right = findLeft(nums, target), findRight(nums, target)\n23.    if left <= right and nums[left] == target and nums[right] == target:\n24.        return [left, right]\n25.    return [-1, -1]\n```",
				"options": [
					"Line 4: while left < right:",
					"Line 9: right = mid",
					"Line 15: mid = (left + right) // 2",
					"Line 20: return right - 1"
				],
				"explanation": "The bug is in Line 20: `return right - 1`. The `findRight` function should return `right` instead of `right - 1` because the loop condition `left < right` ensures that `right` is the first position greater than the target, so `right - 1` would be the last occurrence of the target.",
				"answer": "d",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "In the context of finding the first and last position of a target in a sorted array, what is the time complexity of the following approach?\n1. Use binary search to find the first occurrence of the target.\n2. Use binary search to find the last occurrence of the target.\n3. Return the indices of the first and last occurrences.\n",
				"options": ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
				"explanation": "The time complexity of using binary search twice (once for the first occurrence and once for the last occurrence) is O(log n) + O(log n) = O(log n). This is because each binary search operation takes O(log n) time in a sorted array.",
				"answer": "b",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "Consider the following scenario: You have a sorted array with 10^5 elements, and you need to find the first and last position of a target element. Which of the following statements is true regarding the efficiency of using a binary search approach?",
				"options": [
					"The binary search approach will take O(n) time, which is efficient for this input size.",
					"The binary search approach will take O(log n) time, which is efficient for this input size.",
					"The binary search approach will take O(n log n) time, which is inefficient for this input size.",
					"The binary search approach will take O(1) time, which is the most efficient."
				],
				"explanation": "The binary search approach will take O(log n) time, which is efficient for a sorted array of size 10^5. This is because binary search reduces the search space by half with each iteration, making it very efficient for large arrays.",
				"answer": "b",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "In the given problem of finding the first and last position of a target in a sorted array, which of the following edge cases should be considered to ensure the algorithm works correctly?",
				"options": [
					"The target is not present in the array.",
					"The target is present at the beginning of the array.",
					"The target is present at the end of the array.",
					"All of the above."
				],
				"explanation": "All of the above edge cases should be considered. The algorithm should correctly handle cases where the target is not present, as well as when the target is at the beginning or end of the array, to ensure it returns the correct indices or [-1, -1] if the target is not found.",
				"answer": "d",
				"topics": ["Array", "Binary Search"]
			}
		]
	},
	{
		"slug": "search-insert-position",
		"title": "Search Insert Position",
		"leetcodeUrl": "https://leetcode.com/problems/search-insert-position",
		"difficulty": "Easy",
		"topics": ["Array", "Binary Search"],
		"content": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n**Example 1:**\n```\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\n```\n\n**Example 2:**\n```\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n```\n\n**Constraints:**\n- `1 <= nums.length <= 10^4`\n- `-10^4 <= nums[i] <= 10^4`\n- `nums` contains distinct values sorted in ascending order.\n- `-10^4 <= target <= 10^4`",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of the binary search algorithm used to solve the 'Search Insert Position' problem?",
				"options": ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
				"explanation": "The binary search algorithm divides the search interval in half each time, leading to a logarithmic time complexity of O(log n). This is efficient for searching in a sorted array.",
				"answer": "b",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "Consider the following implementation of the 'Search Insert Position' problem. Identify the bug in the code:\n```python\n1. def searchInsert(nums, target):\n2.     left, right = 0, len(nums) - 1\n3.     while left <= right:\n4.         mid = (left + right) // 2\n5.         if nums[mid] == target:\n6.             return mid\n7.         elif nums[mid] < target:\n8.             left = mid + 1\n9.         else:\n10.            right = mid - 1\n11.    return left\n```\nWhat is the issue with this implementation?",
				"options": [
					"The condition in line 3 should be 'left < right'.",
					"The calculation of 'mid' in line 4 should use 'left + (right - left) // 2'.",
					"The return statement in line 11 should be 'return right'.",
					"There is no bug; the implementation is correct."
				],
				"explanation": "The implementation is correct. The binary search is properly implemented to find the target or the insert position if the target is not found. The return statement 'return left' correctly returns the position where the target should be inserted.",
				"answer": "d",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "Given the following code snippet for finding the search insert position, which line should be modified to handle the case where the array is empty?\n```python\n1. def searchInsert(nums, target):\n2.     left, right = 0, len(nums) - 1\n3.     while left <= right:\n4.         mid = (left + right) // 2\n5.         if nums[mid] == target:\n6.             return mid\n7.         elif nums[mid] < target:\n8.             left = mid + 1\n9.         else:\n10.            right = mid - 1\n11.    return left\n```",
				"options": [
					"Add 'if not nums: return 0' after line 1.",
					"Change 'left <= right' to 'left < right' in line 3.",
					"Modify 'return left' to 'return right' in line 11.",
					"Add 'if len(nums) == 0: return -1' after line 1."
				],
				"explanation": "To handle the case where the array is empty, you should add a check at the beginning of the function. Adding 'if not nums: return 0' after line 1 ensures that if the array is empty, the function returns 0, which is the correct insert position for any target.",
				"answer": "a",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "Which of the following scenarios would cause the binary search algorithm to perform poorly in terms of time complexity?",
				"options": [
					"The array is sorted in descending order.",
					"The array contains duplicate elements.",
					"The target is not present in the array.",
					"The array is very large, but the target is near the beginning."
				],
				"explanation": "Binary search requires the array to be sorted in ascending order to function correctly. If the array is sorted in descending order, the algorithm will not work as intended, leading to incorrect results or infinite loops. However, the time complexity remains O(log n) as long as the array is sorted in some order.",
				"answer": "a",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "In the 'Search Insert Position' problem, what is the space complexity of the binary search algorithm?",
				"options": ["O(n)", "O(log n)", "O(1)", "O(n log n)"],
				"explanation": "The space complexity of the binary search algorithm is O(1) because it uses a constant amount of extra space, regardless of the input size. The algorithm only requires a few variables to keep track of the indices and the target value.",
				"answer": "c",
				"topics": ["Array", "Binary Search"]
			}
		]
	},
	{
		"slug": "valid-sudoku",
		"title": "Valid Sudoku",
		"leetcodeUrl": "https://leetcode.com/problems/valid-sudoku",
		"difficulty": "Medium",
		"topics": ["Array", "Hash Table"],
		"content": "Determine if a `9x9` Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n- Each row must contain the digits `1-9` without repetition.\n- Each column must contain the digits `1-9` without repetition.\n- Each of the nine `3x3` sub-boxes of the grid must contain the digits `1-9` without repetition.\n\nNote: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.\n\n**Example 1:**\n```\nInput: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\n```\n\n**Example 2:**\n```\nInput: board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\n```\n\n**Constraints:**\n- `board.length == 9`\n- `board[i].length == 9`\n- `board[i][j]` is a digit `1-9` or `'.'`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a necessary condition for a Sudoku board to be valid?",
				"options": [
					"Each row must contain unique digits from 1 to 9.",
					"Each column must contain unique digits from 1 to 9.",
					"Each 3x3 sub-box must contain unique digits from 1 to 9.",
					"All of the above."
				],
				"explanation": "A valid Sudoku board must satisfy all three conditions: each row, each column, and each 3x3 sub-box must contain unique digits from 1 to 9. If any of these conditions are violated, the board is not valid.",
				"answer": "d",
				"topics": ["Array", "Hash Table"]
			},
			{
				"question": "Given the following code snippet for checking the validity of a Sudoku board, which line contains a bug?\n```python\n1. def isValidSudoku(board):\n2.     rows = [set() for _ in range(9)]\n3.     cols = [set() for _ in range(9)]\n4.     boxes = [set() for _ in range(9)]\n5.     for r in range(9):\n6.         for c in range(9):\n7.             if board[r][c] == '.':\n8.                 continue\n9.             if board[r][c] in rows[r]:\n10.                return False\n11.            if board[r][c] in cols[c]:\n12.                return False\n13.            box_index = (r // 3) * 3 + (c // 3)\n14.            if board[r][c] in boxes[box_index]:\n15.                return False\n16.            rows[r].add(board[r][c])\n17.            cols[c].add(board[r][c])\n18.            boxes[box_index].add(board[r][c])\n19.     return True\n```",
				"options": [
					"Line 9: if board[r][c] in rows[r]:",
					"Line 11: if board[r][c] in cols[c]:",
					"Line 13: box_index = (r // 3) * 3 + (c // 3)",
					"Line 14: if board[r][c] in boxes[box_index]:"
				],
				"explanation": "The code correctly checks for duplicates in rows, columns, and boxes. The calculation of box_index is correct, as it maps each cell to its corresponding 3x3 sub-box. There is no bug in the provided lines; the code is correct.",
				"answer": "c",
				"topics": ["Array", "Hash Table"]
			},
			{
				"question": "In the context of validating a Sudoku board, which of the following data structures is most appropriate for checking the uniqueness of digits in rows, columns, and boxes?",
				"options": ["List", "Set", "Dictionary", "Queue"],
				"explanation": "A set is the most appropriate data structure for checking uniqueness because it automatically handles duplicate entries by not allowing them. This makes it ideal for checking if a digit has already been encountered in a row, column, or box.",
				"answer": "b",
				"topics": ["Array", "Hash Table"]
			},
			{
				"question": "Consider the following code snippet for validating a Sudoku board. Which line should be added to correctly handle the validation of 3x3 sub-boxes?\n```python\n1. def isValidSudoku(board):\n2.     rows = [set() for _ in range(9)]\n3.     cols = [set() for _ in range(9)]\n4.     boxes = [set() for _ in range(9)]\n5.     for r in range(9):\n6.         for c in range(9):\n7.             if board[r][c] == '.':\n8.                 continue\n9.             if board[r][c] in rows[r]:\n10.                return False\n11.            if board[r][c] in cols[c]:\n12.                return False\n13.            ???\n14.            if board[r][c] in boxes[box_index]:\n15.                return False\n16.            rows[r].add(board[r][c])\n17.            cols[c].add(board[r][c])\n18.            boxes[box_index].add(board[r][c])\n19.     return True\n```",
				"options": [
					"box_index = (r // 3) * 3 + (c // 3)",
					"box_index = (r % 3) * 3 + (c % 3)",
					"box_index = (r // 3) + (c // 3) * 3",
					"box_index = (r % 3) + (c % 3) * 3"
				],
				"explanation": "The correct calculation for the index of the 3x3 sub-box is `box_index = (r // 3) * 3 + (c // 3)`. This formula maps each cell to its corresponding sub-box by dividing the row and column indices by 3 and combining them appropriately.",
				"answer": "a",
				"topics": ["Array", "Hash Table"]
			},
			{
				"question": "What is the time complexity of the provided solution for validating a Sudoku board?",
				"options": [
					"O(1) because the board size is fixed",
					"O(n) where n is the number of cells in the board",
					"O(n^2) where n is the number of cells in the board",
					"O(n^3) where n is the number of cells in the board"
				],
				"explanation": "The time complexity is O(1) because the board size is fixed at 9x9, meaning the number of operations is constant regardless of input size. However, if considering n as the number of cells, it would be O(n) since each cell is processed once.",
				"answer": "a",
				"topics": ["Array", "Hash Table"]
			},
			{
				"question": "In the context of validating a Sudoku board, which of the following scenarios would cause the validation to fail?",
				"options": [
					"A row contains two '5's.",
					"A column contains two '3's.",
					"A 3x3 sub-box contains two '7's.",
					"All of the above."
				],
				"explanation": "The validation will fail if any row, column, or 3x3 sub-box contains duplicate digits. Therefore, any of the scenarios listed would cause the validation to fail.",
				"answer": "d",
				"topics": ["Array", "Hash Table"]
			}
		]
	},
	{
		"slug": "37-sudoku-solver",
		"title": "37. Sudoku Solver",
		"leetcodeUrl": "https://leetcode.com/problems/37-sudoku-solver",
		"difficulty": "Hard",
		"topics": ["Backtracking", "Matrix"],
		"content": "Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules:\n\n- Each of the digits `1-9` must occur exactly once in each row.\n- Each of the digits `1-9` must occur exactly once in each column.\n- Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n\nThe `'.'` character indicates empty cells.\n\n**Example 1:**\n```\nInput:\nboard = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n         [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n         [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n         [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n         [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n         [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n         [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n         [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n         [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],\n [\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],\n [\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n [\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n [\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n [\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],\n [\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n [\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n [\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n```\n\n**Constraints:**\n- `board.length == 9`\n- `board[i].length == 9`\n- `board[i][j]` is a digit or `'.'`\n- It is guaranteed that the input board has only one solution.",
		"rating": 2400,
		"MCQs": [
			{
				"question": "Which of the following is a necessary condition for a valid Sudoku board?",
				"options": [
					"Each row must contain the digits 1-9 without repetition.",
					"Each column must contain the digits 1-9 without repetition.",
					"Each 3x3 sub-box must contain the digits 1-9 without repetition.",
					"All of the above."
				],
				"explanation": "A valid Sudoku board must satisfy all three conditions: each row, each column, and each 3x3 sub-box must contain the digits 1-9 without repetition. This ensures that the board is correctly filled according to Sudoku rules.",
				"answer": "d",
				"topics": ["Backtracking", "Matrix"]
			},
			{
				"question": "In a backtracking solution for solving Sudoku, which of the following steps is crucial for ensuring the algorithm explores all possible configurations?",
				"options": [
					"Checking if the current board configuration is valid before proceeding.",
					"Filling the first empty cell with a random number and proceeding.",
					"Backtracking when a number placement leads to an invalid configuration.",
					"Using a heuristic to fill cells in a specific order."
				],
				"explanation": "Backtracking involves exploring all possible configurations by placing numbers and checking if they lead to a valid solution. If a placement leads to an invalid configuration, the algorithm must backtrack and try a different number. This ensures that all possibilities are explored.",
				"answer": "c",
				"topics": ["Backtracking", "Matrix"]
			},
			{
				"question": "Given the following partial implementation of a Sudoku solver, identify the missing line that correctly checks if a number can be placed in a given cell:\n```python\ndef is_valid(board, row, col, num):\n    # Check row\n    for i in range(9):\n        if board[row][i] == num:\n            return False\n    # Check column\n    for i in range(9):\n        if board[i][col] == num:\n            return False\n    # Check 3x3 sub-box\n    start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n    for i in range(3):\n        for j in range(3):\n            if ???:\n                return False\n    return True\n```",
				"options": [
					"board[start_row + i][start_col + j] == num",
					"board[start_row + j][start_col + i] == num",
					"board[start_row + i][start_col + j] != num",
					"board[start_row + j][start_col + i] != num"
				],
				"explanation": "The missing line should check if the number already exists in the 3x3 sub-box. The correct condition is `board[start_row + i][start_col + j] == num`, which iterates over the 3x3 sub-box starting from the calculated starting row and column.",
				"answer": "a",
				"topics": ["Backtracking", "Matrix"]
			},
			{
				"question": "Consider the following recursive backtracking function for solving Sudoku. Which line contains a bug that could cause the function to fail in certain cases?\n```python\ndef solve_sudoku(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == '.':\n                for num in map(str, range(1, 10)):\n                    if is_valid(board, i, j, num):\n                        board[i][j] = num\n                        if solve_sudoku(board):\n                            return True\n                        board[i][j] = '.'\n                return False\n    return True\n```",
				"options": [
					"if board[i][j] == '.':",
					"if is_valid(board, i, j, num):",
					"if solve_sudoku(board):",
					"board[i][j] = '.'"
				],
				"explanation": "The bug is in the line `if solve_sudoku(board):`. If the recursive call returns False, the function should continue trying other numbers, but the current implementation immediately returns False, which is correct. The function is implemented correctly, and the bug is a trick question.",
				"answer": "c",
				"topics": ["Backtracking", "Matrix"]
			},
			{
				"question": "Analyze the time complexity of the backtracking algorithm for solving a Sudoku puzzle. Assume the board is initially empty and you are trying to fill it completely.",
				"options": [
					"O(9^81) - because each cell can have 9 possibilities and there are 81 cells.",
					"O(81!) - because each cell must be filled in a specific order.",
					"O(9!) - because each row must contain unique numbers from 1 to 9.",
					"O(1) - because the solution is guaranteed to exist and is unique."
				],
				"explanation": "The time complexity of the backtracking algorithm is O(9^81) in the worst case because each of the 81 cells can potentially have 9 different numbers placed in it. This results in a large number of possible configurations to explore.",
				"answer": "a",
				"topics": ["Backtracking", "Matrix"]
			},
			{
				"question": "In the context of solving Sudoku using backtracking, which optimization can significantly reduce the search space and improve performance?",
				"options": [
					"Using a fixed order to fill cells from top-left to bottom-right.",
					"Prioritizing cells with the fewest possible valid numbers first.",
					"Filling all cells in a row before moving to the next row.",
					"Randomly selecting numbers to fill in each cell."
				],
				"explanation": "Prioritizing cells with the fewest possible valid numbers first is a heuristic that can significantly reduce the search space. This is known as the \"minimum remaining values\" heuristic and helps in quickly identifying constraints and reducing possibilities.",
				"answer": "b",
				"topics": ["Backtracking", "Matrix"]
			}
		]
	},
	{
		"slug": "count-and-say",
		"title": "Count and Say",
		"leetcodeUrl": "https://leetcode.com/problems/count-and-say",
		"difficulty": "Medium",
		"topics": ["String", "Recursion"],
		"content": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\n- `countAndSay(1) = \"1\"`\n- `countAndSay(n)` is the way you would \"say\" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n\nFor example, the saying and conversion for digit string `\"3322251\"`:\n\nGiven a positive integer `n`, return the nth term of the count-and-say sequence.\n\n**Example 1:**\n```\nInput: n = 1\nOutput: \"1\"\nExplanation: This is the base case.\n```\n\n**Example 2:**\n```\nInput: n = 4\nOutput: \"1211\"\nExplanation: `countAndSay(1) = \"1\"`, `countAndSay(2) =` say \"1\" = one 1 = \"11\", `countAndSay(3) =` say \"11\" = two 1's = \"21\", `countAndSay(4) =` say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n```\n\n**Constraints:**\n- `1 <= n <= 30`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of generating the nth term in the count-and-say sequence?",
				"options": ["O(n^2)", "O(2^n)", "O(n)", "O(n!)"],
				"explanation": "The time complexity of generating the nth term in the count-and-say sequence is O(2^n). This is because each term in the sequence can potentially double in length compared to the previous term, leading to exponential growth. The sequence is generated by iterating over the previous term and constructing the next term, which can take up to O(2^n) time in the worst case.",
				"answer": "b",
				"topics": ["String", "Recursion"]
			},
			{
				"question": "Given the following implementation of the count-and-say sequence, which line contains a bug?\n```python\n1. def countAndSay(n):\n2.     if n == 1:\n3.         return \"1\"\n4.     prev = countAndSay(n - 1)\n5.     result = \"\"\n6.     count = 1\n7.     for i in range(1, len(prev)):\n8.         if prev[i] == prev[i - 1]:\n9.             count += 1\n10.        else:\n11.            result += str(count) + prev[i - 1]\n12.            count = 1\n13.    result += str(count) + prev[-1]\n14.    return result\n```\nWhich line contains the bug and why?",
				"options": [
					"Line 4: Recursive call should be countAndSay(n - 2)",
					"Line 7: Loop should start from 0",
					"Line 11: Incorrect string concatenation",
					"Line 13: Missing reset of count variable"
				],
				"explanation": "The bug is in Line 7. The loop should start from 0, not 1, because the first character of the string needs to be processed as well. The current implementation skips the first character, leading to incorrect results for n > 1.",
				"answer": "b",
				"topics": ["String", "Recursion"]
			},
			{
				"question": "In the count-and-say sequence, what is the output for n = 5?",
				"options": ["\"111221\"", "\"312211\"", "\"13112221\"", "\"111211\""],
				"explanation": "For n = 5, the sequence is generated as follows:\n- countAndSay(1) = \"1\"\n- countAndSay(2) = \"11\" (one 1)\n- countAndSay(3) = \"21\" (two 1s)\n- countAndSay(4) = \"1211\" (one 2, one 1)\n- countAndSay(5) = \"111221\" (one 1, one 2, two 1s)\nThus, the output for n = 5 is \"111221\".",
				"answer": "a",
				"topics": ["String", "Recursion"]
			},
			{
				"question": "Which of the following optimizations can reduce the space complexity of the count-and-say sequence generation?",
				"options": [
					"Use a single string builder instead of multiple strings",
					"Implement memoization to store previous results",
					"Use a queue to process characters",
					"Iterate backwards to avoid extra space"
				],
				"explanation": "Using a single string builder instead of multiple strings can reduce the space complexity. This is because it avoids creating multiple intermediate strings, thus saving space. Memoization is not applicable here as each term depends on the previous one, and a queue or backward iteration does not inherently reduce space usage.",
				"answer": "a",
				"topics": ["String", "Recursion"]
			},
			{
				"question": "Consider the following code snippet for generating the count-and-say sequence:\n```python\n1. def countAndSay(n):\n2.     if n == 1:\n3.         return \"1\"\n4.     prev = countAndSay(n - 1)\n5.     result = []\n6.     count = 1\n7.     for i in range(1, len(prev)):\n8.         if prev[i] == prev[i - 1]:\n9.             count += 1\n10.        else:\n11.            result.append(str(count))\n12.            result.append(prev[i - 1])\n13.            count = 1\n14.    result.append(str(count))\n15.    result.append(prev[-1])\n16.    return ''.join(result)\n```\nWhat is the space complexity of this implementation?",
				"options": ["O(n)", "O(n^2)", "O(2^n)", "O(n!)"],
				"explanation": "The space complexity of this implementation is O(2^n). This is because the length of the sequence can potentially double with each term, leading to exponential growth in space usage. The use of a list to build the result string does not change the asymptotic space complexity.",
				"answer": "c",
				"topics": ["String", "Recursion"]
			}
		]
	},
	{
		"slug": "combination-sum",
		"title": "Combination Sum",
		"leetcodeUrl": "https://leetcode.com/problems/combination-sum",
		"difficulty": "Medium",
		"topics": ["Backtracking", "Array"],
		"content": "Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order. The same number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to `target` is less than 150 combinations for the given input.\n\n**Example 1:**\n```\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations.\n```\n\n**Example 2:**\n```\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n```\n\n**Example 3:**\n```\nInput: candidates = [2], target = 1\nOutput: []\n```\n\n**Constraints:**\n- `1 <= candidates.length <= 30`\n- `2 <= candidates[i] <= 40`\n- All elements of `candidates` are distinct.\n- `1 <= target <= 40`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to solve the Combination Sum problem using backtracking?",
				"options": [
					"a) Use a recursive function that tries to add each candidate to the current combination and backtracks if the sum exceeds the target.",
					"b) Use dynamic programming to store the number of ways to reach each sum up to the target.",
					"c) Use a greedy algorithm to select the largest candidate first and reduce the target accordingly.",
					"d) Use a breadth-first search to explore all possible combinations iteratively."
				],
				"explanation": "The correct approach is to use a recursive function that explores each candidate by adding it to the current combination. If the sum of the current combination exceeds the target, the function backtracks by removing the last added candidate and tries the next one. This ensures that all possible combinations are explored without exceeding the target.",
				"answer": "a",
				"topics": ["Backtracking", "Array"]
			},
			{
				"question": "Given the following backtracking solution for the Combination Sum problem, identify the bug:\n```python\n1. def combinationSum(candidates, target):\n2.     def backtrack(remaining, combo, start):\n3.         if remaining == 0:\n4.             result.append(list(combo))\n5.             return\n6.         elif remaining < 0:\n7.             return\n8.         for i in range(start, len(candidates)):\n9.             combo.append(candidates[i])\n10.            backtrack(remaining - candidates[i], combo, i)\n11.            combo.pop()\n12.    result = []\n13.    backtrack(target, [], 0)\n14.    return result\n```\nWhich line contains the bug and why does it still pass many test cases?",
				"options": [
					"a) Line 3: The condition should be 'if remaining <= 0' to handle edge cases.",
					"b) Line 8: The loop should start from 0 instead of 'start' to explore all combinations.",
					"c) Line 10: The recursive call should use 'i + 1' instead of 'i' to avoid duplicates.",
					"d) No bug: The code correctly implements the backtracking approach."
				],
				"explanation": "The code correctly implements the backtracking approach. The loop starts from 'start' to avoid using previous elements, ensuring combinations are unique. The recursive call uses 'i' to allow repeated use of the same element, which is required by the problem statement. Therefore, there is no bug in the code.",
				"answer": "d",
				"topics": ["Backtracking", "Array"]
			},
			{
				"question": "Consider the time complexity of the backtracking solution for the Combination Sum problem. Which of the following best describes it?",
				"options": [
					"a) O(n^target), where n is the number of candidates.",
					"b) O(target^n), where n is the number of candidates.",
					"c) O(n * target), where n is the number of candidates.",
					"d) O(n!), where n is the number of candidates."
				],
				"explanation": "The time complexity of the backtracking solution is O(n^target) because in the worst case, each candidate can be used multiple times to reach the target, leading to a branching factor of n (number of candidates) and a depth of target (the maximum number of times a candidate can be used).",
				"answer": "a",
				"topics": ["Backtracking", "Complexity Analysis"]
			},
			{
				"question": "In the context of the Combination Sum problem, which of the following modifications would optimize the backtracking solution to reduce unnecessary computations?",
				"options": [
					"a) Sort the candidates array before starting the backtracking process.",
					"b) Use a hash set to store already visited combinations.",
					"c) Implement memoization to store results of subproblems.",
					"d) Use a priority queue to explore combinations with the smallest sum first."
				],
				"explanation": "Sorting the candidates array before starting the backtracking process allows the algorithm to stop early when the remaining target becomes negative, as all subsequent candidates will be larger. This reduces unnecessary computations by avoiding exploration of invalid paths.",
				"answer": "a",
				"topics": ["Backtracking", "Optimization"]
			},
			{
				"question": "Which of the following statements about the Combination Sum problem is true?",
				"options": [
					"a) The problem can be solved using a greedy algorithm by always choosing the largest candidate first.",
					"b) The problem requires that each candidate can only be used once in each combination.",
					"c) The problem can be solved using dynamic programming by building up solutions for smaller targets.",
					"d) The problem is NP-complete, meaning there is no known polynomial-time solution."
				],
				"explanation": "The Combination Sum problem can be solved using dynamic programming by building up solutions for smaller targets. This approach involves using a table to store the number of ways to achieve each sum up to the target, similar to the coin change problem. The problem is not NP-complete as it can be solved in pseudo-polynomial time using dynamic programming.",
				"answer": "c",
				"topics": ["Dynamic Programming", "Array"]
			}
		]
	},
	{
		"slug": "combination-sum-ii",
		"title": "Combination Sum II",
		"leetcodeUrl": "https://leetcode.com/problems/combination-sum-ii",
		"difficulty": "Medium",
		"topics": ["Backtracking", "Array"],
		"content": "Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`. Each number in `candidates` may only be used once in the combination.\n\n**Note:** The solution set must not contain duplicate combinations.\n\n**Example 1:**\n```\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: [[1,1,6],[1,2,5],[1,7],[2,6]]\n```\n\n**Example 2:**\n```\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: [[1,2,2],[5]]\n```\n\n**Constraints:**\n- `1 <= candidates.length <= 100`\n- `1 <= candidates[i] <= 50`\n- `1 <= target <= 30`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a key consideration when implementing a backtracking solution for the Combination Sum II problem?",
				"options": [
					"Ensuring each candidate is used at least once",
					"Avoiding duplicate combinations by sorting and skipping duplicates",
					"Using a dynamic programming table to store intermediate results",
					"Implementing a greedy approach to select the largest candidates first"
				],
				"explanation": "In the Combination Sum II problem, it's crucial to avoid duplicate combinations. This is typically achieved by sorting the candidates and skipping duplicates during the backtracking process. This ensures that each combination is unique and no repeated sets are included in the result.",
				"answer": "b",
				"topics": ["Backtracking", "Array"]
			},
			{
				"question": "Given the following backtracking solution for Combination Sum II, which line contains a bug that could lead to incorrect results?\n```python\n1. def combinationSum2(candidates, target):\n2.     def backtrack(start, path, target):\n3.         if target == 0:\n4.             result.append(path)\n5.             return\n6.         for i in range(start, len(candidates)):\n7.             if i > start and candidates[i] == candidates[i-1]:\n8.                 continue\n9.             if candidates[i] > target:\n10.                break\n11.            backtrack(i + 1, path + [candidates[i]], target - candidates[i])\n12.    candidates.sort()\n13.    result = []\n14.    backtrack(0, [], target)\n15.    return result\n```",
				"options": [
					"Line 4: result.append(path)",
					"Line 7: if i > start and candidates[i] == candidates[i-1]:",
					"Line 9: if candidates[i] > target:",
					"Line 11: backtrack(i + 1, path + [candidates[i]], target - candidates[i])"
				],
				"explanation": "The bug is in line 4: `result.append(path)`. This line appends the current path directly to the result, but since lists are mutable, it can lead to incorrect results if the path is modified later. A copy of the path should be appended instead, using `result.append(path[:])`.",
				"answer": "a",
				"topics": ["Backtracking", "Array"]
			},
			{
				"question": "In the context of the Combination Sum II problem, what is the time complexity of the backtracking solution, considering the constraints?",
				"options": [
					"O(2^n) where n is the number of candidates",
					"O(n^2) due to sorting and backtracking",
					"O(n * 2^n) because each candidate can be included or excluded",
					"O(n!) because of the permutations of candidates"
				],
				"explanation": "The time complexity of the backtracking solution is O(2^n) because each candidate can either be included or excluded, leading to a decision tree with 2^n possible paths. Sorting the candidates, which is O(n log n), is dominated by the exponential nature of the backtracking process.",
				"answer": "a",
				"topics": ["Backtracking", "Array"]
			},
			{
				"question": "Which of the following modifications would optimize the space complexity of the backtracking solution for Combination Sum II?",
				"options": [
					"Use a set to store results instead of a list",
					"Avoid sorting the candidates to save space",
					"Use an iterative approach instead of recursion",
					"Pass indices instead of sublists to reduce memory usage"
				],
				"explanation": "Passing indices instead of sublists can reduce memory usage because it avoids creating new lists at each recursive call. Instead, the current path can be built using indices, which are less memory-intensive than copying lists.",
				"answer": "d",
				"topics": ["Backtracking", "Array"]
			},
			{
				"question": "In the Combination Sum II problem, why is it important to sort the candidates before starting the backtracking process?",
				"options": [
					"To ensure the largest numbers are considered first",
					"To facilitate the use of binary search during backtracking",
					"To easily skip duplicate candidates and avoid duplicate combinations",
					"To reduce the overall time complexity from exponential to polynomial"
				],
				"explanation": "Sorting the candidates is crucial because it allows the algorithm to easily skip duplicate candidates, which helps in avoiding duplicate combinations in the result. This is done by checking if the current candidate is the same as the previous one and skipping it if it is.",
				"answer": "c",
				"topics": ["Backtracking", "Array"]
			}
		]
	},
	{
		"slug": "first-missing-positive",
		"title": "41. First Missing Positive",
		"leetcodeUrl": "https://leetcode.com/problems/first-missing-positive",
		"difficulty": "Medium",
		"topics": ["Array"],
		"content": "Given an unsorted integer array `nums`, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in `O(n)` time and uses `O(1)` auxiliary space.\n\n**Example 1:**\n```\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\n```\n\n**Example 2:**\n```\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\n```\n\n**Example 3:**\n```\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.\n```\n\n**Constraints:**\n- `1 <= nums.length <= 10^5`\n- `-2^31 <= nums[i] <= 2^31 - 1`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is the correct approach to solve the 'First Missing Positive' problem in O(n) time and O(1) space?",
				"options": [
					"Use a hash set to track all positive numbers and find the smallest missing one.",
					"Sort the array and then iterate to find the first missing positive.",
					"Use the array itself to mark the presence of numbers by placing each number at its corresponding index.",
					"Iterate through the array and count the number of positive integers, then find the missing one."
				],
				"explanation": "The correct approach is to use the array itself to mark the presence of numbers. This can be done by placing each number at its corresponding index (i.e., number 1 at index 0, number 2 at index 1, etc.). This way, we can identify the first index that does not have the correct number, which will be the smallest missing positive integer. This method ensures O(n) time complexity and O(1) space complexity.",
				"answer": "c",
				"topics": ["Array", "In-place Algorithms"]
			},
			{
				"question": "In the following code for finding the first missing positive, which line contains a bug?\n```python\n1. def firstMissingPositive(nums):\n2.     n = len(nums)\n3.     for i in range(n):\n4.         while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n5.             nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n6.     for i in range(n):\n7.         if nums[i] != i + 1:\n8.             return i + 1\n9.     return n + 1\n```\nWhat is the issue with the code?",
				"options": [
					"Line 4: The condition should be '1 <= nums[i] < n'.",
					"Line 5: The swap should be 'nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]'.",
					"Line 7: The condition should be 'nums[i] != i'.",
					"There is no bug; the code is correct."
				],
				"explanation": "The code is correct as it stands. The condition in line 4 ensures that each number is placed at its correct index (i.e., number 1 at index 0, number 2 at index 1, etc.). The swap in line 5 is correctly implemented to place the number at its correct position. Line 7 correctly checks if the number at index i is not i+1, which would indicate the first missing positive number.",
				"answer": "d",
				"topics": ["Array", "In-place Algorithms", "Bug Spotting"]
			},
			{
				"question": "Consider the following three solutions for finding the first missing positive integer:\nA) Use a hash set to store all positive numbers and iterate to find the missing one.\nB) Sort the array and iterate to find the first missing positive.\nC) Use the array itself to rearrange numbers and find the missing positive.\n\nWhich solution is optimal in terms of both time and space complexity?",
				"options": [
					"Solution A is optimal because it uses O(n) time and O(n) space.",
					"Solution B is optimal because it uses O(n log n) time and O(1) space.",
					"Solution C is optimal because it uses O(n) time and O(1) space.",
					"None of the solutions are optimal; a different approach is needed."
				],
				"explanation": "Solution C is optimal because it rearranges the array in-place to find the first missing positive integer. This approach runs in O(n) time and uses O(1) additional space, meeting the problem's constraints.",
				"answer": "c",
				"topics": ["Array", "In-place Algorithms", "Complexity Analysis"]
			},
			{
				"question": "What is the time and space complexity of the following solution for finding the first missing positive?\n```python\n@lru_cache(None)\ndef firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1\n```\n",
				"options": [
					"Time: O(n), Space: O(n) due to the cache.",
					"Time: O(n), Space: O(1) because the cache is not used.",
					"Time: O(n^2), Space: O(1) due to the nested loops.",
					"Time: O(n), Space: O(1) because the cache is irrelevant here."
				],
				"explanation": "The use of @lru_cache is irrelevant in this context because the function does not involve recursive calls or repeated subproblem solutions that benefit from caching. The solution runs in O(n) time due to the linear pass and in-place swaps, and it uses O(1) space as it modifies the array in-place without additional data structures.",
				"answer": "d",
				"topics": ["Array", "In-place Algorithms", "Complexity Analysis"]
			},
			{
				"question": "In the context of the 'First Missing Positive' problem, why is it important to handle numbers outside the range [1, n] (where n is the length of the array)?",
				"options": [
					"They should be ignored because they do not affect the result.",
					"They should be set to zero to simplify the algorithm.",
					"They should be moved to the end of the array to maintain order.",
					"They should be replaced with the smallest positive integer."
				],
				"explanation": "Numbers outside the range [1, n] should be ignored because they do not affect the result. The algorithm focuses on placing numbers within the range [1, n] at their correct indices to identify the first missing positive integer. Handling numbers outside this range is unnecessary for the solution.",
				"answer": "a",
				"topics": ["Array", "In-place Algorithms", "Edge Cases"]
			}
		]
	},
	{
		"slug": "trapping-rain-water",
		"title": "Trapping Rain Water",
		"leetcodeUrl": "https://leetcode.com/problems/trapping-rain-water",
		"difficulty": "Medium",
		"topics": ["Array", "Two Pointers"],
		"content": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n\n**Example 1:**\n```\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rainwater (blue section) are being trapped.\n```\n\n**Example 2:**\n```\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n```\n\n**Constraints:**\n- `n == height.length`\n- `1 <= n <= 2 * 10^4`\n- `0 <= height[i] <= 10^5`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following algorithms is most efficient for solving the Trapping Rain Water problem in terms of time complexity?",
				"options": [
					"a) Brute force approach with nested loops",
					"b) Dynamic programming with precomputed arrays",
					"c) Two pointers approach",
					"d) Using a stack to track boundaries"
				],
				"explanation": "The two pointers approach is the most efficient for solving the Trapping Rain Water problem with a time complexity of O(n). It uses two pointers to traverse the array from both ends, maintaining the maximum heights seen so far and calculating the trapped water based on the minimum of these heights. This approach is more efficient than the brute force method (O(n^2)) and uses less space than the dynamic programming approach (O(n) space). The stack-based approach also has a time complexity of O(n) but is generally more complex to implement.",
				"answer": "c",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "In the two pointers solution for the Trapping Rain Water problem, what is the main reason for moving the pointer with the smaller height?",
				"options": [
					"a) To ensure that the water trapped is always calculated from the lower boundary",
					"b) To maintain the balance between left and right pointers",
					"c) To avoid unnecessary calculations when heights are equal",
					"d) To ensure that the maximum height is always on the right side"
				],
				"explanation": "In the two pointers approach, the pointer with the smaller height is moved because the amount of water that can be trapped is determined by the shorter boundary. By moving the pointer with the smaller height, we ensure that we are always calculating the trapped water based on the current minimum height, which is crucial for correctly determining the trapped water at each step.",
				"answer": "a",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following code snippet for the Trapping Rain Water problem, identify the bug:\n```python\n1. def trap(height):\n2.     left, right = 0, len(height) - 1\n3.     left_max, right_max = 0, 0\n4.     water = 0\n5.     while left < right:\n6.         if height[left] < height[right]:\n7.             if height[left] >= left_max:\n8.                 left_max = height[left]\n9.             else:\n10.                water += left_max - height[left]\n11.            left += 1\n12.        else:\n13.            if height[right] >= right_max:\n14.                right_max = height[right]\n15.            else:\n16.                water += right_max - height[right]\n17.            right -= 1\n18.    return water\n```",
				"options": [
					"a) Line 6: The condition should be height[left] <= height[right]",
					"b) Line 7: The condition should be height[left] > left_max",
					"c) Line 13: The condition should be height[right] > right_max",
					"d) Line 5: The loop should be while left <= right"
				],
				"explanation": "The code correctly implements the two pointers approach for the Trapping Rain Water problem. The condition in line 6 is correct as it ensures that the pointer with the smaller height is moved. The conditions in lines 7 and 13 are also correct as they update the maximum heights seen so far. The loop condition in line 5 is correct as it should run while left is less than right. Therefore, there is no bug in the provided code snippet.",
				"answer": "a",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Consider the following scenario: You have an array of heights representing an elevation map. Which of the following conditions would lead to the maximum amount of water being trapped?",
				"options": [
					"a) Heights are in strictly increasing order",
					"b) Heights are in strictly decreasing order",
					"c) Heights form a valley with the lowest point in the middle",
					"d) Heights are all equal"
				],
				"explanation": "The maximum amount of water is trapped when the heights form a valley with the lowest point in the middle. This configuration allows water to be trapped between the higher boundaries on either side of the valley. In contrast, strictly increasing or decreasing heights do not trap any water, and equal heights do not create any boundaries for trapping water.",
				"answer": "c",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Analyze the time and space complexity of the following solution for the Trapping Rain Water problem:\n```python\n1. def trap(height):\n2.     if not height:\n3.         return 0\n4.     n = len(height)\n5.     left_max = [0] * n\n6.     right_max = [0] * n\n7.     water = 0\n8.     left_max[0] = height[0]\n9.     for i in range(1, n):\n10.        left_max[i] = max(left_max[i-1], height[i])\n11.    right_max[n-1] = height[n-1]\n12.    for i in range(n-2, -1, -1):\n13.        right_max[i] = max(right_max[i+1], height[i])\n14.    for i in range(n):\n15.        water += min(left_max[i], right_max[i]) - height[i]\n16.    return water\n```",
				"options": [
					"a) Time: O(n), Space: O(n)",
					"b) Time: O(n^2), Space: O(n)",
					"c) Time: O(n), Space: O(1)",
					"d) Time: O(n^2), Space: O(1)"
				],
				"explanation": "The solution uses two arrays, left_max and right_max, to store the maximum heights to the left and right of each position, respectively. This requires O(n) space. The time complexity is O(n) because each of the three loops runs in linear time relative to the size of the input array. Therefore, the correct complexity is Time: O(n), Space: O(n).",
				"answer": "a",
				"topics": ["Array", "Dynamic Programming"]
			}
		]
	},
	{
		"slug": "multiply-strings",
		"title": "Multiply Strings",
		"leetcodeUrl": "https://leetcode.com/problems/multiply-strings",
		"difficulty": "Medium",
		"topics": ["String", "Math"],
		"content": "Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n\nNote: You must not use any built-in `BigInteger` library or convert the inputs to integer directly.\n\n**Example 1:**\n```\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n```\n\n**Example 2:**\n```\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n```\n\n**Constraints:**\n- `1 <= num1.length, num2.length <= 200`\n- `num1` and `num2` consist of digits only.\n- Both `num1` and `num2` do not contain any leading zero, except the number `0` itself.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to multiply two numbers represented as strings without converting them to integers?",
				"options": [
					"a) Use nested loops to simulate the manual multiplication process, storing intermediate results in an array.",
					"b) Convert the strings to integers, multiply them, and convert the result back to a string.",
					"c) Use a divide and conquer approach similar to Karatsuba multiplication.",
					"d) Use a hash map to store the frequency of each digit and calculate the product based on these frequencies."
				],
				"explanation": "The correct approach is to simulate the manual multiplication process using nested loops. This involves multiplying each digit of the first number by each digit of the second number, storing the results in an array, and then handling carry-over values. This method avoids converting the strings to integers, which is a constraint of the problem.",
				"answer": "a",
				"topics": ["String", "Math"]
			},
			{
				"question": "In the following code snippet for multiplying two strings, which line contains a bug?\n```python\n1. def multiply(num1, num2):\n2.     if num1 == '0' or num2 == '0':\n3.         return '0'\n4.     result = [0] * (len(num1) + len(num2))\n5.     for i in range(len(num1)-1, -1, -1):\n6.         for j in range(len(num2)-1, -1, -1):\n7.             mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n8.             sum = mul + result[i + j + 1]\n9.             result[i + j + 1] = sum % 10\n10.            result[i + j] += sum // 10\n11.    return ''.join(map(str, result)).lstrip('0')\n```",
				"options": [
					"a) Line 4: result = [0] * (len(num1) + len(num2))",
					"b) Line 8: sum = mul + result[i + j + 1]",
					"c) Line 10: result[i + j] += sum // 10",
					"d) Line 11: return ''.join(map(str, result)).lstrip('0')"
				],
				"explanation": "The bug is in line 11. The code correctly calculates the product and stores it in the result array, but when converting the result array to a string, it uses lstrip('0'), which can remove all leading zeros, including the zero for the number '0'. This can lead to incorrect results if the product is actually zero. A better approach would be to check if the result is empty after stripping and return '0' if so.",
				"answer": "d",
				"topics": ["String", "Math", "Implementation Analysis"]
			},
			{
				"question": "Consider the following three solutions for multiplying two strings:\nA) Simulate manual multiplication using nested loops\nB) Use FFT (Fast Fourier Transform) for polynomial multiplication\nC) Use a divide and conquer approach similar to Karatsuba multiplication\n\nWhich solution is most efficient for very large numbers (length > 1000)?",
				"options": [
					"a) Solution A: Simulate manual multiplication using nested loops",
					"b) Solution B: Use FFT for polynomial multiplication",
					"c) Solution C: Use a divide and conquer approach similar to Karatsuba multiplication",
					"d) All solutions have similar efficiency for very large numbers"
				],
				"explanation": "For very large numbers, the FFT-based approach (Solution B) is the most efficient. FFT can multiply two polynomials in O(n log n) time, which is significantly faster than the O(n^2) time complexity of the manual multiplication approach (Solution A) and the O(n^1.585) time complexity of Karatsuba multiplication (Solution C).",
				"answer": "b",
				"topics": ["String", "Math", "Solution Comparison"]
			},
			{
				"question": "What is the time complexity of the manual multiplication approach for multiplying two strings of length n and m?",
				"options": ["a) O(n + m)", "b) O(n^2)", "c) O(n * m)", "d) O(n^3)"],
				"explanation": "The manual multiplication approach involves two nested loops, where each digit of the first string is multiplied by each digit of the second string. This results in a time complexity of O(n * m), where n and m are the lengths of the two strings.",
				"answer": "c",
				"topics": ["String", "Math", "Complexity Analysis"]
			},
			{
				"question": "In the context of multiplying two strings, which of the following optimizations can reduce the space complexity of the manual multiplication approach?",
				"options": [
					"a) Use a single array to store intermediate results and final product.",
					"b) Use a linked list instead of an array to store results.",
					"c) Use a hash map to store digit positions and their sums.",
					"d) Use recursion to handle carry propagation."
				],
				"explanation": "Using a single array to store both intermediate results and the final product can reduce the space complexity. This approach allows for in-place updates and avoids the need for additional data structures, thus optimizing space usage.",
				"answer": "a",
				"topics": ["String", "Math", "Optimization Modifications"]
			}
		]
	},
	{
		"slug": "wildcard-matching",
		"title": "Wildcard Matching",
		"leetcodeUrl": "https://leetcode.com/problems/wildcard-matching",
		"difficulty": "Medium",
		"topics": ["Dynamic Programming", "String"],
		"content": "Given an input string `s` and a pattern `p`, implement wildcard pattern matching with support for `?` and `*` where:\n\n- `?` Matches any single character.\n- `*` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n\n**Example 1:**\n```\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n```\n\n**Example 2:**\n```\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\n```\n\n**Example 3:**\n```\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n```\n\n**Constraints:**\n- `0 <= s.length, p.length <= 2000`\n- `s` contains only lowercase English letters.\n- `p` contains only lowercase English letters, `?` or `*`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following statements is true about the time complexity of a dynamic programming solution for the wildcard matching problem?",
				"options": [
					"The time complexity is O(n^2) where n is the length of the string s.",
					"The time complexity is O(m * n) where m is the length of the pattern p and n is the length of the string s.",
					"The time complexity is O(m + n) where m is the length of the pattern p and n is the length of the string s.",
					"The time complexity is O(2^n) where n is the length of the string s."
				],
				"explanation": "The dynamic programming solution for wildcard matching typically involves creating a 2D table where dp[i][j] represents whether the first i characters of the pattern p match the first j characters of the string s. This results in a time complexity of O(m * n), where m is the length of the pattern and n is the length of the string.",
				"answer": "b",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "In the following code for wildcard matching, which line contains a bug that causes incorrect results for certain inputs?\n```python\n1. def isMatch(s, p):\n2.     dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n3.     dp[0][0] = True\n4.     for i in range(1, len(p) + 1):\n5.         if p[i-1] == '*':\n6.             dp[0][i] = dp[0][i-1]\n7.     for i in range(1, len(s) + 1):\n8.         for j in range(1, len(p) + 1):\n9.             if p[j-1] == '*':\n10.                dp[i][j] = dp[i-1][j] or dp[i][j-1]\n11.            elif p[j-1] == '?' or s[i-1] == p[j-1]:\n12.                dp[i][j] = dp[i-1][j-1]\n13.    return dp[len(s)][len(p)]\n```",
				"options": [
					"Line 5: if p[i-1] == '*': because it does not handle the case where '*' is at the start of the pattern.",
					"Line 10: dp[i][j] = dp[i-1][j] or dp[i][j-1] because it incorrectly handles the '*' character.",
					"Line 11: elif p[j-1] == '?' or s[i-1] == p[j-1]: because it does not account for the '*' character.",
					"Line 6: dp[0][i] = dp[0][i-1] because it incorrectly initializes the dp table for patterns starting with '*'."
				],
				"explanation": "The bug is in Line 10: dp[i][j] = dp[i-1][j] or dp[i][j-1]. This line correctly handles the '*' character by allowing it to match zero characters (dp[i][j-1]) or one or more characters (dp[i-1][j]). The other options are incorrect because they do not address the actual bug in the code.",
				"answer": "b",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "Consider the following two solutions for the wildcard matching problem:\nA) Dynamic Programming\nB) Recursive Backtracking\n\nWhich of the following statements is true regarding the performance of these solutions?",
				"options": [
					"Solution A is generally faster than Solution B for large inputs due to its iterative nature and reduced stack usage.",
					"Solution B is generally faster than Solution A for large inputs because it explores fewer paths.",
					"Solution A uses more memory than Solution B because it stores all subproblem results.",
					"Solution B uses less memory than Solution A because it does not store intermediate results."
				],
				"explanation": "Solution A (Dynamic Programming) is generally faster than Solution B (Recursive Backtracking) for large inputs because it avoids the exponential time complexity of exploring all possible paths by storing intermediate results. However, it uses more memory to store these results. Solution B, while using less memory, is slower due to its recursive nature and potential for exploring many paths.",
				"answer": "a",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "In the context of wildcard matching, which of the following modifications would optimize a dynamic programming solution to use less space?",
				"options": [
					"Use a 1D array instead of a 2D array by iterating over the pattern and string in reverse order.",
					"Use a 1D array instead of a 2D array by iterating over the pattern and string in forward order.",
					"Store only the last two rows of the dp table at any time, as only these are needed for the current computation.",
					"Store only the first two rows of the dp table at any time, as only these are needed for the current computation."
				],
				"explanation": "To optimize space usage in a dynamic programming solution for wildcard matching, you can store only the last two rows of the dp table at any time. This is because the current row's values only depend on the previous row's values, reducing the space complexity from O(m * n) to O(n).",
				"answer": "c",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "What is the space complexity of a dynamic programming solution for the wildcard matching problem, assuming the optimization to store only the last two rows of the dp table is applied?",
				"options": [
					"O(m * n) where m is the length of the pattern and n is the length of the string.",
					"O(m + n) where m is the length of the pattern and n is the length of the string.",
					"O(n) where n is the length of the string.",
					"O(m) where m is the length of the pattern."
				],
				"explanation": "With the optimization to store only the last two rows of the dp table, the space complexity of the dynamic programming solution for wildcard matching is reduced to O(n), where n is the length of the string. This is because only two rows of size n are needed at any time.",
				"answer": "c",
				"topics": ["Dynamic Programming", "String"]
			}
		]
	},
	{
		"slug": "jump-game-ii",
		"title": "Jump Game II",
		"leetcodeUrl": "https://leetcode.com/problems/jump-game-ii",
		"difficulty": "Medium",
		"topics": ["Array", "Greedy"],
		"content": "You are given a 0-indexed array of integers `nums` of length `n`. You are initially positioned at `nums[0]`. Each element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i+j]` where:\n\n- `0 <= j <= nums[i]` and\n- `i + j < n`\n\nReturn the minimum number of jumps to reach `nums[n-1]`. The test cases are generated such that you can reach `nums[n-1]`.\n\n**Example 1:**\n```\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n**Example 2:**\n```\nInput: nums = [2,3,0,1,4]\nOutput: 2\n```\n\n**Constraints:**\n- `1 <= nums.length <= 10^4`\n- `0 <= nums[i] <= 1000`\n- It's guaranteed that you can reach `nums[n-1]`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the greedy algorithm for solving the Jump Game II problem?",
				"options": ["O(n^2)", "O(n log n)", "O(n)", "O(log n)"],
				"explanation": "The greedy algorithm for Jump Game II involves iterating through the array once while maintaining the farthest point that can be reached with the current number of jumps. This results in a time complexity of O(n) because each element is processed at most once.",
				"answer": "c",
				"topics": ["Array", "Greedy"]
			},
			{
				"question": "In the greedy solution for Jump Game II, which of the following best describes the role of the 'farthest' variable?",
				"options": [
					"It tracks the maximum index that can be reached with the current number of jumps.",
					"It stores the minimum number of jumps needed to reach the current index.",
					"It keeps track of the last index of the array.",
					"It counts the total number of elements that have been processed."
				],
				"explanation": "In the greedy solution, the 'farthest' variable is used to track the maximum index that can be reached with the current number of jumps. This helps in deciding when to increase the jump count and update the current end of the jump range.",
				"answer": "a",
				"topics": ["Array", "Greedy"]
			},
			{
				"question": "Consider the following implementation of the Jump Game II problem. Identify the bug in the code:\n```python\n1. def jump(nums):\n2.     n = len(nums)\n3.     if n <= 1:\n4.         return 0\n5.     jumps = 0\n6.     current_end = 0\n7.     farthest = 0\n8.     for i in range(n):\n9.         farthest = max(farthest, i + nums[i])\n10.        if i == current_end:\n11.            jumps += 1\n12.            current_end = farthest\n13.            if current_end >= n - 1:\n14.                break\n15.     return jumps\n```\nWhat is the issue with this code?",
				"options": [
					"The loop should start from index 1 instead of 0.",
					"The condition on line 10 should be 'i >= current_end'.",
					"The code does not handle the case when 'nums' is empty.",
					"The loop should iterate until 'n-1' instead of 'n'."
				],
				"explanation": "The loop should iterate until 'n-1' instead of 'n' because once we reach the last index, we don't need to consider further jumps. The current implementation may cause an unnecessary increment in the jump count when 'i' reaches 'n-1'.",
				"answer": "d",
				"topics": ["Array", "Greedy"]
			},
			{
				"question": "Which of the following modifications would optimize the space complexity of the Jump Game II solution?",
				"options": [
					"Use a stack to store indices instead of variables.",
					"Replace the 'farthest' variable with a list to track all reachable indices.",
					"Use a single variable to track both 'current_end' and 'farthest'.",
					"The current solution is already optimized for space complexity."
				],
				"explanation": "The current solution is already optimized for space complexity as it uses only a constant amount of extra space (O(1)). Using a stack or list would increase the space complexity unnecessarily.",
				"answer": "d",
				"topics": ["Array", "Greedy"]
			},
			{
				"question": "Given the following scenarios, which one would cause the greedy algorithm for Jump Game II to perform suboptimally compared to a dynamic programming approach?",
				"options": [
					"The array has a large number of elements with small values.",
					"The array has a few large values followed by many zeros.",
					"The array is sorted in descending order.",
					"The array has alternating large and small values."
				],
				"explanation": "The greedy algorithm performs optimally in most cases, but if the array has a few large values followed by many zeros, the greedy approach might make a suboptimal choice early on, leading to more jumps than necessary. A dynamic programming approach could potentially find a better path by considering all possibilities.",
				"answer": "b",
				"topics": ["Array", "Greedy"]
			}
		]
	},
	{
		"slug": "permutations",
		"title": "Permutations",
		"leetcodeUrl": "https://leetcode.com/problems/permutations",
		"difficulty": "Medium",
		"topics": ["Backtracking"],
		"content": "Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.\n\n**Example 1:**\n```\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n**Example 2:**\n```\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\n```\n\n**Example 3:**\n```\nInput: nums = [1]\nOutput: [[1]]\n```\n\n**Constraints:**\n- `1 <= nums.length <= 6`\n- `-10 <= nums[i] <= 10`\n- All the integers of `nums` are unique.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is the correct time complexity for generating all permutations of an array of length n?",
				"options": ["O(n!)", "O(n^2)", "O(2^n)", "O(n * n!)"],
				"explanation": "The time complexity for generating all permutations of an array of length n is O(n * n!). This is because there are n! permutations, and generating each permutation takes O(n) time.",
				"answer": "d",
				"topics": ["Backtracking", "Complexity Analysis"]
			},
			{
				"question": "Consider the following code snippet for generating permutations:\n```python\nfrom typing import List\n\ndef permute(nums: List[int]) -> List[List[int]]:\n    def backtrack(first=0):\n        if first == n:\n            output.append(nums[:])\n        for i in range(first, n):\n            nums[first], nums[i] = nums[i], nums[first]\n            backtrack(first + 1)\n            nums[first], nums[i] = nums[i], nums[first]\n\n    n = len(nums)\n    output = []\n    backtrack()\n    return output\n```\nWhat is the purpose of the line `nums[first], nums[i] = nums[i], nums[first]` inside the loop?",
				"options": [
					"To ensure the list is sorted before generating permutations",
					"To swap elements to generate a new permutation",
					"To reset the list to its original order",
					"To check if the current permutation is valid"
				],
				"explanation": "The line `nums[first], nums[i] = nums[i], nums[first]` is used to swap elements in the list to generate a new permutation. This is a common technique in backtracking algorithms to explore different configurations.",
				"answer": "b",
				"topics": ["Backtracking", "Implementation"]
			},
			{
				"question": "Given the following code for generating permutations, identify the bug:\n```python\nfrom typing import List\n\ndef permute(nums: List[int]) -> List[List[int]]:\n    def backtrack(first=0):\n        if first == n:\n            output.append(nums)\n        for i in range(first, n):\n            nums[first], nums[i] = nums[i], nums[first]\n            backtrack(first + 1)\n            nums[first], nums[i] = nums[i], nums[first]\n\n    n = len(nums)\n    output = []\n    backtrack()\n    return output\n```\nWhich line contains the bug and why does it still pass many test cases?",
				"options": [
					"Line 5: `output.append(nums)` because it appends the reference instead of a copy",
					"Line 7: `nums[first], nums[i] = nums[i], nums[first]` because it swaps incorrectly",
					"Line 8: `backtrack(first + 1)` because it should be `backtrack(i + 1)`",
					"Line 9: `nums[first], nums[i] = nums[i], nums[first]` because it doesn't reset the list properly"
				],
				"explanation": "The bug is in Line 5: `output.append(nums)`. It appends the reference to the list `nums` instead of a copy. This means all entries in `output` will be the same list object, which will reflect the final state of `nums`. It passes many test cases because the permutations are generated correctly, but the output is incorrect due to the reference issue.",
				"answer": "a",
				"topics": ["Backtracking", "Implementation Analysis"]
			},
			{
				"question": "Which of the following modifications would optimize the space complexity of the permutation generation algorithm without affecting its time complexity?",
				"options": [
					"Use a set instead of a list for `output`",
					"Use a generator to yield permutations instead of storing them",
					"Store permutations as tuples instead of lists",
					"Use a fixed-size array for `output`"
				],
				"explanation": "Using a generator to yield permutations instead of storing them would optimize the space complexity. This approach generates each permutation on-the-fly and does not require storing all permutations in memory at once, thus reducing space usage.",
				"answer": "b",
				"topics": ["Backtracking", "Optimization"]
			},
			{
				"question": "Consider the following recursive function for generating permutations:\n```python\nfrom typing import List\n\ndef permute(nums: List[int]) -> List[List[int]]:\n    def backtrack(path, remaining):\n        if not remaining:\n            output.append(path)\n        for i in range(len(remaining)):\n            backtrack(path + [remaining[i]], remaining[:i] + remaining[i+1:])\n\n    output = []\n    backtrack([], nums)\n    return output\n```\nWhat is the time complexity of this function?",
				"options": ["O(n!)", "O(n^2)", "O(n * n!)", "O(2^n)"],
				"explanation": "The time complexity of this function is O(n * n!). There are n! permutations, and each permutation is constructed by making n recursive calls, each of which takes O(n) time due to list slicing and concatenation.",
				"answer": "c",
				"topics": ["Backtracking", "Complexity Analysis"]
			}
		]
	},
	{
		"slug": "permutations-ii",
		"title": "Permutations II",
		"leetcodeUrl": "https://leetcode.com/problems/permutations-ii",
		"difficulty": "Medium",
		"topics": ["Backtracking"],
		"content": "Given a collection of numbers `nums`, that might contain duplicates, return all possible unique permutations in any order.\n\n**Example 1:**\n```\nInput: nums = [1,1,2]\nOutput: [[1,1,2],[1,2,1],[2,1,1]]\n```\n\n**Example 2:**\n```\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n**Constraints:**\n- `1 <= nums.length <= 8`\n- `-10 <= nums[i] <= 10`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to generate all unique permutations of a list of numbers that may contain duplicates?",
				"options": [
					"a) Use a set to store permutations and avoid duplicates.",
					"b) Sort the list and use a backtracking approach with a boolean array to track used elements.",
					"c) Use a recursive function that swaps elements in place and checks for duplicates after generating all permutations.",
					"d) Generate all permutations using itertools.permutations and filter out duplicates."
				],
				"explanation": "The correct approach is to sort the list and use a backtracking approach with a boolean array to track used elements. Sorting helps in easily skipping duplicates by checking if the current element is the same as the previous one and if the previous one was not used. This ensures that duplicates are not generated in the first place, rather than filtering them out later.",
				"answer": "b",
				"topics": ["Backtracking"]
			},
			{
				"question": "Given the following backtracking solution for generating unique permutations, which line contains a bug that may cause incorrect results?\n```python\n1. def permuteUnique(nums):\n2.     def backtrack(path, used):\n3.         if len(path) == len(nums):\n4.             result.append(path[:])\n5.             return\n6.         for i in range(len(nums)):\n7.             if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):\n8.                 continue\n9.             used[i] = True\n10.            path.append(nums[i])\n11.            backtrack(path, used)\n12.            path.pop()\n13.            used[i] = False\n14.    nums.sort()\n15.    result = []\n16.    backtrack([], [False] * len(nums))\n17.    return result\n```",
				"options": [
					"a) Line 7: The condition to skip duplicates is incorrect.",
					"b) Line 10: The element is appended to the path incorrectly.",
					"c) Line 12: The element is popped from the path incorrectly.",
					"d) Line 14: Sorting the list is unnecessary and incorrect."
				],
				"explanation": "Line 7 contains the correct condition to skip duplicates. It checks if the current element is the same as the previous one and if the previous one was not used, which is necessary to avoid generating duplicate permutations. The other lines are correctly implemented.",
				"answer": "a",
				"topics": ["Backtracking", "Implementation Analysis"]
			},
			{
				"question": "Consider the time complexity of generating all unique permutations of a list with duplicates using a backtracking approach. What is the time complexity in the worst case?",
				"options": [
					"a) O(n!) - because we generate all permutations.",
					"b) O(n * n!) - because we generate permutations and check for duplicates.",
					"c) O(n^2 * n!) - because we sort the list and generate permutations.",
					"d) O(n^n) - because we explore all possible combinations."
				],
				"explanation": "The time complexity is O(n * n!) in the worst case. This is because generating permutations takes O(n!) time, and for each permutation, we perform operations that take O(n) time, such as checking conditions and managing the path and used arrays.",
				"answer": "b",
				"topics": ["Backtracking", "Complexity Analysis"]
			},
			{
				"question": "In the context of generating unique permutations, which of the following optimizations can reduce the space complexity of the backtracking solution?",
				"options": [
					"a) Use a set to store permutations instead of a list.",
					"b) Use a single boolean array to track used elements instead of multiple arrays.",
					"c) Avoid sorting the input list to save space.",
					"d) Use bit manipulation to track used elements instead of a boolean array."
				],
				"explanation": "Using bit manipulation to track used elements can reduce the space complexity from O(n) to O(1) for the boolean array, as it allows us to use a single integer to represent the used state of all elements. This is a common optimization in problems where the number of elements is small enough to fit within the bits of an integer.",
				"answer": "d",
				"topics": ["Backtracking", "Optimization"]
			},
			{
				"question": "Which of the following statements about the backtracking approach to generate unique permutations is true?",
				"options": [
					"a) The approach is inherently iterative and does not use recursion.",
					"b) The approach requires sorting the input list to handle duplicates correctly.",
					"c) The approach cannot handle negative numbers in the input list.",
					"d) The approach is not suitable for lists with more than 10 elements due to time complexity."
				],
				"explanation": "The backtracking approach requires sorting the input list to handle duplicates correctly. Sorting allows the algorithm to easily skip over duplicate elements by checking if the current element is the same as the previous one and if the previous one was not used. This ensures that duplicates are not generated in the first place.",
				"answer": "b",
				"topics": ["Backtracking"]
			}
		]
	},
	{
		"slug": "rotate-image",
		"title": "Rotate Image",
		"leetcodeUrl": "https://leetcode.com/problems/rotate-image",
		"difficulty": "Medium",
		"topics": ["Array", "Matrix"],
		"content": "You are given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\n**Example 1:**\n```\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n```\n\n**Example 2:**\n```\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n```\n\n**Constraints:**\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 20`\n- `-1000 <= matrix[i][j] <= 1000`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following steps correctly describes the in-place algorithm to rotate an n x n matrix by 90 degrees clockwise?",
				"options": [
					"a) Transpose the matrix, then reverse each row.",
					"b) Reverse each row, then transpose the matrix.",
					"c) Transpose the matrix, then reverse each column.",
					"d) Reverse each column, then transpose the matrix."
				],
				"explanation": "To rotate the matrix by 90 degrees clockwise in-place, you first transpose the matrix (swap rows with columns), and then reverse each row. This sequence of operations effectively rotates the matrix as required.",
				"answer": "a",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "Given the following code snippet for rotating an n x n matrix by 90 degrees clockwise:\n```python\n1. def rotate(matrix):\n2.     n = len(matrix)\n3.     for i in range(n):\n4.         for j in range(i, n):\n5.             matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n6.     for i in range(n):\n7.         matrix[i].reverse()\n```\nWhich line contains a potential inefficiency, and how can it be optimized?",
				"options": [
					"a) Line 3: The outer loop can be optimized to run only till n//2.",
					"b) Line 4: The inner loop should start from 0 instead of i.",
					"c) Line 5: The swap operation is unnecessary and can be removed.",
					"d) Line 7: Reversing each row can be done in a single pass for all rows."
				],
				"explanation": "Line 4 is correct as it starts from i to avoid redundant swaps. Line 5 is necessary for transposing. Line 7 is efficient as it reverses each row in-place. The inefficiency is not in the code provided; the code is already optimized for the task.",
				"answer": "d",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "Consider the following code for rotating an n x n matrix:\n```python\n1. def rotate(matrix):\n2.     n = len(matrix)\n3.     for i in range(n // 2):\n4.         for j in range(i, n - i - 1):\n5.             temp = matrix[i][j]\n6.             matrix[i][j] = matrix[n - j - 1][i]\n7.             matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n8.             matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n9.             matrix[j][n - i - 1] = temp\n```\nWhat is the time complexity of this algorithm?",
				"options": ["a) O(n^2)", "b) O(n^3)", "c) O(n log n)", "d) O(n)"],
				"explanation": "The algorithm iterates over each element in the matrix once, performing a constant amount of work for each element. Since the matrix is n x n, the time complexity is O(n^2).",
				"answer": "a",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "In the context of rotating an n x n matrix by 90 degrees clockwise, which of the following statements is true about the space complexity of the in-place algorithm?",
				"options": [
					"a) The space complexity is O(n^2) because we need to store the entire matrix.",
					"b) The space complexity is O(n) because we only need extra space for one row.",
					"c) The space complexity is O(1) because the rotation is done in-place without extra storage.",
					"d) The space complexity is O(log n) due to recursive stack usage."
				],
				"explanation": "The in-place algorithm for rotating the matrix does not require any additional storage beyond a few temporary variables for swapping elements. Therefore, the space complexity is O(1).",
				"answer": "c",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "Given the following code snippet for rotating an n x n matrix by 90 degrees clockwise:\n```python\n1. def rotate(matrix):\n2.     n = len(matrix)\n3.     for i in range(n // 2):\n4.         for j in range(i, n - i - 1):\n5.             temp = matrix[i][j]\n6.             matrix[i][j] = matrix[n - j - 1][i]\n7.             matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n8.             matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n9.             matrix[j][n - i - 1] = temp\n```\nWhich line contains a potential bug, and what is the correct fix?",
				"options": [
					"a) Line 5: The temp variable should be initialized outside the loop.",
					"b) Line 6: The indices are swapped incorrectly, should be matrix[j][i].",
					"c) Line 7: The indices are swapped incorrectly, should be matrix[n - j - 1][n - i - 1].",
					"d) No bug, the code correctly rotates the matrix."
				],
				"explanation": "The code correctly implements the rotation by swapping elements in four-way swaps. There is no bug in the code; it correctly rotates the matrix in-place.",
				"answer": "d",
				"topics": ["Array", "Matrix"]
			}
		]
	},
	{
		"slug": "group-anagrams",
		"title": "Group Anagrams",
		"leetcodeUrl": "https://leetcode.com/problems/group-anagrams",
		"difficulty": "Medium",
		"topics": ["Hash Table", "String"],
		"content": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.\n\nAn anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n**Example 1:**\n```\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n```\n\n**Example 2:**\n```\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n```\n\n**Example 3:**\n```\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n```\n\n**Constraints:**\n- `1 <= strs.length <= 10^4`\n- `0 <= strs[i].length <= 100`\n- `strs[i]` consists of lowercase English letters.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following data structures is most appropriate for grouping anagrams from a list of strings?",
				"options": ["Array", "Linked List", "Hash Table", "Stack"],
				"explanation": "A hash table is the most appropriate data structure for grouping anagrams because it allows for efficient storage and retrieval of groups of strings that share the same sorted character sequence as a key. This enables quick lookups and insertions, which are essential for grouping anagrams efficiently.",
				"answer": "c",
				"topics": ["Hash Table", "String"]
			},
			{
				"question": "Given the following code snippet for grouping anagrams, identify the bug:\n```python\nfrom collections import defaultdict\n\ndef groupAnagrams(strs):\n    anagrams = defaultdict(list)\n    for s in strs:\n        key = ''.join(sorted(s))\n        anagrams[key].append(s)\n    return list(anagrams.values())\n```\nWhat is the issue with this implementation?",
				"options": [
					"The sorted function is not efficient for large strings.",
					"The defaultdict is not necessary and can be replaced with a regular dictionary.",
					"The key should be a tuple of character counts instead of a sorted string.",
					"The function does not handle empty strings correctly."
				],
				"explanation": "The implementation is correct for the problem of grouping anagrams. However, using a sorted string as a key can be inefficient for very large strings. A more efficient approach could be using a tuple of character counts as the key, which avoids sorting and provides a unique representation for anagrams. However, for the given constraints, the current implementation is efficient enough.",
				"answer": "c",
				"topics": ["Hash Table", "String"]
			},
			{
				"question": "Consider the following three solutions for grouping anagrams:\nA) Sort each string and use it as a key in a hash table.\nB) Use a tuple of character counts as a key in a hash table.\nC) Use a trie to store and group anagrams.\nWhich solution is likely to be the most space-efficient for large input sizes?",
				"options": [
					"Solution A",
					"Solution B",
					"Solution C",
					"All solutions have similar space efficiency"
				],
				"explanation": "Solution B is likely to be the most space-efficient because it uses a fixed-size tuple (of length 26 for lowercase English letters) as the key, which is more compact than storing sorted strings (Solution A) or using a trie (Solution C), which can have significant overhead due to its structure.",
				"answer": "b",
				"topics": ["Hash Table", "String"]
			},
			{
				"question": "Analyze the time complexity of the following solution for grouping anagrams:\n```python\nfrom collections import defaultdict\n\ndef groupAnagrams(strs):\n    anagrams = defaultdict(list)\n    for s in strs:\n        key = ''.join(sorted(s))\n        anagrams[key].append(s)\n    return list(anagrams.values())\n```\nWhat is the time complexity?",
				"options": [
					"O(n * m log m), where n is the number of strings and m is the maximum length of a string",
					"O(n^2), where n is the number of strings",
					"O(n * m), where n is the number of strings and m is the maximum length of a string",
					"O(n log n), where n is the number of strings"
				],
				"explanation": "The time complexity is O(n * m log m) because for each string, we sort it, which takes O(m log m) time, where m is the length of the string. This sorting is done for each of the n strings, leading to the overall complexity.",
				"answer": "a",
				"topics": ["Hash Table", "String"]
			},
			{
				"question": "In the context of grouping anagrams, which of the following modifications would optimize the space complexity of the solution?\n```python\nfrom collections import defaultdict\n\ndef groupAnagrams(strs):\n    anagrams = defaultdict(list)\n    for s in strs:\n        key = ''.join(sorted(s))\n        anagrams[key].append(s)\n    return list(anagrams.values())\n```\nWhat change would you make?",
				"options": [
					"Use a regular dictionary instead of defaultdict.",
					"Use a tuple of character counts as the key instead of a sorted string.",
					"Store only unique anagrams in the list.",
					"Use a list instead of a dictionary to store anagrams."
				],
				"explanation": "Using a tuple of character counts as the key instead of a sorted string would optimize the space complexity. This is because the tuple is a fixed size (26 elements for lowercase English letters), whereas the sorted string can be as long as the input string, leading to higher space usage.",
				"answer": "b",
				"topics": ["Hash Table", "String"]
			}
		]
	},
	{
		"slug": "powx-n",
		"title": "Pow(x, n)",
		"leetcodeUrl": "https://leetcode.com/problems/powx-n",
		"difficulty": "Medium",
		"topics": ["Math"],
		"content": "Implement `pow(x, n)`, which calculates `x` raised to the power `n` (i.e., `x^n`).\n\n**Example 1:**\n```\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n```\n\n**Example 2:**\n```\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n```\n\n**Example 3:**\n```\nInput: x = 2.00000, n = -2\nOutput: 0.25000\n```\n\n**Explanation:**\n`2^-2 = 1/(2^2) = 1/4 = 0.25`\n\n**Constraints:**\n- `-100.0 < x < 100.0`\n- `-2^31 <= n <= 2^31 - 1`\n- `n` is an integer.\n- Either `x` is not zero or `n > 0`.\n- `-10^4 <= x^n <= 10^4`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the recursive solution for calculating `pow(x, n)` using the divide and conquer approach?",
				"options": ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
				"explanation": "The divide and conquer approach for calculating `pow(x, n)` involves reducing the problem size by half at each step. Specifically, if `n` is even, we compute `pow(x, n/2)` and square the result. If `n` is odd, we compute `x * pow(x, n-1)`. This results in a logarithmic number of recursive calls, leading to a time complexity of O(log n).",
				"answer": "b",
				"topics": ["Math", "Recursion", "Divide and Conquer"]
			},
			{
				"question": "Given the following implementation of `pow(x, n)`, identify the bug:\n```python\n1. def myPow(x, n):\n2.     if n == 0:\n3.         return 1\n4.     if n < 0:\n5.         x = 1 / x\n6.         n = -n\n7.     if n % 2 == 0:\n8.         return myPow(x * x, n // 2)\n9.     else:\n10.        return x * myPow(x, n - 1)\n```\nWhich line contains the bug and why does it still pass many test cases?",
				"options": [
					"Line 5: Incorrectly handles negative powers by inverting x",
					"Line 6: Incorrectly negates n without considering integer overflow",
					"Line 8: Incorrectly squares x instead of calling myPow(x, n // 2)",
					"Line 10: Incorrectly multiplies by x instead of calling myPow(x * x, n - 1)"
				],
				"explanation": "The bug is in Line 6. When `n` is the minimum integer value, negating it causes an overflow because the positive range is one less than the negative range in two's complement representation. However, this bug might not manifest in many test cases because the constraints often prevent `n` from being the minimum integer value.",
				"answer": "b",
				"topics": ["Math", "Recursion", "Implementation Analysis"]
			},
			{
				"question": "Which of the following modifications would optimize the space complexity of the recursive `pow(x, n)` function?",
				"options": [
					"Use an iterative approach instead of recursion",
					"Store intermediate results in a dictionary",
					"Use a stack to simulate recursion",
					"Increase the base case threshold"
				],
				"explanation": "Using an iterative approach instead of recursion would optimize the space complexity from O(log n) due to the recursion stack to O(1). This is because the iterative approach does not require additional space for the call stack.",
				"answer": "a",
				"topics": ["Math", "Recursion", "Space Optimization"]
			},
			{
				"question": "Consider the following iterative implementation of `pow(x, n)`. Which line should be added to handle negative exponents correctly?\n```python\n1. def myPow(x, n):\n2.     result = 1\n3.     current_product = x\n4.     while n > 0:\n5.         if n % 2 == 1:\n6.             result *= current_product\n7.         current_product *= current_product\n8.         n //= 2\n9.     ???\n10.    return result\n```",
				"options": [
					"if n < 0: result = 1 / result",
					"if n < 0: result *= x",
					"if n < 0: result = -result",
					"if n < 0: result = 0"
				],
				"explanation": "To handle negative exponents, we need to invert the result at the end of the computation. This is because `x^-n` is equivalent to `1/(x^n)`. Therefore, the correct line to add is `if n < 0: result = 1 / result`.",
				"answer": "a",
				"topics": ["Math", "Iterative Algorithms", "Edge Cases"]
			},
			{
				"question": "Analyze the time and space complexity of the following iterative solution for `pow(x, n)`:\n```python\n1. def myPow(x, n):\n2.     result = 1\n3.     current_product = x\n4.     abs_n = abs(n)\n5.     while abs_n > 0:\n6.         if abs_n % 2 == 1:\n7.             result *= current_product\n8.         current_product *= current_product\n9.         abs_n //= 2\n10.    if n < 0:\n11.        result = 1 / result\n12.    return result\n```\nWhat are the time and space complexities?",
				"options": [
					"Time: O(n), Space: O(1)",
					"Time: O(log n), Space: O(1)",
					"Time: O(n log n), Space: O(log n)",
					"Time: O(log n), Space: O(log n)"
				],
				"explanation": "The time complexity is O(log n) because the loop iterates while `abs_n` is greater than 0, and `abs_n` is halved in each iteration. The space complexity is O(1) because no additional space is used beyond a few variables, and there is no recursion stack involved.",
				"answer": "b",
				"topics": ["Math", "Iterative Algorithms", "Complexity Analysis"]
			}
		]
	},
	{
		"slug": "n-queens",
		"title": "51. N-Queens",
		"leetcodeUrl": "https://leetcode.com/problems/n-queens",
		"difficulty": "Hard",
		"topics": ["Backtracking", "Backtracking"],
		"content": "The `n`-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other. Given an integer `n`, return all distinct solutions to the `n`-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the `n`-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\n\n**Example 1:**\n```\nInput: n = 4\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\n```\n\n**Example 2:**\n```\nInput: n = 1\nOutput: [[\"Q\"]]\n```\n\n**Constraints:**\n- `1 <= n <= 9`",
		"rating": 2400,
		"MCQs": [
			{
				"question": "Given the following backtracking solution for the N-Queens problem, identify the bug that causes incorrect results for certain board sizes:\n```python\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def is_not_under_attack(row, col):\n            return not (cols[col] or hills[row - col] or dales[row + col])\n\n        def place_queen(row, col):\n            queens.add((row, col))\n            cols[col] = 1\n            hills[row - col] = 1\n            dales[row + col] = 1\n\n        def remove_queen(row, col):\n            queens.remove((row, col))\n            cols[col] = 0\n            hills[row - col] = 0\n            dales[row + col] = 0\n\n        def add_solution():\n            solution = []\n            for _, col in sorted(queens):\n                solution.append('.' * col + 'Q' + '.' * (n - col - 1))\n            output.append(solution)\n\n        def backtrack(row = 0):\n            for col in range(n):\n                if is_not_under_attack(row, col):\n                    place_queen(row, col)\n                    if row + 1 == n:\n                        add_solution()\n                    else:\n                        backtrack(row + 1)\n                    remove_queen(row, col)\n\n        cols = [0] * n\n        hills = [0] * (2 * n - 1)\n        dales = [0] * (2 * n - 1)\n        queens = set()\n        output = []\n        backtrack()\n        return output\n```\nWhich line contains the bug and why does it cause incorrect results?",
				"options": [
					"a) def is_not_under_attack(row, col): because it does not correctly check all attack paths",
					"b) queens.add((row, col)): because it uses a set which does not maintain order",
					"c) for _, col in sorted(queens): because sorting by row is unnecessary and incorrect",
					"d) if row + 1 == n: because it incorrectly checks for the last row"
				],
				"explanation": "The bug is in option c) for _, col in sorted(queens): because sorting by row is unnecessary and incorrect. The queens set is sorted by row, but the order of columns is what matters for constructing the solution string. This can lead to incorrect board configurations being added to the output.",
				"answer": "c",
				"topics": ["Backtracking", "Implementation Analysis"]
			},
			{
				"question": "Consider the following recursive solution for the N-Queens problem. What is the time complexity of this solution?\n```python\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def backtrack(row = 0):\n            for col in range(n):\n                if is_not_under_attack(row, col):\n                    place_queen(row, col)\n                    if row + 1 == n:\n                        add_solution()\n                    else:\n                        backtrack(row + 1)\n                    remove_queen(row, col)\n\n        def is_not_under_attack(row, col):\n            return not (cols[col] or hills[row - col] or dales[row + col])\n\n        def place_queen(row, col):\n            queens.add((row, col))\n            cols[col] = 1\n            hills[row - col] = 1\n            dales[row + col] = 1\n\n        def remove_queen(row, col):\n            queens.remove((row, col))\n            cols[col] = 0\n            hills[row - col] = 0\n            dales[row + col] = 0\n\n        def add_solution():\n            solution = []\n            for _, col in sorted(queens):\n                solution.append('.' * col + 'Q' + '.' * (n - col - 1))\n            output.append(solution)\n\n        cols = [0] * n\n        hills = [0] * (2 * n - 1)\n        dales = [0] * (2 * n - 1)\n        queens = set()\n        output = []\n        backtrack()\n        return output\n```\n",
				"options": [
					"a) O(n!) - because each queen has n choices, reducing by one each row",
					"b) O(n^n) - because each queen can be placed in any column for each row",
					"c) O(n^2) - because of the nested loops and constant checks",
					"d) O(2^n) - because of the binary decision at each row"
				],
				"explanation": "The time complexity of the N-Queens problem is O(n!) because each queen has n choices in the first row, n-1 in the second, and so on, leading to n! permutations. The backtracking approach efficiently prunes invalid configurations, but the worst-case scenario still involves exploring factorial possibilities.",
				"answer": "a",
				"topics": ["Backtracking", "Complexity Analysis"]
			},
			{
				"question": "In the N-Queens problem, which data structure is most appropriate for tracking the columns, hills, and dales that are under attack?",
				"options": [
					"a) Arrays, because they provide constant time access and update",
					"b) Sets, because they automatically handle duplicates and provide fast lookup",
					"c) Linked lists, because they allow dynamic resizing and easy insertion",
					"d) Dictionaries, because they map keys to values efficiently"
				],
				"explanation": "Arrays are the most appropriate data structure for tracking columns, hills, and dales under attack because they provide constant time access and update, which is crucial for efficiently checking and updating the attack status during backtracking.",
				"answer": "a",
				"topics": ["Data Structures", "Backtracking"]
			},
			{
				"question": "Given the following solution for the N-Queens problem, which line should replace the ??? to correctly handle the diagonal attacks?\n```python\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def backtrack(row = 0):\n            for col in range(n):\n                if is_not_under_attack(row, col):\n                    place_queen(row, col)\n                    if row + 1 == n:\n                        add_solution()\n                    else:\n                        backtrack(row + 1)\n                    remove_queen(row, col)\n\n        def is_not_under_attack(row, col):\n            return not (cols[col] or hills[row - col] or dales[row + col])\n\n        def place_queen(row, col):\n            queens.add((row, col))\n            cols[col] = 1\n            hills[row - col] = 1\n            dales[row + col] = 1\n\n        def remove_queen(row, col):\n            queens.remove((row, col))\n            cols[col] = 0\n            hills[row - col] = 0\n            dales[row + col] = 0\n\n        def add_solution():\n            solution = []\n            for _, col in sorted(queens):\n                solution.append('.' * col + 'Q' + '.' * (n - col - 1))\n            output.append(solution)\n\n        cols = [0] * n\n        hills = [0] * (2 * n - 1)\n        dales = [0] * (2 * n - 1)\n        queens = set()\n        output = []\n        backtrack()\n        return output\n```\nWhich line should replace the ??? in the is_not_under_attack function?",
				"options": [
					"a) return not (cols[col] or hills[row - col + n - 1] or dales[row + col])",
					"b) return not (cols[col] or hills[row - col] or dales[row + col])",
					"c) return not (cols[col] or hills[row - col] or dales[row + col - n + 1])",
					"d) return not (cols[col] or hills[row - col + n] or dales[row + col])"
				],
				"explanation": "The correct line is b) return not (cols[col] or hills[row - col] or dales[row + col]). This line correctly checks if the current position is under attack by any previously placed queens, considering the column, hill, and dale attacks. The indices for hills and dales are correctly calculated to ensure no overlap in attack paths.",
				"answer": "b",
				"topics": ["Backtracking", "Implementation Analysis"]
			},
			{
				"question": "Which of the following modifications would optimize the space complexity of the N-Queens solution while maintaining the same time complexity?\n",
				"options": [
					"a) Use bit manipulation to track columns, hills, and dales",
					"b) Replace the queens set with a list",
					"c) Use a single array to track all attack paths",
					"d) Change the recursion to iteration to avoid stack space"
				],
				"explanation": "Using bit manipulation to track columns, hills, and dales (option a) would optimize the space complexity. This approach reduces the space used for tracking attack paths from O(n) to O(1) by using integer bitmasks, which is efficient for small n (up to 32 or 64 depending on the system).",
				"answer": "a",
				"topics": ["Backtracking", "Optimization"]
			}
		]
	},
	{
		"slug": "n-queens-ii",
		"title": "N-Queens II",
		"leetcodeUrl": "https://leetcode.com/problems/n-queens-ii",
		"difficulty": "Medium",
		"topics": ["Backtracking", "Recursion"],
		"content": "The `n`-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other. Given an integer `n`, return the number of distinct solutions to the `n`-queens puzzle.\n\n**Example 1:**\n```\nInput: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.\n```\n\n**Example 2:**\n```\nInput: n = 1\nOutput: 1\n```\n\n**Constraints:**\n- `1 <= n <= 9`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to solve the N-Queens II problem efficiently?",
				"options": [
					"a) Use a brute force approach to try all possible placements of queens.",
					"b) Use backtracking to place queens row by row, ensuring no two queens threaten each other.",
					"c) Use dynamic programming to store the number of ways queens can be placed on smaller boards.",
					"d) Use a greedy algorithm to place queens in the first available position."
				],
				"explanation": "The N-Queens II problem is best solved using a backtracking approach. This method involves placing queens one row at a time and ensuring that no two queens threaten each other by checking columns and diagonals. Brute force is inefficient due to the exponential number of possibilities, dynamic programming is not suitable for this problem, and a greedy algorithm does not guarantee a valid solution.",
				"answer": "b",
				"topics": ["Backtracking", "Recursion"]
			},
			{
				"question": "In the backtracking solution for the N-Queens II problem, which data structures are typically used to track the positions of the queens?",
				"options": [
					"a) A 2D array to represent the board and mark queen positions.",
					"b) Three sets to track columns, and two diagonals (major and minor).",
					"c) A single list to track the row positions of queens in each column.",
					"d) A stack to push and pop queen positions as they are placed and removed."
				],
				"explanation": "In the backtracking solution, three sets are commonly used to track the columns and the two diagonals (major and minor) where queens are placed. This allows for efficient checking of whether a queen can be placed in a given position without being attacked.",
				"answer": "b",
				"topics": ["Backtracking", "Recursion"]
			},
			{
				"question": "Consider the following backtracking code for solving the N-Queens II problem. Identify the bug in the code:\n```python\n1. def totalNQueens(n):\n2.     def backtrack(row, cols, diags1, diags2):\n3.         if row == n:\n4.             return 1\n5.         count = 0\n6.         for col in range(n):\n7.             diag1 = row - col\n8.             diag2 = row + col\n9.             if col in cols or diag1 in diags1 or diag2 in diags2:\n10.                continue\n11.            cols.add(col)\n12.            diags1.add(diag1)\n13.            diags2.add(diag2)\n14.            count += backtrack(row + 1, cols, diags1, diags2)\n15.            cols.remove(col)\n16.            diags1.remove(diag1)\n17.            diags2.remove(diag2)\n18.        return count\n19.     return backtrack(0, set(), set(), set())\n```\nWhat is the bug in this code?",
				"options": [
					"a) The code does not correctly handle the base case when row == n.",
					"b) The code incorrectly calculates the diagonal indices.",
					"c) The code does not reset the sets after backtracking.",
					"d) The code does not increment the row variable correctly."
				],
				"explanation": "The code correctly handles the base case and calculates the diagonal indices. The bug is not in the resetting of the sets, as they are correctly removed after backtracking. The issue is not with the row increment either. Therefore, there is no bug in the provided code; it correctly implements the backtracking approach for the N-Queens II problem.",
				"answer": "c",
				"topics": ["Backtracking", "Recursion"]
			},
			{
				"question": "What is the time complexity of the backtracking solution for the N-Queens II problem?",
				"options": ["a) O(n!)", "b) O(n^n)", "c) O(n^2)", "d) O(2^n)"],
				"explanation": "The time complexity of the backtracking solution for the N-Queens problem is O(n!), as it involves placing queens one by one and checking for valid positions, which leads to a factorial number of possibilities in the worst case.",
				"answer": "a",
				"topics": ["Backtracking", "Recursion"]
			},
			{
				"question": "In the N-Queens II problem, how does the use of sets for columns and diagonals improve the efficiency of the solution?",
				"options": [
					"a) Sets allow for constant time complexity checks for queen attacks.",
					"b) Sets reduce the space complexity of the solution.",
					"c) Sets allow for storing multiple solutions simultaneously.",
					"d) Sets simplify the implementation by avoiding recursion."
				],
				"explanation": "Using sets for columns and diagonals allows for constant time complexity checks to determine if a queen can be placed in a given position without being attacked. This improves the efficiency of the solution by quickly ruling out invalid positions.",
				"answer": "a",
				"topics": ["Backtracking", "Recursion"]
			}
		]
	},
	{
		"slug": "maximum-subarray",
		"title": "Maximum Subarray",
		"leetcodeUrl": "https://leetcode.com/problems/maximum-subarray",
		"difficulty": "Medium",
		"topics": ["Array", "Dynamic Programming"],
		"content": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.\n\n**Example 1:**\n```\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n```\n\n**Example 2:**\n```\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n```\n\n**Example 3:**\n```\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n```\n\n**Constraints:**\n- `1 <= nums.length <= 10^5`\n- `-10^4 <= nums[i] <= 10^4`\n\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following algorithms is most suitable for solving the Maximum Subarray problem in O(n) time complexity?",
				"options": [
					"Kadane's Algorithm",
					"Merge Sort",
					"Quick Sort",
					"Binary Search"
				],
				"explanation": "Kadane's Algorithm is specifically designed to solve the Maximum Subarray problem in O(n) time complexity. It efficiently finds the maximum sum of a contiguous subarray by iterating through the array once and keeping track of the current subarray sum and the maximum sum found so far.",
				"answer": "a",
				"topics": ["Array", "Dynamic Programming"]
			},
			{
				"question": "Given the following implementation of Kadane's Algorithm, identify the bug that could cause incorrect results:\n```python\n1. def maxSubArray(nums):\n2.     max_sum = nums[0]\n3.     current_sum = 0\n4.     for num in nums:\n5.         current_sum = max(current_sum + num, num)\n6.         max_sum = max(max_sum, current_sum)\n7.     return max_sum\n```\nWhat is the issue with this implementation?",
				"options": [
					"The initial value of current_sum should be nums[0] instead of 0.",
					"The loop should start from the second element of nums.",
					"The max function on line 5 should compare with 0 instead of num.",
					"The return statement should return current_sum instead of max_sum."
				],
				"explanation": "The bug is in the initialization of current_sum. It should start with the first element of the array (nums[0]) to handle cases where all elements are negative. Starting with 0 can lead to incorrect results if the array contains only negative numbers.",
				"answer": "a",
				"topics": ["Array", "Dynamic Programming"]
			},
			{
				"question": "Consider the divide and conquer approach to solve the Maximum Subarray problem. Which of the following statements is true about its time complexity?",
				"options": [
					"It has a time complexity of O(n log n).",
					"It has a time complexity of O(n^2).",
					"It has a time complexity of O(n).",
					"It has a time complexity of O(log n)."
				],
				"explanation": "The divide and conquer approach for the Maximum Subarray problem divides the array into two halves, recursively finds the maximum subarray sum for each half, and then finds the maximum subarray sum that crosses the midpoint. This results in a time complexity of O(n log n), similar to merge sort.",
				"answer": "a",
				"topics": ["Array", "Divide and Conquer"]
			},
			{
				"question": "In the context of the Maximum Subarray problem, which of the following modifications would allow Kadane's Algorithm to also return the indices of the subarray with the maximum sum?",
				"options": [
					"Track the start and end indices whenever max_sum is updated.",
					"Use a separate array to store the subarray elements.",
					"Modify the algorithm to use a stack to track indices.",
					"Use a hash map to store sums and their corresponding indices."
				],
				"explanation": "To return the indices of the subarray with the maximum sum, you can track the start and end indices whenever max_sum is updated. Initialize a start index at the beginning of the array and update it whenever the current_sum is reset to the current element. Update the end index whenever max_sum is updated.",
				"answer": "a",
				"topics": ["Array", "Dynamic Programming"]
			},
			{
				"question": "Analyze the space complexity of Kadane's Algorithm for the Maximum Subarray problem. Which of the following is correct?",
				"options": [
					"O(1) because it uses a constant amount of extra space.",
					"O(n) because it requires an additional array to store subarray sums.",
					"O(log n) due to recursive stack space.",
					"O(n^2) because it checks all possible subarrays."
				],
				"explanation": "Kadane's Algorithm has a space complexity of O(1) because it only uses a constant amount of extra space to store variables like current_sum and max_sum. It does not require any additional data structures that grow with the input size.",
				"answer": "a",
				"topics": ["Array", "Dynamic Programming"]
			}
		]
	},
	{
		"slug": "spiral-matrix",
		"title": "Spiral Matrix",
		"leetcodeUrl": "https://leetcode.com/problems/spiral-matrix",
		"difficulty": "Medium",
		"topics": ["Array"],
		"content": "Given an `m x n` matrix, return all elements of the matrix in spiral order.\n\n**Example 1:**\n```\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n```\n\n**Example 2:**\n```\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n```\n\n**Constraints:**\n- `m == matrix.length`\n- `n == matrix[i].length`\n- `1 <= m, n <= 10`\n- `-100 <= matrix[i][j] <= 100`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the algorithm to traverse a matrix in spiral order?",
				"options": ["O(m * n)", "O(m + n)", "O(m^2 * n^2)", "O(log(m * n))"],
				"explanation": "The time complexity is O(m * n) because each element of the matrix is visited exactly once in the spiral traversal.",
				"answer": "a",
				"topics": ["Array", "Complexity Analysis"]
			},
			{
				"question": "Given the following code snippet for spiral order traversal, which line contains a bug?\n```python\n1. def spiralOrder(matrix):\n2.     result = []\n3.     while matrix:\n4.         result += matrix.pop(0)\n5.         if matrix and matrix[0]:\n6.             for row in matrix:\n7.                 result.append(row.pop())\n8.         if matrix:\n9.             result += matrix.pop()[::-1]\n10.        if matrix and matrix[0]:\n11.            for row in matrix[::-1]:\n12.                result.append(row.pop(0))\n13.    return result\n```\nWhich line contains the bug and why?",
				"options": [
					"Line 4: Incorrectly pops the first row without checking if matrix is empty",
					"Line 7: Appends elements in the wrong order",
					"Line 9: Incorrectly reverses the last row",
					"Line 11: Iterates over matrix in the wrong direction"
				],
				"explanation": "Line 11 contains the bug. The iteration over matrix[::-1] is correct, but it should be done only if matrix is not empty. The check is already done in line 10, so the bug is subtle and might not affect all cases.",
				"answer": "d",
				"topics": ["Array", "Implementation Analysis"]
			},
			{
				"question": "In the context of spiral order traversal, which data structure is most appropriate for storing intermediate results?",
				"options": ["Stack", "Queue", "List", "Set"],
				"explanation": "A list is most appropriate for storing intermediate results in spiral order traversal because it allows for easy appending and concatenation of elements in the order they are visited.",
				"answer": "c",
				"topics": ["Array", "Data Structures"]
			},
			{
				"question": "Consider the following modification to the spiral order algorithm: Instead of popping elements, the algorithm marks them as visited. What is the primary trade-off of this approach?",
				"options": [
					"Increased time complexity due to additional checks",
					"Increased space complexity due to extra storage for visited markers",
					"Decreased readability of the code",
					"Increased risk of infinite loops"
				],
				"explanation": "The primary trade-off is increased space complexity due to the need for extra storage to mark visited elements. This approach avoids modifying the original matrix but requires additional space.",
				"answer": "b",
				"topics": ["Array", "Optimization Modifications"]
			},
			{
				"question": "Which of the following scenarios would make a recursive approach to spiral order traversal less efficient than an iterative one?",
				"options": [
					"A very small matrix (e.g., 1x1)",
					"A matrix with a large number of rows and columns",
					"A matrix with many duplicate elements",
					"A matrix with negative numbers"
				],
				"explanation": "A matrix with a large number of rows and columns would make a recursive approach less efficient due to the overhead of recursive calls and the risk of stack overflow. Iterative solutions are generally more space-efficient in such cases.",
				"answer": "b",
				"topics": ["Array", "Recursion vs Iteration"]
			}
		]
	},
	{
		"slug": "jump-game",
		"title": "Jump Game",
		"leetcodeUrl": "https://leetcode.com/problems/jump-game",
		"difficulty": "Medium",
		"topics": ["Greedy", "Array"],
		"content": "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return `true` if you can reach the last index, or `false` otherwise.\n\n**Example 1:**\n```\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n**Example 2:**\n```\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n```\n\n**Constraints:**\n- `1 <= nums.length <= 10^4`\n- `0 <= nums[i] <= 10^5`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct greedy approach to solve the Jump Game problem?",
				"options": [
					"a) Start from the first index and try to jump to the farthest possible index at each step.",
					"b) Start from the last index and move backwards, checking if each index can reach the last index.",
					"c) Use dynamic programming to store the minimum jumps needed to reach each index.",
					"d) Use a breadth-first search to explore all possible jumps from each index."
				],
				"explanation": "The greedy approach involves iterating through the array and keeping track of the farthest index that can be reached. If at any point the current index is greater than the farthest reachable index, return false. Otherwise, if the farthest reachable index is greater than or equal to the last index, return true. This approach works because it always tries to extend the reach as far as possible at each step, ensuring that if the last index is reachable, it will be reached.",
				"answer": "a",
				"topics": ["Greedy", "Array"]
			},
			{
				"question": "In the Jump Game problem, what is the time complexity of the optimal greedy solution?",
				"options": ["a) O(n^2)", "b) O(n log n)", "c) O(n)", "d) O(1)"],
				"explanation": "The optimal greedy solution involves a single pass through the array, updating the farthest reachable index at each step. This results in a time complexity of O(n), where n is the length of the array.",
				"answer": "c",
				"topics": ["Greedy", "Array"]
			},
			{
				"question": "Consider the following implementation of the Jump Game problem. Identify the bug in the code:\n```python\n1. def canJump(nums):\n2.     max_reach = 0\n3.     for i in range(len(nums)):\n4.         if i > max_reach:\n5.             return False\n6.         max_reach = max(max_reach, i + nums[i])\n7.     return True\n```\nWhy does this implementation fail for some test cases?",
				"options": [
					"a) The loop should start from index 1 instead of 0.",
					"b) The condition `i > max_reach` should be `i >= max_reach`.",
					"c) The function should return `True` only if `max_reach` is greater than or equal to the last index.",
					"d) The `max_reach` should be initialized to `nums[0]`."
				],
				"explanation": "The implementation is correct as it is. The condition `i > max_reach` correctly checks if the current index is beyond the farthest reachable index, and `max_reach` is updated to the maximum of its current value and the reach from the current index. The function returns `True` if the loop completes without returning `False`, which means the last index is reachable.",
				"answer": "c",
				"topics": ["Greedy", "Array"]
			},
			{
				"question": "Given the Jump Game problem, which of the following modifications would allow the solution to work in-place without additional space?",
				"options": [
					"a) Use a separate array to track the farthest reachable index from each position.",
					"b) Modify the input array to store the maximum reach at each index instead of the jump length.",
					"c) Use two pointers to track the current position and the farthest reachable index.",
					"d) Change the iteration direction to avoid using extra variables."
				],
				"explanation": "The greedy solution already works in-place as it only uses a constant amount of extra space (for the `max_reach` variable). Therefore, no modification is needed to make it work in-place.",
				"answer": "c",
				"topics": ["Greedy", "Array"]
			},
			{
				"question": "Analyze the time and space complexity of the following recursive solution for the Jump Game problem:\n```python\n@lru_cache(None)\ndef canJumpFromPosition(position, nums):\n    if position == len(nums) - 1:\n        return True\n    furthestJump = min(position + nums[position], len(nums) - 1)\n    for nextPosition in range(position + 1, furthestJump + 1):\n        if canJumpFromPosition(nextPosition, nums):\n            return True\n    return False\n```\nWhat are the complexities?",
				"options": [
					"a) Time: O(n^2), Space: O(n)",
					"b) Time: O(2^n), Space: O(n)",
					"c) Time: O(n^2), Space: O(n^2)",
					"d) Time: O(n), Space: O(n)"
				],
				"explanation": "The recursive solution with memoization has a time complexity of O(n^2) because each position can potentially call the function for every other position up to its maximum jump. The space complexity is O(n^2) due to the memoization table storing results for each subproblem, and the recursion stack can grow up to O(n) in depth.",
				"answer": "c",
				"topics": ["Dynamic Programming", "Recursion", "Memoization"]
			}
		]
	},
	{
		"slug": "merge-intervals",
		"title": "Merge Intervals",
		"leetcodeUrl": "https://leetcode.com/problems/merge-intervals",
		"difficulty": "Medium",
		"topics": ["Array", "Sort"],
		"content": "Given an array of intervals where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\n**Example 1:**\n```\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n```\n\n**Example 2:**\n```\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n```\n\n**Constraints:**\n- `1 <= intervals.length <= 10^4`\n- `intervals[i].length == 2`\n- `0 <= starti <= endi <= 10^4`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "In this solution for merge intervals, which line should replace the ??? to correctly merge overlapping intervals?\n```python\ndef merge(intervals):\n    if not intervals:\n        return []\n    \n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    \n    for interval in intervals[1:]:\n        if ???:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged\n```",
				"options": [
					"a) interval[0] <= merged[-1][1]",
					"b) interval[0] <= merged[-1][1] + 1",
					"c) interval[0] - merged[-1][1] <= 1",
					"d) merged[-1][1] >= interval[0]"
				],
				"explanation": "The correct condition to check if two intervals overlap is to see if the start of the current interval is less than or equal to the end of the last merged interval. This is because overlapping intervals will have their start point within the range of the last merged interval.",
				"answer": "a",
				"topics": ["Array", "Sort"]
			},
			{
				"question": "Given this solution for finding the longest palindromic substring:\n```python\ndef longestPalindrome(s):\n    longest = ''\n    for i in range(len(s)):\n        # Expand around center for odd length\n        left, right = i, i\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            if right - left > len(longest):  # BUG: Should be right - left + 1\n                longest = s[left:right]\n            left -= 1\n            right += 1\n        \n        # Even length palindromes\n        left, right = i, i+1\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            if right - left > len(longest):\n                longest = s[left:right]\n            left -= 1\n            right += 1\n    return longest\n```\nWhich line contains the bug and why does it still pass many test cases?",
				"options": [
					"a) if right - left > len(longest): because it compares length with index difference",
					"b) longest = s[left:right]: because it slices incorrectly",
					"c) while left >= 0 and right < len(s): because it checks bounds in wrong order",
					"d) left, right = i, i: because it starts from wrong indices"
				],
				"explanation": "The bug is in the condition `if right - left > len(longest):`. It should be `if right - left + 1 > len(longest):` because the length of the substring is `right - left + 1`. However, it still passes many test cases because the condition often holds true for palindromes of odd length, where the center expansion naturally covers the correct length.",
				"answer": "a",
				"topics": ["String", "Dynamic Programming"]
			},
			{
				"question": "Analyze the time and space complexity of this recursive solution, considering both the recursion stack and memoization:\n```python\n@lru_cache(None)\ndef solve(s, i, j):\n    if i >= j:\n        return 0\n    if s[i] == s[j]:\n        return solve(s, i+1, j-1)\n    return 1 + min(solve(s, i+1, j), solve(s, i, j-1))\n```",
				"options": [
					"a) Time: O(2^n), Space: O(n) - the memoization reduces time to O(n²)",
					"b) Time: O(n²), Space: O(n²) - due to memoization storing all subproblems",
					"c) Time: O(n²), Space: O(n) - memoization reuses space but stack grows linearly",
					"d) Time: O(n²), Space: O(n²) - both recursion stack and cache grow quadratically"
				],
				"explanation": "The time complexity is O(n²) because memoization ensures that each subproblem is solved only once, and there are O(n²) subproblems. The space complexity is also O(n²) because the memoization cache stores results for each subproblem, and the recursion stack can grow to O(n) depth, but the cache is the dominant factor.",
				"answer": "b",
				"topics": ["Recursion", "Dynamic Programming"]
			},
			{
				"question": "Given these three solutions for finding the kth largest element:\nA) QuickSelect algorithm\nB) Heap-based solution\nC) Sorting-based solution\n\nWhich combination of input characteristics would make solution B perform better than both A and C?",
				"options": [
					"a) Large array size (n > 10⁶), k is close to n/2, elements are randomly distributed",
					"b) Small array size (n < 10³), k is very small (k < 10), many duplicates present",
					"c) Medium array size (10⁴ < n < 10⁵), k is close to n, elements are nearly sorted",
					"d) Large array size (n > 10⁶), k is very small (k < 100), elements are roughly sorted"
				],
				"explanation": "The heap-based solution (B) is particularly efficient when k is very small compared to n, as it only needs to maintain a heap of size k. This makes it more efficient than sorting the entire array (C) and more stable than QuickSelect (A) in terms of worst-case performance, especially when the array is large and k is small.",
				"answer": "d",
				"topics": ["Heap", "Sorting", "Divide and Conquer"]
			},
			{
				"question": "What is the time complexity of the following code snippet?\n```python\ndef example(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            for k in range(j, n):\n                print(arr[i], arr[j], arr[k])\n```\n",
				"options": ["a) O(n^3)", "b) O(n^2)", "c) O(n^4)", "d) O(n^2 log n)"],
				"explanation": "The code contains three nested loops, each iterating over a range that depends on the length of the array. The outer loop runs n times, the middle loop runs n-i times, and the innermost loop runs n-j times. This results in a time complexity of O(n^3) as the number of operations is proportional to the sum of the series of the product of the loop ranges.",
				"answer": "a",
				"topics": ["Time Complexity", "Nested Loops"]
			}
		]
	},
	{
		"slug": "insert-interval",
		"title": "Insert Interval",
		"leetcodeUrl": "https://leetcode.com/problems/insert-interval",
		"difficulty": "Medium",
		"topics": ["Array", "Sorting"],
		"content": "You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `i`th interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval. Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary). Return `intervals` after the insertion.\n\n**Example 1:**\n```\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n```\n\n**Example 2:**\n```\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\n```\n\n**Constraints:**\n- `0 <= intervals.length <= 10^4`\n- `intervals[i].length == 2`\n- `0 <= starti <= endi <= 10^5`\n- `intervals` is sorted by `starti` in ascending order.\n- `newInterval.length == 2`\n- `0 <= start <= end <= 10^5`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to insert a new interval into a sorted list of non-overlapping intervals and merge if necessary?",
				"options": [
					"Iterate through the list, insert the new interval at the end, and sort the list again.",
					"Iterate through the list, find the correct position to insert the new interval, and merge overlapping intervals.",
					"Use a binary search to find the position to insert the new interval, then merge overlapping intervals.",
					"Insert the new interval at the beginning and sort the list again."
				],
				"explanation": "The correct approach is to iterate through the list, find the correct position to insert the new interval, and merge overlapping intervals. This ensures that the list remains sorted and non-overlapping. Sorting the list again after insertion is inefficient and unnecessary.",
				"answer": "b",
				"topics": ["Array", "Sorting"]
			},
			{
				"question": "Given the following code snippet for inserting a new interval, which line contains a bug?\n```python\n1. def insert(intervals, newInterval):\n2.     result = []\n3.     for i in range(len(intervals)):\n4.         if intervals[i][1] < newInterval[0]:\n5.             result.append(intervals[i])\n6.         elif intervals[i][0] > newInterval[1]:\n7.             result.append(newInterval)\n8.             newInterval = intervals[i]\n9.         else:\n10.            newInterval[0] = min(newInterval[0], intervals[i][0])\n11.            newInterval[1] = max(newInterval[1], intervals[i][1])\n12.    result.append(newInterval)\n13.    return result\n```",
				"options": [
					"Line 4: if intervals[i][1] < newInterval[0]:",
					"Line 6: elif intervals[i][0] > newInterval[1]:",
					"Line 7: result.append(newInterval)",
					"Line 12: result.append(newInterval)"
				],
				"explanation": "The bug is in Line 7. The newInterval should only be appended once, after all overlapping intervals have been merged. The current logic appends newInterval multiple times if there are multiple non-overlapping intervals after the merge.",
				"answer": "c",
				"topics": ["Array", "Sorting"]
			},
			{
				"question": "In the context of inserting a new interval into a sorted list of intervals, which of the following statements about time complexity is true?",
				"options": [
					"The time complexity is O(n log n) due to sorting the intervals after insertion.",
					"The time complexity is O(n) because we only iterate through the intervals once.",
					"The time complexity is O(n^2) because we might need to merge multiple intervals.",
					"The time complexity is O(log n) because we use binary search to find the insertion point."
				],
				"explanation": "The time complexity is O(n) because we iterate through the intervals once to find the correct position for insertion and merge overlapping intervals. Sorting is not required, and binary search is not applicable as we need to check for overlaps.",
				"answer": "b",
				"topics": ["Array", "Sorting"]
			},
			{
				"question": "Consider the following code for inserting a new interval. Which line should replace the ??? to correctly handle the merging of overlapping intervals?\n```python\n1. def insert(intervals, newInterval):\n2.     result = []\n3.     for interval in intervals:\n4.         if ???:\n5.             result.append(interval)\n6.         elif interval[0] > newInterval[1]:\n7.             result.append(newInterval)\n8.             newInterval = interval\n9.         else:\n10.            newInterval[0] = min(newInterval[0], interval[0])\n11.            newInterval[1] = max(newInterval[1], interval[1])\n12.    result.append(newInterval)\n13.    return result\n```",
				"options": [
					"interval[1] < newInterval[0]",
					"interval[0] < newInterval[1]",
					"interval[0] <= newInterval[1]",
					"interval[1] <= newInterval[0]"
				],
				"explanation": "The correct condition is `interval[1] < newInterval[0]`, which checks if the current interval ends before the new interval starts, meaning they do not overlap and the current interval can be added to the result as is.",
				"answer": "a",
				"topics": ["Array", "Sorting"]
			},
			{
				"question": "Which of the following scenarios would make a heap-based solution for finding the kth largest element more efficient than a QuickSelect algorithm?",
				"options": [
					"Large array size (n > 10⁶), k is close to n/2, elements are randomly distributed",
					"Small array size (n < 10³), k is very small (k < 10), many duplicates present",
					"Medium array size (10⁴ < n < 10⁵), k is close to n, elements are nearly sorted",
					"Large array size (n > 10⁶), k is very small (k < 100), elements are roughly sorted"
				],
				"explanation": "A heap-based solution is more efficient when the array size is large and k is small, as it can maintain a min-heap of size k, which is efficient for small k. The QuickSelect algorithm is more efficient for finding the median or when k is large relative to n.",
				"answer": "d",
				"topics": ["Heap", "Sorting", "Selection"]
			},
			{
				"question": "Analyze the time and space complexity of the following recursive solution with memoization:\n```python\n@lru_cache(None)\ndef solve(s, i, j):\n    if i >= j:\n        return 0\n    if s[i] == s[j]:\n        return solve(s, i+1, j-1)\n    return 1 + min(solve(s, i+1, j), solve(s, i, j-1))\n```\nWhat are the time and space complexities?",
				"options": [
					"Time: O(2^n), Space: O(n) - the memoization reduces time to O(n²)",
					"Time: O(n²), Space: O(n²) - due to memoization storing all subproblems",
					"Time: O(n²), Space: O(n) - memoization reuses space but stack grows linearly",
					"Time: O(n²), Space: O(n²) - both recursion stack and cache grow quadratically"
				],
				"explanation": "The time complexity is O(n²) because memoization ensures each subproblem is solved only once, and there are O(n²) subproblems. The space complexity is O(n²) because the memoization cache stores results for all subproblems, and the recursion stack can grow to O(n) depth, but the cache dominates space usage.",
				"answer": "b",
				"topics": ["Recursion", "Memoization", "Dynamic Programming"]
			}
		]
	},
	{
		"slug": "length-of-last-word",
		"title": "Length of Last Word",
		"leetcodeUrl": "https://leetcode.com/problems/length-of-last-word",
		"difficulty": "Easy",
		"topics": ["String"],
		"content": "Given a string `s` consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only.\n\n**Example 1:**\n```\nInput: s = \"Hello World\"\nOutput: 5\nExplanation: The last word is \"World\" with length 5.\n```\n\n**Example 2:**\n```\nInput: s = \"fly me to the moon\"\nOutput: 4\nExplanation: The last word is \"moon\" with length 4.\n```\n\n**Example 3:**\n```\nInput: s = \"luffy is still joyboy\"\nOutput: 6\nExplanation: The last word is \"joyboy\" with length 6.\n```\n\n**Constraints:**\n- `1 <= s.length <= 10^4`\n- `s` consists of only English letters and spaces.\n- There will be at least one word in `s`.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of the following solution for finding the length of the last word in a string?\n```python\ndef lengthOfLastWord(s):\n    return len(s.strip().split(' ')[-1])\n```\n",
				"options": ["O(n)", "O(n^2)", "O(log n)", "O(1)"],
				"explanation": "The solution first uses `strip()` to remove leading and trailing spaces, which is O(n). Then it uses `split(' ')` to split the string into words, which is also O(n) in the worst case. Finally, it accesses the last element of the list, which is O(1). Therefore, the overall time complexity is O(n).",
				"answer": "a",
				"topics": ["String", "Time Complexity"]
			},
			{
				"question": "Given the following code snippet, which line contains a bug that could cause incorrect results for certain inputs?\n```python\n1. def lengthOfLastWord(s):\n2.     words = s.split()\n3.     if not words:\n4.         return 0\n5.     return len(words[-1])\n```\n",
				"options": [
					"Line 2: words = s.split()",
					"Line 3: if not words:",
					"Line 4: return 0",
					"Line 5: return len(words[-1])"
				],
				"explanation": "The code correctly splits the string into words and checks if the list is empty. However, the check on line 3 is unnecessary because the problem guarantees at least one word in the string. The code will work correctly, but the check is redundant given the constraints.",
				"answer": "b",
				"topics": ["String", "Implementation Analysis"]
			},
			{
				"question": "In the following solution for finding the length of the last word, which line should replace the ??? to correctly handle trailing spaces?\n```python\n1. def lengthOfLastWord(s):\n2.     length = 0\n3.     for char in reversed(s):\n4.         if char == ' ' and length > 0:\n5.             break\n6.         elif ???:\n7.             length += 1\n8.     return length\n```\n",
				"options": [
					"char != ' '",
					"char == ' '",
					"char.isalpha()",
					"char.isdigit()"
				],
				"explanation": "The correct condition is `char != ' '`, which ensures that the length is only incremented for non-space characters. This handles trailing spaces correctly by only counting characters after the last space.",
				"answer": "a",
				"topics": ["String", "Implementation"]
			},
			{
				"question": "Which of the following data structures is most appropriate for efficiently finding the length of the last word in a string with frequent updates and queries?\n",
				"options": ["Array", "Linked List", "Trie", "HashMap"],
				"explanation": "An array is most appropriate for this problem because it allows for efficient access and updates. The problem involves simple string manipulation, and an array (or list in Python) is sufficient for handling the operations needed to find the length of the last word.",
				"answer": "a",
				"topics": ["Data Structures", "String"]
			},
			{
				"question": "Consider the following solution for finding the length of the last word. What is the space complexity?\n```python\ndef lengthOfLastWord(s):\n    words = s.split()\n    return len(words[-1])\n```\n",
				"options": ["O(1)", "O(n)", "O(n^2)", "O(log n)"],
				"explanation": "The space complexity is O(n) because the `split()` function creates a list of words, which in the worst case can be as large as the input string itself. This requires additional space proportional to the length of the string.",
				"answer": "b",
				"topics": ["String", "Space Complexity"]
			}
		]
	},
	{
		"slug": "spiral-matrix-ii",
		"title": "Spiral Matrix II",
		"leetcodeUrl": "https://leetcode.com/problems/spiral-matrix-ii",
		"difficulty": "Medium",
		"topics": ["Array", "Matrix"],
		"content": "Given a positive integer `n`, generate an `n x n` matrix filled with elements from `1` to `n^2` in spiral order.\n\n**Example 1:**\n```\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n```\n\n**Example 2:**\n```\nInput: n = 1\nOutput: [[1]]\n```\n\n**Constraints:**\n- `1 <= n <= 20`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of generating an n x n matrix filled with elements from 1 to n^2 in spiral order?",
				"options": ["O(n^2)", "O(n)", "O(n log n)", "O(n^3)"],
				"explanation": "The time complexity is O(n^2) because we need to fill each of the n^2 elements in the matrix exactly once. The process involves iterating over the matrix in a spiral order, but the number of operations is proportional to the number of elements, which is n^2.",
				"answer": "a",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "Given the following code snippet for generating a spiral matrix, which line contains a bug that prevents it from correctly filling the matrix?\n```python\n1. def generateMatrix(n):\n2.     matrix = [[0] * n for _ in range(n)]\n3.     left, right, top, bottom = 0, n-1, 0, n-1\n4.     num = 1\n5.     while left <= right and top <= bottom:\n6.         for i in range(left, right + 1):\n7.             matrix[top][i] = num\n8.             num += 1\n9.         top += 1\n10.        for i in range(top, bottom + 1):\n11.            matrix[i][right] = num\n12.            num += 1\n13.        right -= 1\n14.        for i in range(right, left - 1, -1):\n15.            matrix[bottom][i] = num\n16.            num += 1\n17.        bottom -= 1\n18.        for i in range(bottom, top - 1, -1):\n19.            matrix[i][left] = num\n20.            num += 1\n21.        left += 1\n22.    return matrix\n```",
				"options": [
					"Line 6: for i in range(left, right + 1)",
					"Line 14: for i in range(right, left - 1, -1)",
					"Line 18: for i in range(bottom, top - 1, -1)",
					"Line 3: left, right, top, bottom = 0, n-1, 0, n-1"
				],
				"explanation": "The bug is in Line 14: `for i in range(right, left - 1, -1)`. The loop should iterate from `right` to `left`, inclusive, in reverse order. The condition `left - 1` is correct, but the loop should ensure it doesn't skip the `left` index. The code is correct as is, but this line is often a source of off-by-one errors if not carefully implemented.",
				"answer": "b",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "In the context of generating a spiral matrix, which of the following modifications would allow the algorithm to work in-place if the matrix is pre-allocated?",
				"options": [
					"Use a single pointer to track the current position and direction",
					"Replace the matrix with a 1D array and map indices",
					"Use a stack to store the current direction and position",
					"Modify the matrix to store both the current number and direction"
				],
				"explanation": "Using a single pointer to track the current position and direction would allow the algorithm to work in-place. By maintaining a direction vector and updating the position based on the current direction, the matrix can be filled without additional data structures.",
				"answer": "a",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "Which of the following is a correct approach to handle the edge case when n = 1 for generating a spiral matrix?",
				"options": [
					"Initialize the matrix with a single element and return it",
					"Skip the spiral logic and directly return [[1]]",
					"Use a special case check to handle n = 1 separately",
					"All of the above"
				],
				"explanation": "All of the above options are correct approaches. When n = 1, the matrix is simply [[1]], and this can be handled by initializing the matrix with a single element, skipping the spiral logic, or using a special case check.",
				"answer": "d",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "Consider the following code for generating a spiral matrix. Which line should be modified to ensure the matrix is filled correctly when n is even?\n```python\n1. def generateMatrix(n):\n2.     matrix = [[0] * n for _ in range(n)]\n3.     left, right, top, bottom = 0, n-1, 0, n-1\n4.     num = 1\n5.     while left <= right and top <= bottom:\n6.         for i in range(left, right + 1):\n7.             matrix[top][i] = num\n8.             num += 1\n9.         top += 1\n10.        for i in range(top, bottom + 1):\n11.            matrix[i][right] = num\n12.            num += 1\n13.        right -= 1\n14.        for i in range(right, left - 1, -1):\n15.            matrix[bottom][i] = num\n16.            num += 1\n17.        bottom -= 1\n18.        for i in range(bottom, top - 1, -1):\n19.            matrix[i][left] = num\n20.            num += 1\n21.        left += 1\n22.    return matrix\n```",
				"options": [
					"Line 5: while left <= right and top <= bottom",
					"Line 3: left, right, top, bottom = 0, n-1, 0, n-1",
					"Line 6: for i in range(left, right + 1)",
					"Line 18: for i in range(bottom, top - 1, -1)"
				],
				"explanation": "The code is already correct for both even and odd n. However, if there were an issue, it would likely be in the condition of the while loop (Line 5), which ensures that the loop continues until all layers are filled. The current condition is correct, but this is a common place to check for off-by-one errors.",
				"answer": "a",
				"topics": ["Array", "Matrix"]
			}
		]
	},
	{
		"slug": "permutation-sequence",
		"title": "Permutation Sequence",
		"leetcodeUrl": "https://leetcode.com/problems/permutation-sequence",
		"difficulty": "Medium",
		"topics": ["Math", "Backtracking"],
		"content": "The set `[1,2,3,..., n]` contains a total of `n!` unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for `n=3`:\n\n    \"123\"\n    \"132\"\n    \"213\"\n    \"231\"\n    \"312\"\n    \"321\"\n\nGiven `n` and `k`, return the `k`th permutation sequence.\n\n**Example 1:**\n```\nInput: n = 3, k = 3\nOutput: \"213\"\n```\n\n**Example 2:**\n```\nInput: n = 4, k = 9\nOutput: \"2314\"\n```\n\n**Example 3:**\n```\nInput: n = 3, k = 1\nOutput: \"123\"\n```\n\n**Constraints:**\n- `1 <= n <= 9`\n- `1 <= k <= n!`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following statements is true about the time complexity of generating the k-th permutation sequence directly without generating all permutations?",
				"options": [
					"a) The time complexity is O(n!) because it involves generating all permutations.",
					"b) The time complexity is O(n^2) because it involves calculating factorials and iterating through the sequence.",
					"c) The time complexity is O(n) because it involves a single pass through the sequence.",
					"d) The time complexity is O(n log n) because it involves sorting the sequence."
				],
				"explanation": "The correct approach to find the k-th permutation directly involves calculating factorials to determine the position of each digit in the sequence. This requires iterating through the sequence once, making the time complexity O(n^2) due to the factorial calculations and the iteration through the sequence to build the permutation.",
				"answer": "b",
				"topics": ["Math", "Backtracking"]
			},
			{
				"question": "Given the following code snippet for finding the k-th permutation sequence, which line contains a bug?\n```python\n1. def getPermutation(n, k):\n2.     nums = list(range(1, n+1))\n3.     k -= 1\n4.     factorial = [1] * n\n5.     for i in range(1, n):\n6.         factorial[i] = factorial[i-1] * i\n7.     result = ''\n8.     for i in range(n, 0, -1):\n9.         idx = k // factorial[i-1]\n10.        result += str(nums[idx])\n11.        nums.pop(idx)\n12.        k %= factorial[i-1]\n13.    return result\n```\nWhich line contains the bug and why?",
				"options": [
					"a) Line 3: k -= 1, because it incorrectly adjusts k for zero-based indexing.",
					"b) Line 6: factorial[i] = factorial[i-1] * i, because it incorrectly calculates factorial values.",
					"c) Line 10: result += str(nums[idx]), because it incorrectly appends the number to the result.",
					"d) Line 11: nums.pop(idx), because it incorrectly removes the number from the list."
				],
				"explanation": "The bug is in Line 3: k -= 1. This line is actually correct because it adjusts k for zero-based indexing, which is necessary for the algorithm to work correctly. The other lines are correctly implemented for the purpose of finding the k-th permutation.",
				"answer": "a",
				"topics": ["Math", "Backtracking"]
			},
			{
				"question": "In the context of finding the k-th permutation sequence, which of the following optimizations can reduce the space complexity of the solution?",
				"options": [
					"a) Use a linked list instead of an array to store the numbers.",
					"b) Precompute all permutations and store them in a list.",
					"c) Use a single integer to represent the factorial values instead of an array.",
					"d) Use a recursive approach to generate permutations on-the-fly."
				],
				"explanation": "Using a single integer to represent the factorial values instead of an array can reduce the space complexity. The factorial values are only needed one at a time, so storing them in an array is unnecessary. This optimization reduces the space complexity from O(n) to O(1).",
				"answer": "c",
				"topics": ["Math", "Backtracking"]
			},
			{
				"question": "Which of the following is a correct approach to find the k-th permutation sequence of numbers 1 to n?",
				"options": [
					"a) Generate all permutations and return the k-th one.",
					"b) Use a backtracking approach to generate permutations until the k-th one is found.",
					"c) Calculate the position of each digit using factorials and construct the permutation directly.",
					"d) Use dynamic programming to store and retrieve permutations efficiently."
				],
				"explanation": "The correct approach is to calculate the position of each digit using factorials and construct the permutation directly. This method leverages the properties of permutations and factorials to efficiently determine the k-th permutation without generating all permutations.",
				"answer": "c",
				"topics": ["Math", "Backtracking"]
			}
		]
	},
	{
		"slug": "rotate-list",
		"title": "Rotate List",
		"leetcodeUrl": "https://leetcode.com/problems/rotate-list",
		"difficulty": "Medium",
		"topics": ["Linked List"],
		"content": "Given the head of a linked list, rotate the list to the right by `k` places.\n\n**Example 1:**\n```\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n```\n\n**Example 2:**\n```\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n```\n\n**Constraints:**\n- The number of nodes in the list is in the range `[0,500]`.\n- `-100 <= Node.val <= 100`\n- `0 <= k <= 2 * 10^9`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the optimal solution for rotating a linked list to the right by k places?",
				"options": ["O(n)", "O(n^2)", "O(k)", "O(1)"],
				"explanation": "The optimal solution involves first finding the length of the list, which takes O(n) time. Then, the list is made circular and broken at the correct position, which also takes O(n) time. Therefore, the overall time complexity is O(n).",
				"answer": "a",
				"topics": ["Linked List", "Complexity Analysis"]
			},
			{
				"question": "Given the following implementation of rotating a linked list, which line contains a bug?\n```python\n1. def rotateRight(head, k):\n2.     if not head or not head.next or k == 0:\n3.         return head\n4.     # Find the length of the list\n5.     length = 1\n6.     current = head\n7.     while current.next:\n8.         current = current.next\n9.         length += 1\n10.    # Make the list circular\n11.    current.next = head\n12.    # Find the new head position\n13.    k = k % length\n14.    steps_to_new_head = length - k\n15.    new_tail = head\n16.    for _ in range(steps_to_new_head - 1):\n17.        new_tail = new_tail.next\n18.    new_head = new_tail.next\n19.    new_tail.next = None\n20.    return new_head\n```",
				"options": [
					"Line 2: if not head or not head.next or k == 0:",
					"Line 11: current.next = head",
					"Line 13: k = k % length",
					"Line 19: new_tail.next = None"
				],
				"explanation": "The bug is in Line 13: k = k % length. This line is correct and necessary to handle cases where k is greater than the length of the list. The actual bug is not present in the given code; the code is correct. However, if there were a bug, it would likely be in handling edge cases like k being a multiple of the list length.",
				"answer": "c",
				"topics": ["Linked List", "Implementation Analysis"]
			},
			{
				"question": "In the context of rotating a linked list, which of the following statements is true about the space complexity of the optimal solution?",
				"options": [
					"The space complexity is O(n) due to the use of additional data structures.",
					"The space complexity is O(1) because no additional data structures are used.",
					"The space complexity is O(k) because of the recursive calls.",
					"The space complexity is O(log n) due to the stack space used."
				],
				"explanation": "The space complexity of the optimal solution is O(1) because the rotation is done in place without using any additional data structures. The list is modified by changing pointers, which does not require extra space.",
				"answer": "b",
				"topics": ["Linked List", "Space Complexity"]
			},
			{
				"question": "Consider the following scenario: You have a linked list of 500 nodes, and you need to rotate it by 1 billion places. Which of the following statements is true about the number of rotations actually needed?",
				"options": [
					"You need to perform 1 billion rotations.",
					"You need to perform 500 rotations.",
					"You need to perform 0 rotations because 1 billion is a multiple of 500.",
					"You need to perform 1 billion % 500 rotations."
				],
				"explanation": "Since rotating a list by its length results in the same list, you only need to perform rotations equivalent to 1 billion % 500, which is 0. Therefore, no rotations are needed.",
				"answer": "c",
				"topics": ["Linked List", "Modular Arithmetic"]
			},
			{
				"question": "Which of the following modifications would optimize the given solution for rotating a linked list to handle very large values of k efficiently?",
				"options": [
					"Use a hash map to store node positions.",
					"Use a stack to reverse the list first.",
					"Calculate k % length to reduce unnecessary rotations.",
					"Convert the list to an array for faster access."
				],
				"explanation": "Calculating k % length reduces the number of rotations needed by taking advantage of the fact that rotating a list by its length results in the same list. This optimization is crucial for handling very large values of k efficiently.",
				"answer": "c",
				"topics": ["Linked List", "Optimization"]
			}
		]
	},
	{
		"slug": "unique-paths",
		"title": "Unique Paths",
		"leetcodeUrl": "https://leetcode.com/problems/unique-paths",
		"difficulty": "Medium",
		"topics": ["Dynamic Programming", "Math"],
		"content": "There is a robot on an `m x n` grid. The robot is initially located at the top-left corner (i.e., `grid[0][0]`). The robot tries to move to the bottom-right corner (i.e., `grid[m-1][n-1]`). The robot can only move either down or right at any point in time. Given the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\nThe test cases are generated such that the answer will be less than or equal to `2 * 10^9`.\n\n**Constraints:**\n- `1 <= m, n <= 100`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is the correct time complexity for a dynamic programming solution to the Unique Paths problem, where m and n are the dimensions of the grid?",
				"options": ["O(m * n)", "O(m + n)", "O(m^2 * n^2)", "O(2^m * 2^n)"],
				"explanation": "The dynamic programming solution involves filling up a 2D table of size m x n, where each cell represents the number of unique paths to that cell. This requires iterating over each cell once, leading to a time complexity of O(m * n).",
				"answer": "a",
				"topics": ["Dynamic Programming", "Complexity Analysis"]
			},
			{
				"question": "Given the following dynamic programming solution for the Unique Paths problem, which line contains a bug?\n```python\n1. def uniquePaths(m, n):\n2.     dp = [[0] * n for _ in range(m)]\n3.     for i in range(m):\n4.         for j in range(n):\n5.             if i == 0 or j == 0:\n6.                 dp[i][j] = 1\n7.             else:\n8.                 dp[i][j] = dp[i-1][j] + dp[i][j-1]\n9.     return dp[m-1][n-1]\n```\nWhy does it still pass many test cases?",
				"options": [
					"Line 2: Initialization of dp array with zeros",
					"Line 5: Incorrect condition for setting initial paths",
					"Line 6: Incorrect assignment of initial paths",
					"Line 8: Incorrect calculation of paths from previous cells"
				],
				"explanation": "The bug is in Line 5. The condition should be 'if i == 0 and j == 0' to correctly initialize the starting point. However, the current condition still works because it sets the first row and first column to 1, which is correct for the problem's constraints.",
				"answer": "b",
				"topics": ["Dynamic Programming", "Implementation Analysis"]
			},
			{
				"question": "In the context of the Unique Paths problem, which of the following optimizations can reduce the space complexity from O(m * n) to O(n)?",
				"options": [
					"Use a single array of size n to store the current row's path counts",
					"Use a single array of size m to store the current column's path counts",
					"Use a 2D array but only update the diagonal elements",
					"Use a recursive approach with memoization"
				],
				"explanation": "By using a single array of size n, you can iteratively update the path counts for each row, reusing the array for each subsequent row. This reduces the space complexity from O(m * n) to O(n) because you only need to store the current row's path counts at any time.",
				"answer": "a",
				"topics": ["Dynamic Programming", "Space Optimization"]
			},
			{
				"question": "Consider the following recursive solution with memoization for the Unique Paths problem:\n```python\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef uniquePaths(m, n):\n    if m == 1 or n == 1:\n        return 1\n    return uniquePaths(m-1, n) + uniquePaths(m, n-1)\n```\nWhat is the time complexity of this solution?",
				"options": ["O(m * n)", "O(2^m * 2^n)", "O(m + n)", "O(m^2 * n^2)"],
				"explanation": "The memoization ensures that each unique subproblem is solved only once, leading to a time complexity of O(m * n). Without memoization, the time complexity would be exponential, but memoization reduces it to polynomial time by storing results of subproblems.",
				"answer": "a",
				"topics": ["Dynamic Programming", "Recursion", "Complexity Analysis"]
			},
			{
				"question": "Which of the following statements is true about the Unique Paths problem when using a combinatorial approach?",
				"options": [
					"The number of unique paths is given by the binomial coefficient C(m+n-2, m-1)",
					"The number of unique paths is given by the binomial coefficient C(m+n-2, n-1)",
					"The number of unique paths is given by the factorial of m+n-2",
					"The number of unique paths is given by the sum of factorials of m and n"
				],
				"explanation": "The combinatorial approach calculates the number of unique paths as the number of ways to choose (m-1) down moves from a total of (m+n-2) moves, which is given by the binomial coefficient C(m+n-2, m-1). This is equivalent to choosing (n-1) right moves, hence C(m+n-2, n-1) is also correct.",
				"answer": "b",
				"topics": ["Math", "Combinatorics"]
			}
		]
	},
	{
		"slug": "unique-paths-ii",
		"title": "Unique Paths II",
		"leetcodeUrl": "https://leetcode.com/problems/unique-paths-ii",
		"difficulty": "Medium",
		"topics": ["Dynamic Programming", "Backtracking"],
		"content": "You are given an `m x n` integer array `grid`. There is a robot initially located at the top-left corner (i.e., `grid[0][0]`). The robot tries to move to the bottom-right corner (i.e., `grid[m-1][n-1]`). The robot can only move either down or right at any point in time. An obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include any square that is an obstacle. Return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\n**Constraints:**\n- `m == obstacleGrid.length`\n- `n == obstacleGrid[i].length`\n- `1 <= m, n <= 100`\n- `obstacleGrid[i][j]` is `0` or `1`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following statements is true about the time complexity of a dynamic programming solution for the 'Unique Paths II' problem?",
				"options": [
					"The time complexity is O(m * n) because we iterate over each cell once.",
					"The time complexity is O(m + n) because we only need to consider the boundary cells.",
					"The time complexity is O(m^2 * n^2) because we need to check all possible paths.",
					"The time complexity is O(1) because we only need to check the start and end cells."
				],
				"explanation": "The dynamic programming solution involves filling a 2D table where each cell represents the number of ways to reach that cell. We iterate over each cell in the grid once, leading to a time complexity of O(m * n).",
				"answer": "a",
				"topics": ["Dynamic Programming", "Complexity Analysis"]
			},
			{
				"question": "Given the following code snippet for solving 'Unique Paths II', which line contains a bug?\n```python\n1. def uniquePathsWithObstacles(grid):\n2.     if not grid or grid[0][0] == 1:\n3.         return 0\n4.     m, n = len(grid), len(grid[0])\n5.     dp = [[0] * n for _ in range(m)]\n6.     dp[0][0] = 1\n7.     for i in range(m):\n8.         for j in range(n):\n9.             if grid[i][j] == 1:\n10.                dp[i][j] = 0\n11.            else:\n12.                if i > 0:\n13.                    dp[i][j] += dp[i-1][j]\n14.                if j > 0:\n15.                    dp[i][j] += dp[i][j-1]\n16.    return dp[m-1][n-1]\n```",
				"options": [
					"Line 2: The check for grid[0][0] should be after initializing dp.",
					"Line 5: The dp array should be initialized with 1s instead of 0s.",
					"Line 10: The assignment should be dp[i][j] = 1 instead of 0.",
					"Line 6: The initial value should be set to 0 if grid[0][0] is 1."
				],
				"explanation": "The bug is in Line 6. The initial value of dp[0][0] should be set to 0 if grid[0][0] is 1, as the robot cannot start on an obstacle. The check in Line 2 is correct, but the initialization should reflect the obstacle condition.",
				"answer": "d",
				"topics": ["Dynamic Programming", "Implementation Analysis"]
			},
			{
				"question": "In the 'Unique Paths II' problem, which of the following modifications would optimize the space complexity of the dynamic programming solution?",
				"options": [
					"Use a 1D array instead of a 2D array to store the number of paths.",
					"Store only the last row of the dp table to reduce space usage.",
					"Use a hash map to store only non-zero values of the dp table.",
					"Iterate over the grid in reverse order to avoid using extra space."
				],
				"explanation": "Using a 1D array instead of a 2D array can optimize the space complexity from O(m * n) to O(n) by updating the array in place as we iterate through the grid. This works because each cell only depends on the current and previous row values.",
				"answer": "a",
				"topics": ["Dynamic Programming", "Space Optimization"]
			},
			{
				"question": "Consider the following scenario: The grid is a 3x3 matrix with obstacles at positions (1,1) and (2,0). How many unique paths exist from the top-left to the bottom-right corner?",
				"options": ["0", "1", "2", "3"],
				"explanation": "The grid looks like this:\n```\n0 0 0\n0 1 0\n1 0 0\n```\nThe robot can only move right or down. The only path is: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2). Thus, there is only 1 unique path.",
				"answer": "b",
				"topics": ["Dynamic Programming", "Path Counting"]
			},
			{
				"question": "Which of the following is a valid edge case to consider when implementing a solution for the 'Unique Paths II' problem?",
				"options": [
					"The grid is a single cell with an obstacle.",
					"The grid is a single row with no obstacles.",
					"The grid is a single column with all cells as obstacles.",
					"The grid is a 2x2 matrix with no obstacles."
				],
				"explanation": "A valid edge case is when the grid is a single cell with an obstacle. In this case, the robot cannot start, and the number of unique paths should be 0. This tests the initial condition handling in the implementation.",
				"answer": "a",
				"topics": ["Dynamic Programming", "Edge Cases"]
			},
			{
				"question": "Analyze the space complexity of the following recursive solution with memoization for the 'Unique Paths II' problem:\n```python\n@lru_cache(None)\ndef uniquePaths(i, j, grid):\n    if i < 0 or j < 0 or grid[i][j] == 1:\n        return 0\n    if i == 0 and j == 0:\n        return 1\n    return uniquePaths(i-1, j, grid) + uniquePaths(i, j-1, grid)\n```\nWhat is the space complexity?",
				"options": [
					"O(m * n) due to the memoization cache storing results for each cell.",
					"O(m + n) because the recursion stack grows linearly with the grid dimensions.",
					"O(1) because the cache optimizes space usage.",
					"O(m^2 * n^2) because each recursive call creates a new stack frame."
				],
				"explanation": "The space complexity is O(m * n) due to the memoization cache storing results for each cell in the grid. The recursion stack itself can grow to O(m + n) in the worst case, but the cache dominates the space usage.",
				"answer": "a",
				"topics": ["Dynamic Programming", "Recursion", "Space Complexity"]
			}
		]
	},
	{
		"slug": "minimum-path-sum",
		"title": "Minimum Path Sum",
		"leetcodeUrl": "https://leetcode.com/problems/minimum-path-sum",
		"difficulty": "Medium",
		"topics": ["Dynamic Programming", "Matrix"],
		"content": "Given an `m x n` grid filled with non-negative numbers, find a path from the top left to the bottom right, which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\n**Example 1:**\n```\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.\n```\n\n**Example 2:**\n```\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n```\n\n**Constraints:**\n- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m,n <= 200`\n- `0 <= grid[i][j] <= 200`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of a dynamic programming solution to the Minimum Path Sum problem, where the grid is of size m x n?",
				"options": ["O(m + n)", "O(m * n)", "O(m^2 * n^2)", "O(log(m * n))"],
				"explanation": "The dynamic programming solution involves filling up a 2D table where each cell is computed based on the values of its top and left neighbors. This requires iterating over each cell in the m x n grid exactly once, leading to a time complexity of O(m * n).",
				"answer": "b",
				"topics": ["Dynamic Programming", "Matrix"]
			},
			{
				"question": "Given the following code snippet for solving the Minimum Path Sum problem, which line contains a bug?\n```python\n1. def minPathSum(grid):\n2.     if not grid or not grid[0]:\n3.         return 0\n4.     m, n = len(grid), len(grid[0])\n5.     dp = [[0] * n for _ in range(m)]\n6.     dp[0][0] = grid[0][0]\n7.     for i in range(1, m):\n8.         dp[i][0] = dp[i-1][0] + grid[i][0]\n9.     for j in range(1, n):\n10.        dp[0][j] = dp[0][j-1] + grid[0][j]\n11.    for i in range(1, m):\n12.        for j in range(1, n):\n13.            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n14.    return dp[m-1][n-1]\n```",
				"options": [
					"Line 5: Initialization of dp array",
					"Line 8: Filling first column of dp",
					"Line 10: Filling first row of dp",
					"Line 13: Calculating minimum path sum for each cell"
				],
				"explanation": "The code correctly initializes and fills the dp array. However, the bug is in line 13, where the minimum path sum is calculated. The logic is correct, but the bug is subtle and not present in this snippet. The code is actually correct, and the question is a trick to ensure understanding of the logic.",
				"answer": "d",
				"topics": ["Dynamic Programming", "Matrix"]
			},
			{
				"question": "In the Minimum Path Sum problem, if the grid is a single row or a single column, what is the optimal approach to solve it?",
				"options": [
					"Use a recursive approach with memoization",
					"Use a greedy approach to select minimum values",
					"Iterate through the row or column and sum the values",
					"Use a divide and conquer approach"
				],
				"explanation": "If the grid is a single row or a single column, the optimal approach is to simply iterate through the row or column and sum the values, as there is only one possible path from start to end.",
				"answer": "c",
				"topics": ["Dynamic Programming", "Matrix"]
			},
			{
				"question": "Consider a grid where all elements are the same value. Which of the following statements is true about the Minimum Path Sum?",
				"options": [
					"The path sum is always the product of the value and the number of steps in the path.",
					"The path sum is the value multiplied by the number of rows.",
					"The path sum is the value multiplied by the number of columns.",
					"The path sum is the value multiplied by the sum of rows and columns minus one."
				],
				"explanation": "In a grid where all elements are the same, the minimum path sum is the value multiplied by the number of steps in the path. The number of steps is the sum of rows and columns minus one, as you need to move m-1 times down and n-1 times right to reach the bottom-right corner.",
				"answer": "d",
				"topics": ["Dynamic Programming", "Matrix"]
			},
			{
				"question": "Which of the following modifications would allow the Minimum Path Sum algorithm to work in-place, reducing space complexity?",
				"options": [
					"Use a single row array to store intermediate results",
					"Use a single column array to store intermediate results",
					"Modify the input grid to store the path sums directly",
					"Use a stack to keep track of the path sums"
				],
				"explanation": "To reduce space complexity, you can modify the input grid to store the path sums directly. This way, you don't need an additional dp array, and the space complexity is reduced to O(1) beyond the input grid.",
				"answer": "c",
				"topics": ["Dynamic Programming", "Matrix"]
			}
		]
	},
	{
		"slug": "valid-number",
		"title": "Valid Number",
		"leetcodeUrl": "https://leetcode.com/problems/valid-number",
		"difficulty": "Medium",
		"topics": ["String"],
		"content": "A valid number can be split up into these components (in order):\n\n- A decimal number or an integer.\n- (Optional) An `e` or `E`, followed by an integer.\n\nA decimal number can be split up into these components (in order):\n\n- (Optional) A sign character (either `+` or `-`).\n- One of the following formats:\n  - One or more digits, followed by a dot `.`.\n  - One or more digits, followed by a dot `.`, followed by one or more digits.\n  - A dot `.`, followed by one or more digits.\n\nAn integer can be split up into these components (in order):\n\n- (Optional) A sign character (either `+` or `-`).\n- One or more digits.\n\nFor example, all the following are valid numbers: [\"2\",\"0089\",\"-0.1\",\"+3.14\",\"4.\",\"-.9\",\"2e10\",\"-90E3\",\"3e+7\",\"+6e-1\",\"53.5e93\",\"-123.456e789\"], while the following are not valid numbers: [\"abc\",\"1a\",\"1e\",\"e3\",\"99e2.5\",\"--6\",\"-+3\",\"95a54e53\"].\n\nGiven a string `s`, return `true` if `s` is a valid number.\n\n**Example 1:**\n```\nInput: s = \"0\"\nOutput: true\n```\n\n**Example 2:**\n```\nInput: s = \"e\"\nOutput: false\n```\n\n**Example 3:**\n```\nInput: s = \".\"\nOutput: false\n```\n\n**Constraints:**\n- `1 <= s.length <= 20`\n- `s` consists of only English letters (both uppercase and lowercase), digits (0-9), plus `+`, minus `-`, or dot `.`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a valid number according to the problem statement?",
				"options": ["+3.14e-10", "-e3", "99e2.5", "1e"],
				"explanation": "The string '+3.14e-10' is a valid number because it follows the format of a decimal number with an optional sign, followed by an 'e' and an integer. The other options either have incorrect placement of 'e' or invalid characters following 'e'.",
				"answer": "a",
				"topics": ["String"]
			},
			{
				"question": "Given the following code snippet for checking if a string is a valid number, which line contains a bug?\n```python\nimport re\n\ndef isNumber(s: str) -> bool:\n    pattern = r'^[+-]?((\\d+\\.?\\d*)|(\\.\\d+))([eE][+-]?\\d+)?$'\n    return re.match(pattern, s) is not None\n```\nWhich line contains the bug and why?",
				"options": [
					"Line 3: The pattern does not correctly handle cases with only a dot.",
					"Line 4: The pattern should not use `re.match` but `re.fullmatch`.",
					"Line 5: The pattern does not allow for numbers like '4.'",
					"Line 6: The pattern incorrectly allows multiple signs."
				],
				"explanation": "The bug is in Line 4. The `re.match` function checks for a match only at the beginning of the string, but we need to ensure the entire string matches the pattern. Using `re.fullmatch` ensures the whole string is validated against the pattern.",
				"answer": "b",
				"topics": ["String", "Regular Expressions"]
			},
			{
				"question": "Consider the following code for validating a number:\n```python\nimport re\n\ndef isNumber(s: str) -> bool:\n    pattern = r'^[+-]?((\\d+\\.?\\d*)|(\\.\\d+))([eE][+-]?\\d+)?$'\n    return re.fullmatch(pattern, s) is not None\n```\nWhat is the time complexity of this solution?",
				"options": [
					"O(n), where n is the length of the string",
					"O(1), because regular expressions are constant time",
					"O(n^2), due to backtracking in regex",
					"O(log n), because of the logarithmic nature of regex parsing"
				],
				"explanation": "The time complexity of this solution is O(n), where n is the length of the string. Regular expression matching generally operates in linear time relative to the input size, though specific patterns can cause backtracking and worse performance in some cases. However, this pattern is straightforward and should operate in linear time.",
				"answer": "a",
				"topics": ["String", "Regular Expressions", "Complexity Analysis"]
			},
			{
				"question": "In the context of validating a number, which of the following modifications would optimize the given regex-based solution to handle edge cases more efficiently?",
				"options": [
					"Use a DFA-based approach instead of regex",
					"Add more capturing groups to the regex",
					"Use a non-capturing group for optional sign",
					"Replace regex with a simple loop-based parser"
				],
				"explanation": "Using a DFA-based approach instead of regex can optimize the solution by explicitly handling each character and state transition, which can be more efficient and easier to debug for complex patterns like number validation. This avoids potential pitfalls of regex backtracking and provides more control over the parsing process.",
				"answer": "a",
				"topics": ["String", "Regular Expressions", "Optimization"]
			},
			{
				"question": "Which of the following input characteristics would make a DFA-based solution for number validation perform better than a regex-based solution?",
				"options": [
					"Very long strings with complex patterns",
					"Short strings with simple patterns",
					"Strings with many invalid characters",
					"Strings with nested patterns"
				],
				"explanation": "A DFA-based solution performs better with very long strings with complex patterns because it processes each character in a single pass without backtracking, unlike regex which can suffer from performance issues due to backtracking in complex patterns.",
				"answer": "a",
				"topics": ["String", "Finite Automata", "Optimization"]
			}
		]
	},
	{
		"slug": "plus-one",
		"title": "Plus One",
		"leetcodeUrl": "https://leetcode.com/problems/plus-one",
		"difficulty": "Easy",
		"topics": ["Array"],
		"content": "You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`s. Increment the large integer by one and return the resulting array of digits.\n\n**Example 1:**\n```\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124. Thus, the result should be [1,2,4].\n```\n\n**Example 2:**\n```\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321. Incrementing by one gives 4321 + 1 = 4322. Thus, the result should be [4,3,2,2].\n```\n\n**Example 3:**\n```\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9. Incrementing by one gives 9 + 1 = 10. Thus, the result should be [1,0].\n```\n\n**Constraints:**\n- `1 <= digits.length <= 100`\n- `0 <= digits[i] <= 9`\n- `digits` does not contain any leading `0`s.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of the naive solution to the \"Plus One\" problem, where you iterate from the last digit to the first, handling carry as needed?",
				"options": ["O(n)", "O(log n)", "O(n^2)", "O(1)"],
				"explanation": "The naive solution involves iterating over the digits array from the last element to the first, potentially modifying each digit if there is a carry. This results in a time complexity of O(n), where n is the number of digits in the array.",
				"answer": "a",
				"topics": ["Array", "Time Complexity"]
			},
			{
				"question": "Given the following implementation of the \"Plus One\" problem, which line contains a bug?\n```python\n1. def plusOne(digits):\n2.     n = len(digits)\n3.     for i in range(n-1, -1, -1):\n4.         if digits[i] < 9:\n5.             digits[i] += 1\n6.             return digits\n7.         digits[i] = 0\n8.     return [1] + digits\n```\nWhy does it still pass many test cases?",
				"options": [
					"Line 5: digits[i] += 1, because it doesn't handle carry correctly",
					"Line 6: return digits, because it returns too early",
					"Line 7: digits[i] = 0, because it doesn't account for all digits being 9",
					"Line 8: return [1] + digits, because it assumes a carry is always needed"
				],
				"explanation": "The implementation is correct. The code handles the carry by setting digits[i] to 0 and continues the loop. If all digits are 9, it exits the loop and returns [1] + digits, which correctly handles the carry over. Thus, there is no bug in the code.",
				"answer": "b",
				"topics": ["Array", "Implementation Analysis"]
			},
			{
				"question": "In the \"Plus One\" problem, if the input is [9,9,9], what is the expected output?",
				"options": ["[1,0,0,0]", "[9,9,10]", "[0,0,0]", "[1,0,0]"],
				"explanation": "When the input is [9,9,9], incrementing by one results in a carry over for each digit, leading to [1,0,0,0]. This is because each 9 becomes 0 and a carry is added to the next more significant digit.",
				"answer": "a",
				"topics": ["Array", "Edge Cases"]
			},
			{
				"question": "Consider the following code snippet for the \"Plus One\" problem:\n```python\n1. def plusOne(digits):\n2.     carry = 1\n3.     for i in range(len(digits)-1, -1, -1):\n4.         new_digit = digits[i] + carry\n5.         digits[i] = new_digit % 10\n6.         carry = new_digit // 10\n7.     if carry:\n8.         digits.insert(0, carry)\n9.     return digits\n```\nWhat is the space complexity of this solution?",
				"options": ["O(1)", "O(n)", "O(log n)", "O(n^2)"],
				"explanation": "The space complexity of this solution is O(1) because it modifies the input list in place and only uses a constant amount of extra space for the carry variable. The insertion at the beginning of the list is an in-place operation.",
				"answer": "a",
				"topics": ["Array", "Space Complexity"]
			},
			{
				"question": "Which of the following scenarios would require the most significant change in the \"Plus One\" algorithm's output?",
				"options": [
					"The input array is [0]",
					"The input array is [1,2,3]",
					"The input array is [9,9,9]",
					"The input array is [4,5,6]"
				],
				"explanation": "The input array [9,9,9] would require the most significant change because incrementing it results in a carry that affects all digits, changing the output to [1,0,0,0]. Other inputs like [1,2,3] or [4,5,6] only change the last digit, and [0] changes to [1].",
				"answer": "c",
				"topics": ["Array", "Edge Cases"]
			},
			{
				"question": "In the \"Plus One\" problem, what is the primary reason for iterating from the last digit to the first?",
				"options": [
					"To handle the least significant digit first",
					"To avoid modifying the input array",
					"To ensure the most significant digit is handled last",
					"To minimize the number of operations"
				],
				"explanation": "Iterating from the last digit to the first allows the algorithm to handle the least significant digit first, which is where the increment and potential carry would initially occur. This ensures that any carry is correctly propagated to more significant digits.",
				"answer": "a",
				"topics": ["Array", "Algorithm Design"]
			}
		]
	},
	{
		"slug": "add-binary",
		"title": "Add Binary",
		"leetcodeUrl": "https://leetcode.com/problems/add-binary",
		"difficulty": "Easy",
		"topics": ["String"],
		"content": "Given two binary strings `a` and `b`, return their sum as a binary string.\n\n**Example 1:**\n```\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\n```\n\n**Example 2:**\n```\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\n```\n\n**Constraints:**\n- `1 <= a.length, b.length <= 10^4`\n- Both `a` and `b` consist only of '0' or '1' characters.\n- Each string does not contain leading zeros except for the zero itself.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of the algorithm to add two binary strings of length n?",
				"options": ["O(n)", "O(n^2)", "O(log n)", "O(1)"],
				"explanation": "The time complexity is O(n) because we iterate through each character of the binary strings once to compute the sum, handling carries as we go.",
				"answer": "a",
				"topics": ["String", "Time Complexity"]
			},
			{
				"question": "Given the following implementation of adding two binary strings, which line contains a bug?\n```python\n1. def addBinary(a, b):\n2.     max_len = max(len(a), len(b))\n3.     a = a.zfill(max_len)\n4.     b = b.zfill(max_len)\n5.     result = []\n6.     carry = 0\n7.     for i in range(max_len - 1, -1, -1):\n8.         total = carry\n9.         total += int(a[i]) + int(b[i])\n10.        result.append(str(total % 2))\n11.        carry = total // 2\n12.    if carry:\n13.        result.append('1')\n14.    return ''.join(reversed(result))\n```\nWhich line contains the bug and why?",
				"options": [
					"Line 3: a = a.zfill(max_len)",
					"Line 9: total += int(a[i]) + int(b[i])",
					"Line 10: result.append(str(total % 2))",
					"Line 14: return ''.join(reversed(result))"
				],
				"explanation": "The implementation is correct. The bug is a trick question; there is no bug in the provided code. It correctly handles binary addition with carry and returns the result in the correct order.",
				"answer": "d",
				"topics": ["String", "Implementation Analysis"]
			},
			{
				"question": "In the context of adding two binary strings, which data structure is most appropriate for storing intermediate results and why?",
				"options": [
					"List, because it allows appending and reversing efficiently",
					"Stack, because it naturally handles LIFO operations",
					"Queue, because it processes elements in FIFO order",
					"Set, because it ensures unique elements"
				],
				"explanation": "A list is most appropriate because it allows appending elements efficiently and can be reversed at the end to produce the final result. This is crucial for binary addition where we process from the least significant bit to the most significant bit.",
				"answer": "a",
				"topics": ["String", "Data Structures"]
			},
			{
				"question": "Consider the following code snippet for adding two binary strings:\n```python\n1. def addBinary(a, b):\n2.     max_len = max(len(a), len(b))\n3.     a = a.zfill(max_len)\n4.     b = b.zfill(max_len)\n5.     result = []\n6.     carry = 0\n7.     for i in range(max_len - 1, -1, -1):\n8.         total = carry\n9.         total += int(a[i]) + int(b[i])\n10.        result.append(str(total % 2))\n11.        carry = total // 2\n12.    if carry:\n13.        result.append('1')\n14.    return ''.join(reversed(result))\n```\nWhat is the space complexity of this implementation?",
				"options": [
					"O(n), due to the result list",
					"O(1), since no additional space is used",
					"O(n^2), due to the zfill operation",
					"O(log n), due to the carry operations"
				],
				"explanation": "The space complexity is O(n) because the result list stores the binary sum, which can be at most n+1 in length (including a possible carry). The zfill operation is O(n) as well, but it doesn't increase the overall space complexity beyond O(n).",
				"answer": "a",
				"topics": ["String", "Space Complexity"]
			}
		]
	},
	{
		"slug": "text-justification",
		"title": "Text Justification",
		"leetcodeUrl": "https://leetcode.com/problems/text-justification",
		"difficulty": "Medium",
		"topics": ["String", "Greedy"],
		"content": "Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `''` when necessary so that each line has exactly `maxWidth` characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left-justified, and no extra space is inserted between words.\n\nNote: A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than `0` and not exceed `maxWidth`. The input array `words` contains at least one word.\n\n**Example 1:**\n```\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput: [\n  \"This    is    an\",\n  \"example  of text\",\n  \"justification.  \"\n]\n```\n\n**Example 2:**\n```\nInput: words = [\"What\", \"must\", \"be\", \"acknowledgment\", \"shall\", \"be\"], maxWidth = 16\nOutput: [\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\n```\n\n**Example 3:**\n```\nInput: words = [\"Science\", \"is\", \"what\", \"we\", \"understand\", \"well\", \"enough\", \"to\", \"explain\", \"to\", \"a\", \"computer.\", \"Art\", \"is\", \"everything\", \"else\", \"we\", \"do\"], maxWidth = 20\nOutput: [\n  \"Science  is  what we\",\n  \"understand    well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\n```\n\n**Constraints:**\n- `1 <= words.length <= 300`\n- `1 <= words[i].length <= 20`\n- `words[i]` consist of only English letters and symbols.\n- `1 <= maxWidth <= 100`\n- `words[i].length <= maxWidth`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a core concept in the text justification problem?",
				"options": [
					"Greedy approach to pack words",
					"Dynamic programming to minimize space",
					"Backtracking to find optimal solution",
					"Divide and conquer to split words"
				],
				"explanation": "The text justification problem requires packing as many words as possible into each line while ensuring the line is fully justified. This is best achieved using a greedy approach, where words are added to a line until no more can fit, and then the line is justified before moving to the next line.",
				"answer": "a",
				"topics": ["String", "Greedy"]
			},
			{
				"question": "In the text justification problem, what is the primary challenge when implementing the solution?",
				"options": [
					"Ensuring each line has exactly maxWidth characters",
					"Handling words longer than maxWidth",
					"Distributing spaces evenly between words",
					"Sorting words before packing them"
				],
				"explanation": "The primary challenge in text justification is to ensure that each line has exactly maxWidth characters by distributing spaces evenly between words. This involves calculating the number of spaces needed and distributing them such that the leftmost slots get more spaces if they don't divide evenly.",
				"answer": "c",
				"topics": ["String", "Greedy"]
			},
			{
				"question": "Given the following partial implementation of the text justification problem, which line contains a bug?\n```python\n1. def fullJustify(words, maxWidth):\n2.     res, current, num_of_letters = [], [], 0\n3.     for word in words:\n4.         if num_of_letters + len(word) + len(current) > maxWidth:\n5.             for i in range(maxWidth - num_of_letters):\n6.                 current[i % (len(current) - 1 or 1)] += ' '\n7.             res.append(''.join(current))\n8.             current, num_of_letters = [], 0\n9.         current += [word]\n10.        num_of_letters += len(word)\n11.    return res + [' '.join(current).ljust(maxWidth)]\n```\nWhich line contains the bug and why?",
				"options": [
					"Line 4: Incorrect condition for adding a word",
					"Line 5: Incorrect loop range for adding spaces",
					"Line 6: Incorrect index calculation for space distribution",
					"Line 11: Incorrect handling of the last line"
				],
				"explanation": "Line 6 contains a subtle bug. The index calculation `i % (len(current) - 1 or 1)` is used to distribute spaces, but it can lead to incorrect space distribution when `len(current) == 1`. The condition should ensure that spaces are distributed correctly even when there's only one word in the line.",
				"answer": "c",
				"topics": ["String", "Greedy"]
			},
			{
				"question": "Consider the following solution for text justification. What is the time complexity of this solution?\n```python\n1. def fullJustify(words, maxWidth):\n2.     res, current, num_of_letters = [], [], 0\n3.     for word in words:\n4.         if num_of_letters + len(word) + len(current) > maxWidth:\n5.             for i in range(maxWidth - num_of_letters):\n6.                 current[i % (len(current) - 1 or 1)] += ' '\n7.             res.append(''.join(current))\n8.             current, num_of_letters = [], 0\n9.         current += [word]\n10.        num_of_letters += len(word)\n11.    return res + [' '.join(current).ljust(maxWidth)]\n```",
				"options": [
					"O(n * m), where n is the number of words and m is maxWidth",
					"O(n^2), due to nested loops",
					"O(n), as each word is processed once",
					"O(n * log n), due to sorting"
				],
				"explanation": "The time complexity of this solution is O(n * m), where n is the number of words and m is maxWidth. This is because for each word, the solution may need to distribute spaces up to maxWidth times, especially in the worst case where each line is nearly full.",
				"answer": "a",
				"topics": ["String", "Greedy"]
			},
			{
				"question": "In the text justification problem, which of the following modifications would optimize space usage while maintaining the same time complexity?",
				"options": [
					"Use a single list to store both words and spaces",
					"Replace the list of words with a string",
					"Use a deque instead of a list for current line",
					"Store spaces as a count instead of actual characters"
				],
				"explanation": "Storing spaces as a count instead of actual characters can optimize space usage. This way, you only need to calculate the number of spaces needed and apply them when joining the words, rather than storing each space character separately.",
				"answer": "d",
				"topics": ["String", "Greedy"]
			}
		]
	},
	{
		"slug": "sqrt-x",
		"title": "Sqrt(x)",
		"leetcodeUrl": "https://leetcode.com/problems/sqrt-x",
		"difficulty": "Easy",
		"topics": ["Math"],
		"content": "Given a non-negative integer `x`, return the square root of `x` rounded down to the nearest integer. The returned integer should be non-negative as well. You must not use any built-in exponent function or operator. For example, do not use `pow(x, 0.5)` in C++ or `x**0.5` in Python.\n\n**Example 1:**\n```\nInput: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.\n```\n\n**Example 2:**\n```\nInput: x = 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n```\n\n**Constraints:**\n- `0 <= x <= 2^31 - 1`.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of the binary search algorithm used to find the square root of a non-negative integer x?",
				"options": ["O(log x)", "O(x)", "O(sqrt(x))", "O(1)"],
				"explanation": "The binary search algorithm works by repeatedly dividing the search interval in half. Since the search space is reduced by half each time, the time complexity is O(log x).",
				"answer": "a",
				"topics": ["Math", "Binary Search"]
			},
			{
				"question": "Given the following implementation of the square root function, identify the bug:\n```python\n1. def mySqrt(x):\n2.     if x < 2:\n3.         return x\n4.     left, right = 2, x // 2\n5.     while left <= right:\n6.         mid = (left + right) // 2\n7.         num = mid * mid\n8.         if num > x:\n9.             right = mid - 1\n10.        elif num < x:\n11.            left = mid + 1\n12.        else:\n13.            return mid\n14.    return left\n```\nWhat is the issue with this code?",
				"options": [
					"The condition in line 5 should be 'left < right'.",
					"The return statement in line 14 should be 'return left - 1'.",
					"The initial value of 'right' in line 4 should be 'x'.",
					"The condition in line 8 should be 'num >= x'."
				],
				"explanation": "The bug is in the return statement on line 14. When the loop exits, 'left' is one more than the largest integer whose square is less than or equal to x. Therefore, the correct return statement should be 'return left - 1'.",
				"answer": "b",
				"topics": ["Math", "Binary Search", "Implementation Analysis"]
			},
			{
				"question": "Consider the following code snippet for finding the square root of a number using Newton's method:\n```python\n1. def newtonSqrt(x):\n2.     if x == 0:\n3.         return 0\n4.     guess = x\n5.     while True:\n6.         new_guess = (guess + x / guess) / 2\n7.         if abs(new_guess - guess) < 1e-7:\n8.             return int(new_guess)\n9.         guess = new_guess\n```\nWhat is the time complexity of this algorithm?",
				"options": ["O(log x)", "O(sqrt(x))", "O(log log x)", "O(1)"],
				"explanation": "Newton's method converges quadratically, meaning the number of correct digits approximately doubles with each iteration. This results in a time complexity of O(log log x) for finding the square root to a fixed precision.",
				"answer": "c",
				"topics": ["Math", "Newton's Method", "Complexity Analysis"]
			},
			{
				"question": "Which of the following data structures is most appropriate for implementing a priority queue?",
				"options": ["Array", "Linked List", "Binary Heap", "Hash Table"],
				"explanation": "A binary heap is the most appropriate data structure for implementing a priority queue because it allows for efficient insertion and extraction of the minimum or maximum element, with both operations having a time complexity of O(log n).",
				"answer": "c",
				"topics": ["Data Structures", "Priority Queue"]
			},
			{
				"question": "In the context of finding the square root of a number, which of the following methods is most efficient for very large numbers?",
				"options": [
					"Binary Search",
					"Newton's Method",
					"Exhaustive Search",
					"Recursive Division"
				],
				"explanation": "Newton's Method is most efficient for very large numbers due to its quadratic convergence, which allows it to quickly approximate the square root with high precision.",
				"answer": "b",
				"topics": ["Math", "Optimization"]
			},
			{
				"question": "Given the following recursive function to calculate the square root, what is the space complexity?\n```python\n1. def recursiveSqrt(x, guess=1):\n2.     if abs(guess * guess - x) < 1e-7:\n3.         return int(guess)\n4.     return recursiveSqrt(x, (guess + x / guess) / 2)\n```\n",
				"options": ["O(log x)", "O(1)", "O(n)", "O(log log x)"],
				"explanation": "The space complexity is O(log log x) because each recursive call reduces the error quadratically, leading to a logarithmic number of calls relative to the number of digits of precision required.",
				"answer": "d",
				"topics": ["Math", "Recursion", "Space Complexity"]
			}
		]
	},
	{
		"slug": "climbing-stairs",
		"title": "Climbing Stairs",
		"leetcodeUrl": "https://leetcode.com/problems/climbing-stairs",
		"difficulty": "Easy",
		"topics": ["Dynamic Programming", "Recursion"],
		"content": "You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n**Example 1:**\n```\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps\n```\n\n**Example 2:**\n```\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step\n```\n\n**Constraints:**\n- `1 <= n <= 45`",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of the dynamic programming solution to the Climbing Stairs problem, where you store the number of ways to reach each step in an array?",
				"options": ["O(n)", "O(n^2)", "O(log n)", "O(2^n)"],
				"explanation": "The dynamic programming solution involves iterating through the steps from 1 to n, calculating the number of ways to reach each step based on the previous two steps. This results in a linear time complexity of O(n) because each step is computed once.",
				"answer": "a",
				"topics": ["Dynamic Programming", "Time Complexity"]
			},
			{
				"question": "Consider the following recursive solution for the Climbing Stairs problem:\n```python\n# Line 1\ndef climbStairs(n):\n    # Line 2\n    if n <= 2:\n        return n\n    # Line 3\n    return climbStairs(n-1) + climbStairs(n-2)\n```\nWhat is the time complexity of this recursive solution?",
				"options": ["O(n)", "O(n^2)", "O(2^n)", "O(log n)"],
				"explanation": "The recursive solution without memoization results in a time complexity of O(2^n) because it recalculates the number of ways for each step multiple times, leading to an exponential growth in the number of recursive calls.",
				"answer": "c",
				"topics": ["Recursion", "Time Complexity"]
			},
			{
				"question": "Given the following iterative solution for the Climbing Stairs problem, which line contains a bug?\n```python\n# Line 1\ndef climbStairs(n):\n    # Line 2\n    if n <= 2:\n        return n\n    # Line 3\n    first, second = 1, 2\n    # Line 4\n    for i in range(3, n+1):\n        # Line 5\n        third = first + second\n        # Line 6\n        first = second\n        # Line 7\n        second = third\n    # Line 8\n    return second\n```\n",
				"options": [
					"Line 2: if n <= 2: return n",
					"Line 4: for i in range(3, n+1):",
					"Line 5: third = first + second",
					"Line 8: return second"
				],
				"explanation": "The bug is in Line 2: `if n <= 2: return n`. This line incorrectly returns `n` for `n = 2`, which is correct, but for `n = 1`, it should return `1` instead of `2`. The correct condition should be `if n == 1: return 1` and `if n == 2: return 2`.",
				"answer": "a",
				"topics": ["Implementation Analysis", "Bug Spotting"]
			},
			{
				"question": "In the Climbing Stairs problem, if you use a dynamic programming approach with an array to store the number of ways to reach each step, what is the space complexity?",
				"options": ["O(1)", "O(n)", "O(n^2)", "O(log n)"],
				"explanation": "The space complexity is O(n) because an array of size n is used to store the number of ways to reach each step from 1 to n.",
				"answer": "b",
				"topics": ["Dynamic Programming", "Space Complexity"]
			}
		]
	},
	{
		"slug": "simplify-path",
		"title": "71. Simplify Path",
		"leetcodeUrl": "https://leetcode.com/problems/simplify-path",
		"difficulty": "Medium",
		"topics": ["String", "Stack"],
		"content": "Given a string `path`, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style filesystem, convert it to the simplified canonical path.\n\nIn a Unix-style filesystem, a period `.` refers to the current directory, a double period `..` refers to the directory up a level, and any multiple consecutive slashes (i.e. `//`) are treated as a single slash `/`. For this problem, any other format of periods such as `...` are treated as file/directory names.\n\nThe canonical path should have the following format:\n- The path starts with a single slash `/`.\n- Any two directories are separated by a single slash `/`.\n- The path does not end with a trailing `/`.\n- The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period `.` or double period `..`).\n\nReturn the simplified canonical path.\n\n**Example 1:**\n```\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation: Note that there is no trailing slash after the last directory name.\n```\n\n**Example 2:**\n```\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n```\n\n**Example 3:**\n```\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n```\n\n**Constraints:**\n- `1 <= path.length <= 3000`\n- `path` consists of English letters, digits, period `.`, slash `/` or `_`.\n- `path` is a valid absolute Unix path.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the algorithm to simplify a Unix-style file path using a stack?",
				"options": ["O(n)", "O(n log n)", "O(n^2)", "O(1)"],
				"explanation": "The algorithm iterates through each character in the path string once, performing constant time operations (push and pop) on a stack. Therefore, the time complexity is O(n), where n is the length of the path string.",
				"answer": "a",
				"topics": ["String", "Stack"]
			},
			{
				"question": "Given the following code snippet for simplifying a Unix-style path, which line contains a bug?\n```python\n1. def simplifyPath(path):\n2.     stack = []\n3.     components = path.split('/')\n4.     for component in components:\n5.         if component == '' or component == '.':\n6.             continue\n7.         elif component == '..':\n8.             if stack:\n9.                 stack.pop()\n10.        else:\n11.            stack.append(component)\n12.    return '/' + '/'.join(stack)\n```\nWhich line contains the bug and why does it still pass many test cases?",
				"options": [
					"Line 5: because it incorrectly handles empty components",
					"Line 7: because it doesn't check if stack is empty before popping",
					"Line 11: because it appends components without validation",
					"Line 12: because it doesn't handle the root path correctly"
				],
				"explanation": "The code correctly handles empty components and '.' by skipping them, and '..' by popping from the stack if it's not empty. Line 12 correctly joins the stack with slashes. The bug is not present in the given code; all lines are correct for the problem constraints. However, if there were a bug, it would likely be in handling edge cases like multiple slashes or leading/trailing slashes, which are correctly handled here.",
				"answer": "a",
				"topics": ["String", "Stack"]
			},
			{
				"question": "In the context of simplifying a Unix-style path, which of the following operations is crucial for handling the '..' component?",
				"options": [
					"Pushing the component onto the stack",
					"Popping the top of the stack",
					"Skipping the component",
					"Joining the stack into a string"
				],
				"explanation": "The '..' component indicates moving up one directory level, which is achieved by popping the top of the stack. This operation removes the last directory added to the path, effectively moving up one level.",
				"answer": "b",
				"topics": ["String", "Stack"]
			},
			{
				"question": "Consider the following path: \"/a/./b/../../c/\". What is the simplified canonical path?",
				"options": ["/a/c", "/c", "/a/b/c", "/b/c"],
				"explanation": "The path \"/a/./b/../../c/\" simplifies as follows: \n- \"/a/\" adds 'a' to the stack.\n- \"/./\" is ignored as it refers to the current directory.\n- \"/b/\" adds 'b' to the stack.\n- \"/../\" pops 'b' from the stack.\n- \"/../\" pops 'a' from the stack.\n- \"/c/\" adds 'c' to the stack.\nThe resulting path is \"/c\".",
				"answer": "b",
				"topics": ["String", "Stack"]
			},
			{
				"question": "Which of the following is a valid simplified canonical path for the input \"/a//b////c/d//././/..\"?",
				"options": ["/a/b/c", "/a/b", "/a/b/c/d", "/a/c"],
				"explanation": "The path \"/a//b////c/d//././/..\" simplifies as follows:\n- \"/a/\" adds 'a' to the stack.\n- \"/b/\" adds 'b' to the stack.\n- \"/c/\" adds 'c' to the stack.\n- \"/d/\" adds 'd' to the stack.\n- \"/./\" is ignored as it refers to the current directory.\n- \"/..\" pops 'd' from the stack.\nThe resulting path is \"/a/b/c\".",
				"answer": "a",
				"topics": ["String", "Stack"]
			},
			{
				"question": "Which of the following modifications would optimize the space complexity of the path simplification algorithm?",
				"options": [
					"Use a linked list instead of a stack",
					"Use a single string to build the path",
					"Use a queue instead of a stack",
					"Use a fixed-size array for components"
				],
				"explanation": "Using a single string to build the path would not optimize space complexity because it would require frequent string concatenations, which are costly. A stack is already efficient for this purpose. Using a linked list or queue would not provide any space benefits over a stack. A fixed-size array is not feasible due to the dynamic nature of the path components.",
				"answer": "a",
				"topics": ["String", "Stack"]
			}
		]
	},
	{
		"slug": "edit-distance",
		"title": "Edit Distance",
		"leetcodeUrl": "https://leetcode.com/problems/edit-distance",
		"difficulty": "Medium",
		"topics": ["Dynamic Programming", "String"],
		"content": "Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.\n\nYou have the following three operations permitted on a word:\n\n- Insert a character\n- Delete a character\n- Replace a character\n\n**Example 1:**\n```\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: horse -> rorse (replace 'h' with 'r')\n             rorse -> rose (remove 'r')\n             rose -> ros (remove 'e')\n```\n\n**Example 2:**\n```\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: intention -> inention (remove 't')\n             inention -> enention (replace 'i' with 'e')\n             enention -> exention (replace 'n' with 'x')\n             exention -> exection (replace 'n' with 'c')\n             exection -> execution (insert 'u')\n```\n\n**Constraints:**\n- `0 <= word1.length, word2.length <= 500`\n- `word1` and `word2` consist of lowercase English letters.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the dynamic programming solution for the Edit Distance problem, where the lengths of the input strings are m and n?",
				"options": ["O(m + n)", "O(m * n)", "O(m^2 * n^2)", "O(2^m * 2^n)"],
				"explanation": "The dynamic programming solution for the Edit Distance problem involves filling up a 2D table of size m x n, where m and n are the lengths of the two input strings. Each cell in the table is computed in constant time, leading to a time complexity of O(m * n).",
				"answer": "b",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "Given the following dynamic programming solution for the Edit Distance problem, which line contains a bug?\n```python\n1. def minDistance(word1, word2):\n2.     m, n = len(word1), len(word2)\n3.     dp = [[0] * (n + 1) for _ in range(m + 1)]\n4.     for i in range(m + 1):\n5.         dp[i][0] = i\n6.     for j in range(n + 1):\n7.         dp[0][j] = j\n8.     for i in range(1, m + 1):\n9.         for j in range(1, n + 1):\n10.            if word1[i - 1] == word2[j - 1]:\n11.                dp[i][j] = dp[i - 1][j - 1]\n12.            else:\n13.                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n14.    return dp[m][n]\n```",
				"options": [
					"Line 5: dp[i][0] = i",
					"Line 7: dp[0][j] = j",
					"Line 11: dp[i][j] = dp[i - 1][j - 1]",
					"Line 13: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])"
				],
				"explanation": "The code correctly initializes the base cases in lines 5 and 7, and correctly handles the case where characters match in line 11. Line 13 correctly computes the minimum edit distance by considering all three operations: insert, delete, and replace. There is no bug in the provided lines; the solution is correct.",
				"answer": "d",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "In the Edit Distance problem, which of the following modifications would optimize the space complexity from O(m * n) to O(min(m, n))?",
				"options": [
					"Use a single array of size n to store the current row of the DP table.",
					"Use a single array of size m to store the current column of the DP table.",
					"Use two arrays of size n to store the current and previous rows of the DP table.",
					"Use two arrays of size m to store the current and previous columns of the DP table."
				],
				"explanation": "To optimize the space complexity, we can use two arrays of size equal to the smaller of the two input strings. This is because the DP solution only requires the current and previous rows (or columns) to compute the result. Thus, using two arrays of size n (or m) reduces the space complexity to O(min(m, n)).",
				"answer": "c",
				"topics": ["Dynamic Programming", "String", "Optimization"]
			},
			{
				"question": "Consider the following recursive solution for the Edit Distance problem without memoization. What is the time complexity of this solution?\n```python\n1. def editDistance(word1, word2, m, n):\n2.     if m == 0:\n3.         return n\n4.     if n == 0:\n5.         return m\n6.     if word1[m - 1] == word2[n - 1]:\n7.         return editDistance(word1, word2, m - 1, n - 1)\n8.     return 1 + min(editDistance(word1, word2, m, n - 1),\n9.                    editDistance(word1, word2, m - 1, n),\n10.                   editDistance(word1, word2, m - 1, n - 1))\n```",
				"options": ["O(m * n)", "O(m + n)", "O(3^(m + n))", "O(2^(m + n))"],
				"explanation": "The recursive solution without memoization explores all possible ways to convert one string to another, leading to an exponential number of recursive calls. Specifically, for each character, it considers three operations, resulting in a time complexity of O(3^(m + n)).",
				"answer": "c",
				"topics": ["Dynamic Programming", "String", "Recursion"]
			},
			{
				"question": "Which of the following scenarios would make a dynamic programming solution for the Edit Distance problem more efficient than a recursive solution with memoization?",
				"options": [
					"When the input strings are very short (length < 10).",
					"When the input strings are very long (length > 1000).",
					"When the input strings have many repeated characters.",
					"When the input strings are completely different with no common subsequences."
				],
				"explanation": "A dynamic programming solution is generally more efficient than a recursive solution with memoization when dealing with very long input strings, as it avoids the overhead of recursive function calls and stack management. The iterative nature of dynamic programming can handle large inputs more efficiently in terms of both time and space.",
				"answer": "b",
				"topics": ["Dynamic Programming", "String", "Optimization"]
			}
		]
	},
	{
		"slug": "set-matrix-zeroes",
		"title": "Set Matrix Zeroes",
		"leetcodeUrl": "https://leetcode.com/problems/set-matrix-zeroes",
		"difficulty": "Medium",
		"topics": ["Array", "Matrix"],
		"content": "Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0's`. You must do it in place.\n\n**Example 1:**\n```\nInput:\nmatrix = [[1,1,1],[1,0,1],[1,1,1]]\n```\n```\nOutput:\n[[1,0,1],[0,0,0],[1,0,1]]\n```\n\n**Example 2:**\n```\nInput:\nmatrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n```\n```\nOutput:\n[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n```\n\n**Constraints:**\n- `m == matrix.length`\n- `n == matrix[0].length`\n- `1 <= m,n <= 200`\n- `-231 <= matrix[i][j] <= 231 - 1`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the optimal solution for setting matrix zeroes in place?",
				"options": ["O(m * n)", "O(m^2 * n^2)", "O(m + n)", "O(log(m * n))"],
				"explanation": "The optimal solution involves iterating over the matrix twice: once to determine which rows and columns need to be zeroed, and once to set the zeroes. This results in a time complexity of O(m * n), where m is the number of rows and n is the number of columns.",
				"answer": "a",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "In the following code for setting matrix zeroes, which line contains a bug?\n```python\n1. def setZeroes(matrix):\n2.     rows, cols = len(matrix), len(matrix[0])\n3.     row_zero = [False] * rows\n4.     col_zero = [False] * cols\n5.     for i in range(rows):\n6.         for j in range(cols):\n7.             if matrix[i][j] == 0:\n8.                 row_zero[i] = True\n9.                 col_zero[j] = True\n10.    for i in range(rows):\n11.        for j in range(cols):\n12.            if row_zero[i] or col_zero[j]:\n13.                matrix[i][j] = 0\n14.    return matrix\n```",
				"options": [
					"Line 3: row_zero = [False] * rows",
					"Line 4: col_zero = [False] * cols",
					"Line 12: if row_zero[i] or col_zero[j]:",
					"Line 13: matrix[i][j] = 0"
				],
				"explanation": "The code correctly identifies which rows and columns need to be zeroed and then sets the appropriate elements to zero. However, the problem requires the solution to be in-place without using additional space for row_zero and col_zero arrays. The bug is conceptual rather than a syntax error, as the solution does not meet the in-place requirement.",
				"answer": "c",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "Which of the following modifications would allow the matrix zeroing solution to work in-place without using additional arrays?",
				"options": [
					"Use the first row and column of the matrix to store zeroing information.",
					"Use a separate boolean matrix to track zero positions.",
					"Use a hash set to store zero row and column indices.",
					"Use a stack to store zero positions."
				],
				"explanation": "To achieve an in-place solution, you can use the first row and column of the matrix itself to store information about which rows and columns need to be zeroed. This avoids the need for additional space while still allowing you to zero the matrix correctly.",
				"answer": "a",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "Consider the following code snippet for setting matrix zeroes:\n```python\n1. def setZeroes(matrix):\n2.     is_col = False\n3.     R, C = len(matrix), len(matrix[0])\n4.     for i in range(R):\n5.         if matrix[i][0] == 0:\n6.             is_col = True\n7.         for j in range(1, C):\n8.             if matrix[i][j] == 0:\n9.                 matrix[0][j] = 0\n10.                matrix[i][0] = 0\n11.    for i in range(1, R):\n12.        for j in range(1, C):\n13.            if matrix[i][0] == 0 or matrix[0][j] == 0:\n14.                matrix[i][j] = 0\n15.    if matrix[0][0] == 0:\n16.        for j in range(C):\n17.            matrix[0][j] = 0\n18.    if is_col:\n19.        for i in range(R):\n20.            matrix[i][0] = 0\n```\nWhat is the purpose of the `is_col` variable in this code?",
				"options": [
					"To track if the first column needs to be zeroed.",
					"To track if any column other than the first needs to be zeroed.",
					"To track if the first row needs to be zeroed.",
					"To track if any row other than the first needs to be zeroed."
				],
				"explanation": "The `is_col` variable is used to track whether the first column of the matrix needs to be zeroed. This is necessary because the first column is used to store zeroing information for other columns, so its original state must be preserved separately.",
				"answer": "a",
				"topics": ["Array", "Matrix"]
			},
			{
				"question": "In the context of setting matrix zeroes, why is it important to handle the first row and column separately when using them to store zeroing information?",
				"options": [
					"Because they are used to store zeroing information for the rest of the matrix.",
					"Because they are always zeroed regardless of their initial values.",
					"Because they are the largest row and column in the matrix.",
					"Because they contain the most elements in the matrix."
				],
				"explanation": "The first row and column are used to store zeroing information for the rest of the matrix. Therefore, their original state must be handled separately to ensure that the zeroing process does not inadvertently zero out the entire matrix prematurely.",
				"answer": "a",
				"topics": ["Array", "Matrix"]
			}
		]
	},
	{
		"slug": "search-a-2d-matrix",
		"title": "Search a 2D Matrix",
		"leetcodeUrl": "https://leetcode.com/problems/search-a-2d-matrix",
		"difficulty": "Medium",
		"topics": ["Binary Search", "Matrix"],
		"content": "You are given an `m x n` integer matrix `matrix` with the following two properties:\n\n- Each row is sorted in non-decreasing order.\n- The first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer `target`, return `true` if `target` is in `matrix` or `false` otherwise.\n\nYou must write a solution in `O(log(m*n))` time complexity.\n\n**Example 1:**\n```\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n```\n\n**Example 2:**\n```\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n```\n\n**Constraints:**\n- `m == matrix.length`\n- `n == matrix[i].length`\n- `1 <= m, n <= 100`\n- `-10^4 <= matrix[i][j], target <= 10^4`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following algorithms is most suitable for solving the 'Search a 2D Matrix' problem in O(log(m*n)) time complexity?",
				"options": [
					"Linear Search",
					"Binary Search",
					"Depth-First Search",
					"Breadth-First Search"
				],
				"explanation": "The problem requires searching in a matrix where each row is sorted and the first element of each row is greater than the last element of the previous row. This allows us to treat the matrix as a sorted 1D array and apply binary search, achieving O(log(m*n)) time complexity.",
				"answer": "b",
				"topics": ["Binary Search", "Matrix"]
			},
			{
				"question": "Given the following code snippet for searching a target in a 2D matrix, identify the bug:\n```python\n1 def searchMatrix(matrix, target):\n2     if not matrix or not matrix[0]:\n3         return False\n4     m, n = len(matrix), len(matrix[0])\n5     left, right = 0, m * n - 1\n6     while left <= right:\n7         mid = (left + right) // 2\n8         mid_value = matrix[mid // n][mid % n]\n9         if mid_value == target:\n10            return True\n11        elif mid_value < target:\n12            left = mid + 1\n13        else:\n14            right = mid - 1\n15    return False\n```\nWhich line contains the bug and why does it still pass many test cases?",
				"options": [
					"Line 5: Incorrect calculation of right boundary",
					"Line 7: Incorrect calculation of mid index",
					"Line 8: Incorrect access of mid_value",
					"Line 12: Incorrect update of left boundary"
				],
				"explanation": "The code correctly implements binary search on a 2D matrix by treating it as a 1D array. There is no bug in the code; all lines are correct. The options are designed to test understanding of the binary search implementation.",
				"answer": "a",
				"topics": ["Binary Search", "Matrix"]
			},
			{
				"question": "In the context of the 'Search a 2D Matrix' problem, what is the space complexity of the optimal solution?",
				"options": ["O(1)", "O(m)", "O(n)", "O(m*n)"],
				"explanation": "The optimal solution uses binary search and does not require any additional data structures that grow with the input size, thus the space complexity is O(1).",
				"answer": "a",
				"topics": ["Binary Search", "Matrix"]
			},
			{
				"question": "Consider the following modification to the binary search algorithm for the 'Search a 2D Matrix' problem. Which line should replace the ??? to correctly handle edge cases?\n```python\n1 def searchMatrix(matrix, target):\n2     if not matrix or not matrix[0]:\n3         return False\n4     m, n = len(matrix), len(matrix[0])\n5     left, right = 0, m * n - 1\n6     while left <= right:\n7         mid = (left + right) // 2\n8         mid_value = matrix[mid // n][mid % n]\n9         if ???:\n10            return True\n11        elif mid_value < target:\n12            left = mid + 1\n13        else:\n14            right = mid - 1\n15    return False\n```",
				"options": [
					"mid_value == target",
					"mid_value <= target",
					"mid_value >= target",
					"mid_value != target"
				],
				"explanation": "The correct condition to check if the target is found is 'mid_value == target'. This ensures that the function returns True when the target is located at the mid index.",
				"answer": "a",
				"topics": ["Binary Search", "Matrix"]
			},
			{
				"question": "What is the primary advantage of using binary search over linear search in the 'Search a 2D Matrix' problem?",
				"options": [
					"Binary search is easier to implement",
					"Binary search has better time complexity",
					"Binary search uses less space",
					"Binary search is more intuitive"
				],
				"explanation": "Binary search has a time complexity of O(log(m*n)), which is significantly better than the O(m*n) time complexity of linear search, especially for large matrices.",
				"answer": "b",
				"topics": ["Binary Search", "Matrix"]
			}
		]
	},
	{
		"slug": "sort-colors",
		"title": "Sort Colors",
		"leetcodeUrl": "https://leetcode.com/problems/sort-colors",
		"difficulty": "Medium",
		"topics": ["Array", "Two Pointers"],
		"content": "Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function.\n\n**Example 1:**\n```\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n```\n\n**Example 2:**\n```\nInput: nums = [2,0,1]\nOutput: [0,1,2]\n```\n\n**Constraints:**\n- `n == nums.length`\n- `1 <= n <= 300`\n- `nums[i]` is either `0`, `1`, or `2`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following algorithms is most suitable for solving the \"Sort Colors\" problem efficiently in-place?",
				"options": [
					"Bubble Sort",
					"Merge Sort",
					"Counting Sort",
					"Dutch National Flag Algorithm"
				],
				"explanation": "The \"Sort Colors\" problem can be efficiently solved using the Dutch National Flag Algorithm, which is specifically designed to sort an array with three distinct values in a single pass. This algorithm uses three pointers to partition the array into three sections, achieving an O(n) time complexity and O(1) space complexity. Bubble Sort and Merge Sort are not optimal for this problem due to their higher time complexity and space requirements. Counting Sort, while efficient, requires additional space for counting, which is not in-place.",
				"answer": "d",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Consider the following implementation of the Dutch National Flag Algorithm for sorting colors:\n```python\n1. def sortColors(nums):\n2.     low, mid, high = 0, 0, len(nums) - 1\n3.     while mid <= high:\n4.         if nums[mid] == 0:\n5.             nums[low], nums[mid] = nums[mid], nums[low]\n6.             low += 1\n7.             mid += 1\n8.         elif nums[mid] == 1:\n9.             mid += 1\n10.        else:\n11.            nums[mid], nums[high] = nums[high], nums[mid]\n12.            high -= 1\n13.    return nums\n```\nWhat is the time complexity of this implementation?",
				"options": ["O(n^2)", "O(n log n)", "O(n)", "O(log n)"],
				"explanation": "The time complexity of this implementation is O(n) because it processes each element of the array exactly once. The algorithm uses three pointers to partition the array into three sections, and each swap operation is constant time. Thus, the overall complexity is linear with respect to the number of elements in the array.",
				"answer": "c",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "In the Dutch National Flag Algorithm, what is the purpose of the `high` pointer?",
				"options": [
					"To track the position of the last 0 in the array",
					"To track the position of the first 2 in the array",
					"To track the position of the last 1 in the array",
					"To track the position of the first 0 in the array"
				],
				"explanation": "In the Dutch National Flag Algorithm, the `high` pointer is used to track the position of the first 2 in the array. It helps in placing all 2s at the end of the array by swapping elements when a 2 is encountered at the `mid` pointer. This ensures that all elements after `high` are 2s.",
				"answer": "b",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Identify the bug in the following implementation of the Dutch National Flag Algorithm:\n```python\n1. def sortColors(nums):\n2.     low, mid, high = 0, 0, len(nums) - 1\n3.     while mid <= high:\n4.         if nums[mid] == 0:\n5.             nums[low], nums[mid] = nums[mid], nums[low]\n6.             low += 1\n7.         elif nums[mid] == 1:\n8.             mid += 1\n9.         else:\n10.            nums[mid], nums[high] = nums[high], nums[mid]\n11.            high -= 1\n12.    return nums\n```\nWhy does this implementation fail for some test cases?",
				"options": [
					"The `mid` pointer is not incremented after swapping with `low`.",
					"The `mid` pointer is not incremented after swapping with `high`.",
					"The `low` pointer is not incremented correctly.",
					"The `high` pointer is not decremented correctly."
				],
				"explanation": "The bug in this implementation is that the `mid` pointer is not incremented after swapping with `low`. This can cause the algorithm to get stuck if the swapped element is also 0, as it will be processed again in the next iteration. The correct approach is to increment `mid` after swapping with `low` to ensure progress through the array.",
				"answer": "a",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following code snippet for sorting colors, which line should replace the ??? to correctly implement the Dutch National Flag Algorithm?\n```python\n1. def sortColors(nums):\n2.     low, mid, high = 0, 0, len(nums) - 1\n3.     while mid <= high:\n4.         if nums[mid] == 0:\n5.             nums[low], nums[mid] = nums[mid], nums[low]\n6.             low += 1\n7.             mid += 1\n8.         elif nums[mid] == 1:\n9.             mid += 1\n10.        else:\n11.            ???\n12.            high -= 1\n13.    return nums\n```\n",
				"options": [
					"nums[mid], nums[high] = nums[high], nums[mid]",
					"nums[high], nums[mid] = nums[mid], nums[high]",
					"nums[low], nums[high] = nums[high], nums[low]",
					"nums[high], nums[low] = nums[low], nums[high]"
				],
				"explanation": "The correct line to replace ??? is `nums[mid], nums[high] = nums[high], nums[mid]`. This line swaps the current element at `mid` with the element at `high`, effectively moving the 2 to the end of the array. The `high` pointer is then decremented to reflect the new boundary for 2s.",
				"answer": "a",
				"topics": ["Array", "Two Pointers"]
			}
		]
	},
	{
		"slug": "minimum-window-substring",
		"title": "Minimum Window Substring",
		"leetcodeUrl": "https://leetcode.com/problems/minimum-window-substring",
		"difficulty": "Hard",
		"topics": ["String", "Sliding Window", "Two Pointers"],
		"content": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string `\"\"`.\n\nThe test cases will be generated such that the answer is unique.\n\n**Example 1:**\n```\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n```\n\n**Example 2:**\n```\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n```\n\n**Example 3:**\n```\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window. Since the largest window of s only has one 'a', return empty string.\n```\n\n**Constraints:**\n- `m == s.length`\n- `n == t.length`\n- `1 <= m, n <= 10^5`\n- `s` and `t` consist of uppercase and lowercase English letters.",
		"rating": 2400,
		"MCQs": [
			{
				"question": "What is the primary algorithmic technique used to solve the Minimum Window Substring problem efficiently?",
				"options": [
					"Dynamic Programming",
					"Sliding Window",
					"Binary Search",
					"Depth-First Search"
				],
				"explanation": "The Minimum Window Substring problem is efficiently solved using the Sliding Window technique. This approach allows us to dynamically adjust the window size to find the smallest substring that contains all characters of the target string.",
				"answer": "b",
				"topics": ["String", "Sliding Window", "Two Pointers"]
			},
			{
				"question": "In the following implementation of the Minimum Window Substring problem, which line contains a bug that prevents it from correctly identifying the minimum window?\n```python\nfrom collections import Counter\n\ndef minWindow(s, t):\n    if not t or not s:\n        return \"\"\n\n    dict_t = Counter(t)\n    required = len(dict_t)\n\n    l, r = 0, 0\n    formed = 0\n    window_counts = {}\n    ans = float(\"inf\"), None, None\n\n    while r < len(s):\n        character = s[r]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n\n        while l <= r and formed == required:\n            character = s[l]\n\n            if r - l + 1 < ans[0]:\n                ans = (r - l + 1, l, r)\n\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n\n            l += 1\n\n        r += 1\n\n    return \"\" if ans[0] == float(\"inf\") else s[ans[1]: ans[2] + 1]\n```\n",
				"options": [
					"Line 10: if not t or not s:",
					"Line 18: if character in dict_t and window_counts[character] == dict_t[character]:",
					"Line 24: if r - l + 1 < ans[0]:",
					"Line 30: if character in dict_t and window_counts[character] < dict_t[character]:"
				],
				"explanation": "The bug is in Line 24: `if r - l + 1 < ans[0]:`. This line is correct and updates the answer when a smaller window is found. The implementation is correct, and there is no bug in the provided code. The options are designed to test understanding of the algorithm's logic.",
				"answer": "c",
				"topics": ["String", "Sliding Window", "Two Pointers"]
			},
			{
				"question": "Consider the following scenarios. In which scenario would a heap-based solution for finding the minimum window substring be more efficient than the sliding window approach?",
				"options": [
					"When the string s is extremely large and t is very small.",
					"When the string s and t are both very small.",
					"When the string s is small and t is very large.",
					"When both strings s and t are extremely large."
				],
				"explanation": "A heap-based solution is generally not more efficient than the sliding window approach for the Minimum Window Substring problem. The sliding window approach is optimal for this problem because it efficiently narrows down the window size while maintaining the required characters. The heap-based approach would add unnecessary complexity and overhead.",
				"answer": "a",
				"topics": ["String", "Sliding Window", "Two Pointers"]
			},
			{
				"question": "Analyze the time complexity of the sliding window solution for the Minimum Window Substring problem. Consider both the operations within the window and the overall traversal of the string.",
				"options": [
					"O(n^2) due to nested loops",
					"O(n) because each character is processed at most twice",
					"O(n log n) due to sorting operations",
					"O(n + m) where n is the length of s and m is the length of t"
				],
				"explanation": "The time complexity of the sliding window solution is O(n) because each character in the string s is processed at most twice: once when the right pointer expands the window and once when the left pointer contracts it. There are no nested loops that iterate over the entire string, and no sorting operations are involved.",
				"answer": "b",
				"topics": ["String", "Sliding Window", "Two Pointers"]
			},
			{
				"question": "In the sliding window approach for the Minimum Window Substring problem, what is the purpose of the 'formed' variable?",
				"options": [
					"To count the total number of characters in the window",
					"To track the number of unique characters in the window",
					"To track the number of unique characters that match the target string",
					"To count the total number of characters that match the target string"
				],
				"explanation": "The 'formed' variable is used to track the number of unique characters in the current window that match the required frequency in the target string t. It helps determine when the current window contains all the necessary characters to potentially be a valid solution.",
				"answer": "c",
				"topics": ["String", "Sliding Window", "Two Pointers"]
			},
			{
				"question": "In the sliding window solution for the Minimum Window Substring problem, which line should replace the ??? to correctly update the window counts?\n```python\nwhile l <= r and formed == required:\n    character = s[l]\n\n    if r - l + 1 < ans[0]:\n        ans = (r - l + 1, l, r)\n\n    window_counts[character] -= 1\n    if ???:\n        formed -= 1\n\n    l += 1\n```",
				"options": [
					"window_counts[character] < dict_t[character]",
					"window_counts[character] == dict_t[character]",
					"window_counts[character] <= dict_t[character]",
					"window_counts[character] > dict_t[character]"
				],
				"explanation": "The correct line to replace ??? is `window_counts[character] < dict_t[character]`. This condition checks if the current character's count in the window has fallen below the required count in the target string, indicating that the window is no longer valid for the current character.",
				"answer": "a",
				"topics": ["String", "Sliding Window", "Two Pointers"]
			}
		]
	},
	{
		"slug": "combinations",
		"title": "77. Combinations",
		"leetcodeUrl": "https://leetcode.com/problems/combinations",
		"difficulty": "Medium",
		"topics": ["Backtracking"],
		"content": "Given two integers `n` and `k`, return all possible combinations of `k` numbers chosen from the range `[1, n]`. You may return the answer in any order.\n\n**Example 1:**\n```\nInput: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations. Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n```\n\n**Example 2:**\n```\nInput: n = 1, k = 1\nOutput: [[1]]\nExplanation: There is 1 choose 1 = 1 total combination.\n```\n\n**Constraints:**\n- `1 <= n <= 20`\n- `1 <= k <= n`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of generating all combinations of k numbers from a set of n numbers using a backtracking approach?",
				"options": ["O(n^k)", "O(k * n^k)", "O(n! / (k! * (n-k)!))", "O(2^n)"],
				"explanation": "The time complexity of generating all combinations of k numbers from a set of n numbers using a backtracking approach is O(n! / (k! * (n-k)!)). This is because the number of combinations is given by the binomial coefficient C(n, k), which is n! / (k! * (n-k)!). The backtracking algorithm explores each combination once, leading to this complexity.",
				"answer": "c",
				"topics": ["Backtracking", "Combinatorics"]
			},
			{
				"question": "Given the following backtracking implementation for generating combinations, which line contains a bug?\n```python\n1. def combine(n, k):\n2.     def backtrack(start, path):\n3.         if len(path) == k:\n4.             result.append(path)\n5.             return\n6.         for i in range(start, n + 1):\n7.             path.append(i)\n8.             backtrack(i + 1, path)\n9.             path.pop()\n10.    result = []\n11.    backtrack(1, [])\n12.    return result\n```\nWhich line contains the bug and why?",
				"options": [
					"Line 4: result.append(path) should append a copy of path",
					"Line 6: for i in range(start, n + 1) should be for i in range(start, n)",
					"Line 8: backtrack(i + 1, path) should be backtrack(i, path)",
					"Line 9: path.pop() should be path.remove(i)"
				],
				"explanation": "The bug is in Line 4: result.append(path) should append a copy of path. In Python, lists are mutable, and appending the path directly will result in all entries in result pointing to the same list object, which will be empty after the backtracking completes. A copy of the path should be appended instead, using result.append(path[:]).",
				"answer": "a",
				"topics": ["Backtracking", "Implementation Analysis"]
			},
			{
				"question": "In a backtracking solution for generating combinations, what is the primary purpose of the 'path' variable?",
				"options": [
					"To store the current combination being constructed",
					"To keep track of visited nodes in the search tree",
					"To store all possible combinations",
					"To optimize the search by pruning unnecessary branches"
				],
				"explanation": "The 'path' variable is used to store the current combination being constructed. As the backtracking algorithm explores different branches of the search tree, 'path' is modified to reflect the current state of the combination being built. Once a valid combination is found, it is typically added to a result list.",
				"answer": "a",
				"topics": ["Backtracking", "Algorithm Design"]
			},
			{
				"question": "Consider the following backtracking solution for generating combinations. What is the space complexity of this solution?\n```python\n1. def combine(n, k):\n2.     def backtrack(start, path):\n3.         if len(path) == k:\n4.             result.append(path[:])\n5.             return\n6.         for i in range(start, n + 1):\n7.             path.append(i)\n8.             backtrack(i + 1, path)\n9.             path.pop()\n10.    result = []\n11.    backtrack(1, [])\n12.    return result\n```\n",
				"options": ["O(n)", "O(k)", "O(n^k)", "O(n! / (k! * (n-k)!))"],
				"explanation": "The space complexity of this backtracking solution is O(k). This is because the maximum depth of the recursion stack is k, which corresponds to the length of the path being constructed. Additionally, the space used by the result list is not considered in the space complexity analysis as it is output space.",
				"answer": "b",
				"topics": ["Backtracking", "Space Complexity"]
			},
			{
				"question": "Which of the following modifications would optimize the backtracking solution for generating combinations by reducing unnecessary recursive calls?\n```python\n1. def combine(n, k):\n2.     def backtrack(start, path):\n3.         if len(path) == k:\n4.             result.append(path[:])\n5.             return\n6.         for i in range(start, n + 1):\n7.             path.append(i)\n8.             backtrack(i + 1, path)\n9.             path.pop()\n10.    result = []\n11.    backtrack(1, [])\n12.    return result\n```\n",
				"options": [
					"Add a condition to skip numbers that cannot complete a combination",
					"Use a set to track visited numbers",
					"Sort the numbers before starting the backtracking",
					"Start the loop from 0 instead of 1"
				],
				"explanation": "Adding a condition to skip numbers that cannot complete a combination would optimize the solution. Specifically, if the remaining numbers are fewer than needed to complete a combination, the function can return early. This reduces unnecessary recursive calls and prunes the search space effectively.",
				"answer": "a",
				"topics": ["Backtracking", "Optimization"]
			}
		]
	},
	{
		"slug": "subsets",
		"title": "Subsets",
		"leetcodeUrl": "https://leetcode.com/problems/subsets",
		"difficulty": "Medium",
		"topics": ["Backtracking"],
		"content": "Given an integer array `nums` of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.\n\n**Example 1:**\n```\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n**Example 2:**\n```\nInput: nums = [0]\nOutput: [[],[0]]\n```\n\n**Constraints:**\n- `1 <= nums.length <= 10`\n- `-10 <= nums[i] <= 10`\n- All the numbers of `nums` are unique.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is the correct time complexity for generating all subsets of a set with n elements using a backtracking approach?",
				"options": ["O(n * 2^n)", "O(2^n)", "O(n^2)", "O(n!)"],
				"explanation": "The time complexity for generating all subsets of a set with n elements is O(n * 2^n). This is because there are 2^n possible subsets, and generating each subset takes O(n) time in the worst case (to copy the subset).",
				"answer": "a",
				"topics": ["Backtracking", "Complexity Analysis"]
			},
			{
				"question": "Consider the following code snippet for generating subsets:\n```python\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        self.backtrack(nums, 0, [], res)\n        return res\n    \n    def backtrack(self, nums, start, path, res):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            self.backtrack(nums, i + 1, path, res)\n            path.pop()\n```\nWhat is the purpose of the line `path.pop()` in the `backtrack` function?",
				"options": [
					"To remove the last element and explore other subsets",
					"To ensure the path is empty before starting a new subset",
					"To prevent duplicate subsets from being added",
					"To optimize the space complexity of the solution"
				],
				"explanation": "The `path.pop()` line is used to backtrack by removing the last element added to the current path. This allows the algorithm to explore other subsets by trying different combinations of elements.",
				"answer": "a",
				"topics": ["Backtracking", "Implementation"]
			},
			{
				"question": "In the context of generating subsets, which of the following statements is true about the use of recursion and iteration?",
				"options": [
					"Recursion is necessary to generate all subsets, iteration cannot be used.",
					"Iteration can be used to generate subsets, but recursion is more intuitive for this problem.",
					"Recursion is more efficient than iteration for generating subsets.",
					"Iteration is more efficient than recursion for generating subsets."
				],
				"explanation": "Iteration can be used to generate subsets, but recursion is often more intuitive for this problem because it naturally handles the branching structure of subset generation. Both methods can be used, but recursion aligns well with the backtracking approach.",
				"answer": "b",
				"topics": ["Backtracking", "Recursion"]
			},
			{
				"question": "Given the following code snippet for generating subsets, identify the bug:\n```python\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        self.backtrack(nums, 0, [], res)\n        return res\n    \n    def backtrack(self, nums, start, path, res):\n        res.append(path)\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            self.backtrack(nums, i + 1, path, res)\n            path.pop()\n```\nWhat is the issue with this implementation?",
				"options": [
					"The subsets are not generated in lexicographical order.",
					"The `path` is not copied before appending to `res`, leading to incorrect results.",
					"The function does not handle empty input correctly.",
					"The `start` index is not incremented correctly."
				],
				"explanation": "The issue is that `path` is not copied before appending to `res`. This means that all entries in `res` will end up being the same list object, which is modified in place. The correct approach is to append a copy of `path` using `path[:]`.",
				"answer": "b",
				"topics": ["Backtracking", "Implementation Analysis"]
			},
			{
				"question": "Which of the following modifications would allow the subset generation algorithm to work in-place without using additional space for storing subsets?",
				"options": [
					"Use a global variable to store subsets instead of passing `res` as a parameter.",
					"Modify the input array to store both original and processed values.",
					"Use a bitmask to represent subsets and generate them iteratively.",
					"Change the iteration direction to avoid extra storage."
				],
				"explanation": "Using a bitmask to represent subsets and generate them iteratively allows the algorithm to work in-place without additional space for storing subsets. This approach leverages the binary representation of numbers to indicate the presence or absence of elements in a subset.",
				"answer": "c",
				"topics": ["Backtracking", "Optimization"]
			}
		]
	},
	{
		"slug": "word-search",
		"title": "Word Search",
		"leetcodeUrl": "https://leetcode.com/problems/word-search",
		"difficulty": "Medium",
		"topics": ["Backtracking"],
		"content": "Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n**Example 1:**\n```\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\nOutput: true\n```\n\n**Example 2:**\n```\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\nOutput: true\n```\n\n**Example 3:**\n```\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\nOutput: false\n```\n\n**Constraints:**\n- `m == board.length`\n- `n == board[i].length`\n- `1 <= m,n <= 6`\n- `1 <= word.length <= 15`\n- `board` and `word` consist of only lowercase and uppercase English letters.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a core concept used in solving the Word Search problem efficiently?",
				"options": [
					"Dynamic Programming",
					"Backtracking",
					"Greedy Algorithm",
					"Divide and Conquer"
				],
				"explanation": "The Word Search problem is typically solved using backtracking. This approach involves exploring all possible paths in the grid to find the word, and backtracking when a path does not lead to a solution. Dynamic programming, greedy algorithms, and divide and conquer are not suitable for this problem due to its nature of exploring multiple paths and constraints.",
				"answer": "b",
				"topics": ["Backtracking"]
			},
			{
				"question": "Consider the following implementation of the Word Search problem. Identify the bug in the code:\n```python\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        def dfs(x, y, index):\n            if index == len(word):\n                return True\n            if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or board[x][y] != word[index]:\n                return False\n            temp = board[x][y]\n            board[x][y] = '#'  # mark as visited\n            found = (dfs(x+1, y, index+1) or\n                     dfs(x-1, y, index+1) or\n                     dfs(x, y+1, index+1) or\n                     dfs(x, y-1, index+1))\n            board[x][y] = temp  # unmark\n            return found\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False\n```\nWhat is the bug in this implementation?",
				"options": [
					"The board is not reset correctly after each DFS call.",
					"The DFS function does not check all possible directions.",
					"The base case for the DFS function is incorrect.",
					"The board is marked as visited incorrectly."
				],
				"explanation": "The bug in the implementation is that the board is not reset correctly after each DFS call. The line `board[x][y] = temp` correctly unmarks the cell, allowing other paths to use it. However, if the function returns early due to a found path, the board might not be reset properly for other starting points. This is a subtle issue that can cause incorrect results if not handled properly.",
				"answer": "a",
				"topics": ["Backtracking", "Implementation Analysis"]
			},
			{
				"question": "In the Word Search problem, which of the following modifications would optimize the space complexity of the solution?",
				"options": [
					"Use a separate visited matrix to track visited cells.",
					"Use a stack to simulate recursion and avoid stack overflow.",
					"Modify the board in-place to mark visited cells.",
					"Store all possible paths in a list to avoid recomputation."
				],
				"explanation": "Modifying the board in-place to mark visited cells is an efficient way to optimize space complexity. This approach avoids the need for an additional visited matrix, reducing the space usage. Using a stack to simulate recursion or storing all paths would increase space complexity, and a separate visited matrix would not optimize space usage.",
				"answer": "c",
				"topics": ["Backtracking", "Optimization"]
			},
			{
				"question": "Analyze the time complexity of the backtracking solution for the Word Search problem. Assume the board has dimensions m x n and the word has length k.",
				"options": [
					"O(m * n * 4^k)",
					"O(m * n * k)",
					"O(4^k)",
					"O(m * n * k^2)"
				],
				"explanation": "The time complexity of the backtracking solution is O(m * n * 4^k). This is because for each cell in the m x n board, the algorithm explores up to 4 possible directions (up, down, left, right) for each character in the word of length k. The exponential factor 4^k comes from the branching factor of 4 at each step of the recursion.",
				"answer": "a",
				"topics": ["Backtracking", "Complexity Analysis"]
			},
			{
				"question": "Given the constraints of the Word Search problem, which of the following scenarios would most likely lead to a performance bottleneck?",
				"options": [
					"A board with maximum size and a word with maximum length.",
					"A board with minimum size and a word with maximum length.",
					"A board with maximum size and a word with minimum length.",
					"A board with minimum size and a word with minimum length."
				],
				"explanation": "A board with maximum size and a word with maximum length would most likely lead to a performance bottleneck. This is because the algorithm needs to explore a large number of possible paths in a large grid, and the word's maximum length increases the depth of the recursion, leading to a high number of recursive calls and potential stack overflow.",
				"answer": "a",
				"topics": ["Backtracking", "Performance"]
			}
		]
	},
	{
		"slug": "remove-duplicates-from-sorted-array-ii",
		"title": "Remove Duplicates from Sorted Array II",
		"leetcodeUrl": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii",
		"difficulty": "Medium",
		"topics": ["Array", "Two Pointers"],
		"content": "Given an integer array `nums` sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.\n\nReturn `k` after placing the final result in the first `k` slots of `nums`. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n\n**Example 1:**\n```\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1,1,2,2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).\n```\n\n**Example 2:**\n```\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0,0,1,1,2,3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).\n```\n\n**Constraints:**\n- `1 <= nums.length <= 3 * 10^4`\n- `-10^4 <= nums[i] <= 10^4`\n- `nums` is sorted in non-decreasing order.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is the correct approach to solve the problem of removing duplicates from a sorted array such that each element appears at most twice?",
				"options": [
					"a) Use a hash map to count occurrences and then filter the array.",
					"b) Use two pointers to overwrite duplicates in-place.",
					"c) Sort the array and then remove duplicates using a set.",
					"d) Use a stack to keep track of element counts and modify the array."
				],
				"explanation": "The correct approach is to use two pointers. One pointer iterates through the array, while the other keeps track of the position to overwrite elements. This allows us to modify the array in-place without using extra space, which is a requirement of the problem.",
				"answer": "b",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following code snippet for removing duplicates from a sorted array, which line contains a bug?\n```python\n1. def removeDuplicates(nums):\n2.     if len(nums) <= 2:\n3.         return len(nums)\n4.     write_index = 2\n5.     for i in range(2, len(nums)):\n6.         if nums[i] != nums[write_index - 2]:\n7.             nums[write_index] = nums[i]\n8.             write_index += 1\n9.     return write_index\n```\nWhat is the bug and why does it still pass many test cases?",
				"options": [
					"a) Line 2: The condition should be len(nums) < 2.",
					"b) Line 6: The comparison should be nums[i] != nums[write_index - 1].",
					"c) Line 7: The assignment should be nums[write_index - 1] = nums[i].",
					"d) There is no bug; the code is correct."
				],
				"explanation": "The code is correct as is. The condition in line 6 ensures that we only write a new element if it is different from the element two positions back, which allows each element to appear at most twice. The code passes all test cases because it correctly implements the two-pointer technique to overwrite duplicates in-place.",
				"answer": "d",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Consider the following code for removing duplicates from a sorted array:\n```python\n1. def removeDuplicates(nums):\n2.     if len(nums) <= 2:\n3.         return len(nums)\n4.     write_index = 2\n5.     for i in range(2, len(nums)):\n6.         if nums[i] != nums[write_index - 2]:\n7.             nums[write_index] = nums[i]\n8.             write_index += 1\n9.     return write_index\n```\nWhat is the time complexity of this solution?",
				"options": [
					"a) O(n^2) because of the nested loop structure.",
					"b) O(n) because each element is processed at most once.",
					"c) O(n log n) due to the sorting step.",
					"d) O(n) because of the two-pointer technique."
				],
				"explanation": "The time complexity of this solution is O(n) because the loop iterates through the array once, and each element is processed at most once. The two-pointer technique allows us to efficiently overwrite duplicates in-place without additional passes.",
				"answer": "b",
				"topics": ["Array", "Two Pointers", "Complexity Analysis"]
			},
			{
				"question": "In the context of the problem \"Remove Duplicates from Sorted Array II\", which of the following statements is true about the space complexity of the optimal solution?",
				"options": [
					"a) The space complexity is O(n) due to the use of extra arrays.",
					"b) The space complexity is O(1) because the solution modifies the array in-place.",
					"c) The space complexity is O(log n) due to recursive calls.",
					"d) The space complexity is O(n^2) because of the nested operations."
				],
				"explanation": "The space complexity of the optimal solution is O(1) because it modifies the array in-place without using any additional data structures. The two-pointer technique allows us to achieve this constant space complexity.",
				"answer": "b",
				"topics": ["Array", "Two Pointers", "Complexity Analysis"]
			},
			{
				"question": "Which of the following modifications would allow the given solution to handle arrays where each element can appear at most three times instead of two?",
				"options": [
					"a) Change the initial value of write_index to 3.",
					"b) Modify the condition in line 6 to nums[i] != nums[write_index - 3].",
					"c) Add an additional loop to handle the third occurrence.",
					"d) Use a hash map to track occurrences and modify the array accordingly."
				],
				"explanation": "To allow each element to appear at most three times, we need to modify the condition in line 6 to check against the element three positions back, i.e., nums[i] != nums[write_index - 3]. This ensures that we only write a new element if it is different from the element three positions back, allowing each element to appear at most three times.",
				"answer": "b",
				"topics": ["Array", "Two Pointers", "Implementation"]
			}
		]
	},
	{
		"slug": "search-in-rotated-sorted-array-ii",
		"title": "Search in Rotated Sorted Array II",
		"leetcodeUrl": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii",
		"difficulty": "Medium",
		"topics": ["Array", "Binary Search"],
		"content": "There is an integer array `nums` sorted in non-decreasing order (not necessarily with distinct values). Before being passed to your function, `nums` is rotated at an unknown pivot index `k` (0 <= k < nums.length) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed). For example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index 5 and become `[4,5,6,6,7,0,1,2,4,4]`. Given the array `nums` after the rotation and an integer `target`, return `true` if `target` is in `nums`, or `false` if it is not in `nums`. You must decrease the overall operation steps as much as possible.\n\n**Example 1:**\n```\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n```\n\n**Example 2:**\n```\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n```\n\n**Constraints:**\n- `1 <= nums.length <= 5000`\n- `-10^4 <= nums[i] <= 10^4`\n- `nums` is guaranteed to be rotated at some pivot.\n- `-10^4 <= target <= 10^4`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a key challenge when implementing a binary search on a rotated sorted array with duplicates?",
				"options": [
					"Handling the case where the middle element is equal to the start or end element.",
					"Ensuring the array is sorted before performing binary search.",
					"Finding the pivot point where the array was rotated.",
					"Handling negative numbers in the array."
				],
				"explanation": "The key challenge in implementing binary search on a rotated sorted array with duplicates is handling the case where the middle element is equal to the start or end element. This situation can make it difficult to determine which side of the array is sorted, as duplicates can obscure the pivot point. In such cases, a linear scan might be necessary to skip duplicates and correctly identify the sorted portion of the array.",
				"answer": "a",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "Given the following implementation of searching in a rotated sorted array with duplicates, which line contains a potential inefficiency?\n```python\n1. def search(nums, target):\n2.     left, right = 0, len(nums) - 1\n3.     while left <= right:\n4.         mid = left + (right - left) // 2\n5.         if nums[mid] == target:\n6.             return True\n7.         if nums[left] == nums[mid] == nums[right]:\n8.             left += 1\n9.             right -= 1\n10.        elif nums[left] <= nums[mid]:\n11.            if nums[left] <= target < nums[mid]:\n12.                right = mid - 1\n13.            else:\n14.                left = mid + 1\n15.        else:\n16.            if nums[mid] < target <= nums[right]:\n17.                left = mid + 1\n18.            else:\n19.                right = mid - 1\n20.    return False\n```",
				"options": [
					"Line 7: Checking if nums[left] == nums[mid] == nums[right]",
					"Line 8: Incrementing left when elements are equal",
					"Line 10: Checking if nums[left] <= nums[mid]",
					"Line 16: Checking if nums[mid] < target <= nums[right]"
				],
				"explanation": "Line 7 contains a potential inefficiency because when nums[left] == nums[mid] == nums[right], the algorithm resorts to a linear scan by incrementing left and decrementing right. This can degrade the performance to O(n) in the worst case, especially when there are many duplicates. However, this step is necessary to handle cases where duplicates obscure the pivot point.",
				"answer": "a",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "In the context of searching in a rotated sorted array with duplicates, which of the following scenarios would most likely require a linear scan?",
				"options": [
					"The array is rotated at the middle and contains no duplicates.",
					"The array is rotated at the start and contains many duplicates.",
					"The array is not rotated and contains no duplicates.",
					"The array is rotated at the end and contains a few duplicates."
				],
				"explanation": "When the array is rotated at the start and contains many duplicates, it becomes difficult to determine the sorted portion of the array using binary search alone. In such cases, a linear scan might be necessary to skip over duplicates and correctly identify the sorted portion, especially when the middle element is equal to both the start and end elements.",
				"answer": "b",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "Consider the following code snippet for searching in a rotated sorted array with duplicates. Which line should be modified to improve efficiency in the presence of duplicates?\n```python\n1. def search(nums, target):\n2.     left, right = 0, len(nums) - 1\n3.     while left <= right:\n4.         mid = left + (right - left) // 2\n5.         if nums[mid] == target:\n6.             return True\n7.         if nums[left] == nums[mid] == nums[right]:\n8.             left += 1\n9.             right -= 1\n10.        elif nums[left] <= nums[mid]:\n11.            if nums[left] <= target < nums[mid]:\n12.                right = mid - 1\n13.            else:\n14.                left = mid + 1\n15.        else:\n16.            if nums[mid] < target <= nums[right]:\n17.                left = mid + 1\n18.            else:\n19.                right = mid - 1\n20.    return False\n```",
				"options": [
					"Line 7: Change to handle duplicates more efficiently",
					"Line 8: Remove increment of left",
					"Line 10: Modify condition to check for strict inequality",
					"Line 16: Adjust condition to include equality"
				],
				"explanation": "Line 7 should be modified to handle duplicates more efficiently. The current approach of incrementing left and decrementing right when nums[left] == nums[mid] == nums[right] can lead to a linear scan, which is inefficient. A more sophisticated approach could involve additional checks to skip over duplicates more intelligently, potentially reducing the number of unnecessary comparisons.",
				"answer": "a",
				"topics": ["Array", "Binary Search"]
			},
			{
				"question": "What is the time complexity of the worst-case scenario for searching in a rotated sorted array with duplicates using the provided algorithm?",
				"options": ["O(log n)", "O(n)", "O(n log n)", "O(n^2)"],
				"explanation": "The worst-case time complexity of the provided algorithm is O(n). This occurs when the array contains many duplicates, and the algorithm has to resort to a linear scan to skip over these duplicates, as seen in the condition where nums[left] == nums[mid] == nums[right]. In such cases, the binary search degenerates to a linear search.",
				"answer": "b",
				"topics": ["Array", "Binary Search"]
			}
		]
	},
	{
		"slug": "remove-duplicates-from-sorted-list-ii",
		"title": "Remove Duplicates from Sorted List II",
		"leetcodeUrl": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii",
		"difficulty": "Medium",
		"topics": ["Linked List"],
		"content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\n\n**Example 1:**\n```\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n```\n\n**Example 2:**\n```\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n```\n\n**Constraints:**\n- The number of nodes in the list is in the range [0,300].\n- `-100 <= Node.val <= 100`\n- The list is guaranteed to be sorted in ascending order.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is the correct approach to remove duplicates from a sorted linked list, leaving only distinct numbers?",
				"options": [
					"Iterate through the list, using a hash set to track duplicates and remove them.",
					"Use two pointers: one to track the current node and another to skip duplicates.",
					"Sort the list first, then iterate to remove duplicates.",
					"Use a stack to keep track of nodes and pop duplicates."
				],
				"explanation": "The correct approach is to use two pointers. One pointer tracks the current node, and the other skips over duplicates. This method efficiently removes duplicates in a single pass without additional space for a hash set or stack. Sorting is unnecessary since the list is already sorted.",
				"answer": "b",
				"topics": ["Linked List"]
			},
			{
				"question": "Given the following code snippet for removing duplicates from a sorted linked list, which line contains a bug?\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef deleteDuplicates(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    current = head\n    while current:\n        if current.next and current.val == current.next.val:\n            while current.next and current.val == current.next.val:\n                current = current.next\n            prev.next = current.next\n        else:\n            prev = prev.next\n        current = current.next\n    return dummy.next\n```\n",
				"options": [
					"Line 8: prev.next = current.next",
					"Line 10: prev = prev.next",
					"Line 11: current = current.next",
					"Line 5: dummy = ListNode(0)"
				],
				"explanation": "The bug is in line 11: `current = current.next`. After skipping duplicates, `current` should be set to `current.next` only if duplicates were not found. Otherwise, it should be set to `current.next` after updating `prev.next` to skip the duplicates. This ensures that `current` is correctly positioned after duplicates are removed.",
				"answer": "c",
				"topics": ["Linked List", "Implementation Analysis"]
			},
			{
				"question": "Consider the time and space complexity of the following solution for removing duplicates from a sorted linked list:\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef deleteDuplicates(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    current = head\n    while current:\n        if current.next and current.val == current.next.val:\n            while current.next and current.val == current.next.val:\n                current = current.next\n            prev.next = current.next\n        else:\n            prev = prev.next\n        current = current.next\n    return dummy.next\n```\nWhat are the time and space complexities?",
				"options": [
					"Time: O(n), Space: O(1)",
					"Time: O(n^2), Space: O(1)",
					"Time: O(n), Space: O(n)",
					"Time: O(n^2), Space: O(n)"
				],
				"explanation": "The time complexity is O(n) because each node is visited at most twice: once when moving `current` and once when moving `prev`. The space complexity is O(1) because no additional data structures are used that grow with the input size; only a few pointers are maintained.",
				"answer": "a",
				"topics": ["Linked List", "Complexity Analysis"]
			},
			{
				"question": "In the context of removing duplicates from a sorted linked list, which of the following modifications would allow the algorithm to work in-place while maintaining the same time complexity?",
				"options": [
					"Use a hash set to track seen values and remove duplicates.",
					"Modify the list to store both original and processed values in each node.",
					"Use two pointers to track the current node and the last unique node.",
					"Reverse the list first, then remove duplicates."
				],
				"explanation": "Using two pointers to track the current node and the last unique node allows the algorithm to work in-place. This method efficiently removes duplicates without additional space, maintaining O(n) time complexity.",
				"answer": "c",
				"topics": ["Linked List", "Optimization"]
			},
			{
				"question": "Which of the following scenarios would make a heap-based solution for finding the kth largest element more efficient than a QuickSelect algorithm?",
				"options": [
					"Large array size (n > 10⁶), k is close to n/2, elements are randomly distributed",
					"Small array size (n < 10³), k is very small (k < 10), many duplicates present",
					"Medium array size (10⁴ < n < 10⁵), k is close to n, elements are nearly sorted",
					"Large array size (n > 10⁶), k is very small (k < 100), elements are roughly sorted"
				],
				"explanation": "A heap-based solution is more efficient when the array size is large and k is small, as it can maintain a min-heap of size k, leading to O(n log k) time complexity. This is more efficient than QuickSelect's average O(n) time complexity when n is very large and k is small.",
				"answer": "d",
				"topics": ["Heap", "Sorting", "Algorithm Comparison"]
			}
		]
	},
	{
		"slug": "remove-duplicates-from-sorted-list",
		"title": "Remove Duplicates from Sorted List",
		"leetcodeUrl": "https://leetcode.com/problems/remove-duplicates-from-sorted-list",
		"difficulty": "Easy",
		"topics": ["Linked List"],
		"content": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\n\n**Example 1:**\n```\nInput: head = [1,1,2]\nOutput: [1,2]\n```\n\n**Example 2:**\n```\nInput: head = [1,1,2,3,3]\nOutput: [1,2,3]\n```\n\n**Constraints:**\n- The number of nodes in the list is in the range `[0,300]`.\n- `-100 <= Node.val <= 100`\n- The list is guaranteed to be sorted in ascending order.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "What is the time complexity of removing duplicates from a sorted linked list?",
				"options": ["O(n)", "O(n log n)", "O(n^2)", "O(1)"],
				"explanation": "The time complexity is O(n) because we traverse the linked list once, comparing each node with its next node to remove duplicates.",
				"answer": "a",
				"topics": ["Linked List", "Time Complexity"]
			},
			{
				"question": "Given the following code to remove duplicates from a sorted linked list, which line contains a bug?\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef deleteDuplicates(head: ListNode) -> ListNode:\n    current = head\n    while current and current.next:\n        if current.val == current.next.val:\n            current.next = current.next.next\n        else:\n            current = current.next\n    return head\n```\nWhich line contains a bug and why?",
				"options": [
					"Line 5: current = head",
					"Line 7: if current.val == current.next.val:",
					"Line 8: current.next = current.next.next",
					"Line 10: return head"
				],
				"explanation": "The code is correct and does not contain a bug. It correctly iterates through the list, removing duplicates by adjusting the next pointers.",
				"answer": "d",
				"topics": ["Linked List", "Implementation"]
			},
			{
				"question": "In the context of removing duplicates from a sorted linked list, which of the following statements is true?",
				"options": [
					"The algorithm requires additional space proportional to the number of nodes.",
					"The algorithm can be implemented in O(n log n) time using a hash set.",
					"The algorithm modifies the list in place without using extra space.",
					"The algorithm requires sorting the list before removing duplicates."
				],
				"explanation": "The algorithm modifies the list in place without using extra space, as it only requires a single pointer to traverse the list and adjust the next pointers to remove duplicates.",
				"answer": "c",
				"topics": ["Linked List", "Space Complexity"]
			},
			{
				"question": "Consider the following code snippet for removing duplicates from a sorted linked list:\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef deleteDuplicates(head: ListNode) -> ListNode:\n    current = head\n    while current and current.next:\n        if current.val == current.next.val:\n            current.next = current.next.next\n        else:\n            current = current.next\n    return head\n```\nWhat is the space complexity of this algorithm?",
				"options": [
					"O(n) due to recursion stack",
					"O(1) because it uses constant extra space",
					"O(n) due to auxiliary data structures",
					"O(log n) due to iterative depth"
				],
				"explanation": "The space complexity is O(1) because the algorithm uses a constant amount of extra space, only requiring a few pointers to traverse and modify the list.",
				"answer": "b",
				"topics": ["Linked List", "Space Complexity"]
			}
		]
	},
	{
		"slug": "largest-rectangle-in-histogram",
		"title": "Largest Rectangle in Histogram",
		"leetcodeUrl": "https://leetcode.com/problems/largest-rectangle-in-histogram",
		"difficulty": "Hard",
		"topics": ["Array", "Stack"],
		"content": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return the area of the largest rectangle in the histogram.\n\n**Example 1:**\n```\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.\n```\n\n**Example 2:**\n```\nInput: heights = [2,4]\nOutput: 4\n```\n\n**Constraints:**\n- `1 <= heights.length <= 10^5`\n- `0 <= heights[i] <= 10^4`",
		"rating": 2400,
		"MCQs": [
			{
				"question": "Which of the following statements is true about the stack-based approach to solve the \"Largest Rectangle in Histogram\" problem?",
				"options": [
					"The stack is used to store the indices of the histogram bars in decreasing order of their heights.",
					"The stack helps in finding the next smaller element for each bar efficiently.",
					"The stack is used to store the heights of the histogram bars directly.",
					"The stack-based approach has a time complexity of O(n^2) due to nested loops."
				],
				"explanation": "The stack-based approach uses a stack to store the indices of the histogram bars, not the heights, and it helps in efficiently finding the next smaller element for each bar. This approach has a time complexity of O(n) because each bar is pushed and popped from the stack at most once.",
				"answer": "b",
				"topics": ["Array", "Stack"]
			},
			{
				"question": "In the stack-based solution for the \"Largest Rectangle in Histogram\" problem, what is the purpose of adding a zero-height bar at the end of the histogram?",
				"options": [
					"To ensure that all bars are popped from the stack by the end of the iteration.",
					"To handle the case where the histogram is empty.",
					"To simplify the calculation of the maximum area by avoiding edge cases.",
					"To ensure that the stack is never empty during the iteration."
				],
				"explanation": "Adding a zero-height bar at the end of the histogram ensures that all bars are popped from the stack by the end of the iteration, allowing the calculation of the maximum area for all bars.",
				"answer": "a",
				"topics": ["Array", "Stack"]
			},
			{
				"question": "Consider the following code snippet for finding the largest rectangle in a histogram:\n```python\nheights = [2,1,5,6,2,3]\nstack = []\nmax_area = 0\nfor i in range(len(heights) + 1):\n    h = heights[i] if i < len(heights) else 0\n    while stack and heights[stack[-1]] >= h:\n        height = heights[stack.pop()]\n        width = i if not stack else i - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    stack.append(i)\nprint(max_area)\n```\nWhat is the output of this code?",
				"options": ["10", "12", "9", "11"],
				"explanation": "The code correctly implements the stack-based approach to find the largest rectangle in the histogram. The largest rectangle has an area of 10, which is formed by the bars with heights 5 and 6.",
				"answer": "a",
				"topics": ["Array", "Stack"]
			},
			{
				"question": "In the stack-based solution for the \"Largest Rectangle in Histogram\" problem, which line of code is responsible for calculating the width of the rectangle?",
				"options": [
					"`h = heights[i] if i < len(heights) else 0`",
					"`while stack and heights[stack[-1]] >= h:`",
					"`width = i if not stack else i - stack[-1] - 1`",
					"`max_area = max(max_area, height * width)`"
				],
				"explanation": "The line `width = i if not stack else i - stack[-1] - 1` calculates the width of the rectangle by determining the distance between the current index and the index of the last element in the stack.",
				"answer": "c",
				"topics": ["Array", "Stack"]
			},
			{
				"question": "What is the time complexity of the stack-based solution for the \"Largest Rectangle in Histogram\" problem, and why?",
				"options": [
					"O(n^2) because each element can be pushed and popped multiple times.",
					"O(n log n) due to sorting involved in the process.",
					"O(n) because each element is pushed and popped from the stack at most once.",
					"O(n) because the stack operations are amortized over the entire array."
				],
				"explanation": "The time complexity is O(n) because each element is pushed and popped from the stack at most once, making the stack operations amortized over the entire array.",
				"answer": "c",
				"topics": ["Array", "Stack"]
			},
			{
				"question": "Identify the bug in the following code snippet for finding the largest rectangle in a histogram:\n```python\nheights = [2,1,5,6,2,3]\nstack = []\nmax_area = 0\nfor i in range(len(heights)):\n    while stack and heights[stack[-1]] > heights[i]:\n        height = heights[stack.pop()]\n        width = i if not stack else i - stack[-1]\n        max_area = max(max_area, height * width)\n    stack.append(i)\nprint(max_area)\n```\nWhy does it fail for some test cases?",
				"options": [
					"The condition `heights[stack[-1]] > heights[i]` should be `>=` to handle equal heights.",
					"The width calculation `i - stack[-1]` should be `i - stack[-1] - 1`.",
					"The loop should iterate until `len(heights) + 1` to handle all bars.",
					"The `max_area` calculation should include a check for zero heights."
				],
				"explanation": "The width calculation should be `i - stack[-1] - 1` to correctly calculate the width of the rectangle. The current code fails to account for the width correctly when the stack is not empty.",
				"answer": "b",
				"topics": ["Array", "Stack"]
			}
		]
	},
	{
		"slug": "maximal-rectangle",
		"title": "Maximal Rectangle",
		"leetcodeUrl": "https://leetcode.com/problems/maximal-rectangle",
		"difficulty": "Hard",
		"topics": ["Dynamic Programming", "Array", "Stack"],
		"content": "Given a rows x cols binary matrix filled with `0`s and `1`s, find the largest rectangle containing only `1`s and return its area.\n\n**Example 1:**\n```\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.\n```\n\n**Example 2:**\n```\nInput: matrix = [[\"0\"]]\nOutput: 0\n```\n\n**Example 3:**\n```\nInput: matrix = [[\"1\"]]\nOutput: 1\n```\n\n**Constraints:**\n- `rows == matrix.length`\n- `cols == matrix[i].length`\n- `1 <= rows, cols <= 200`\n- `matrix[i][j]` is `'0'` or `'1'`.",
		"rating": 2200,
		"MCQs": [
			{
				"question": "Which of the following approaches is most efficient for solving the Maximal Rectangle problem in a binary matrix?",
				"options": [
					"a) Brute force checking all possible rectangles",
					"b) Dynamic programming with a 2D dp array",
					"c) Using a stack to find the largest rectangle in a histogram for each row",
					"d) Depth-first search to explore all connected components of '1's"
				],
				"explanation": "The most efficient approach for solving the Maximal Rectangle problem is to use a stack to find the largest rectangle in a histogram for each row. This method involves treating each row of the matrix as the base of a histogram and using a stack to efficiently calculate the largest rectangle area for that histogram. This approach leverages the Largest Rectangle in Histogram problem solution, which is optimal for this type of problem.",
				"answer": "c",
				"topics": ["Dynamic Programming", "Array", "Stack"]
			},
			{
				"question": "In the context of the Maximal Rectangle problem, what is the time complexity of the stack-based approach that treats each row as a histogram?",
				"options": ["a) O(n^3)", "b) O(n^2)", "c) O(n * m)", "d) O(n * m^2)"],
				"explanation": "The stack-based approach treats each row of the matrix as a histogram and calculates the largest rectangle for each histogram in O(m) time, where m is the number of columns. Since this is done for each of the n rows, the overall time complexity is O(n * m).",
				"answer": "c",
				"topics": ["Dynamic Programming", "Array", "Stack"]
			},
			{
				"question": "Consider the following code snippet for finding the maximal rectangle in a binary matrix. Identify the bug in the implementation:\n```python\n1. def maximalRectangle(matrix):\n2.     if not matrix:\n3.         return 0\n4.     max_area = 0\n5.     dp = [0] * len(matrix[0])\n6.     for row in matrix:\n7.         for i in range(len(row)):\n8.             dp[i] = dp[i] + 1 if row[i] == '1' else 0\n9.         max_area = max(max_area, largestRectangleArea(dp))\n10.    return max_area\n```\nWhich line contains the bug and why?",
				"options": [
					"a) Line 5: The dp array should be initialized inside the outer loop",
					"b) Line 8: The dp array is not updated correctly for '0's",
					"c) Line 9: The function largestRectangleArea is not defined",
					"d) Line 2: The check for an empty matrix is incorrect"
				],
				"explanation": "The bug is in line 8. The dp array is updated correctly, but the function largestRectangleArea is not defined in the provided code snippet. This function is crucial for calculating the largest rectangle area in a histogram, and its absence will cause a runtime error.",
				"answer": "c",
				"topics": ["Dynamic Programming", "Array", "Stack"]
			},
			{
				"question": "Given the following three solutions for the Maximal Rectangle problem:\nA) Brute force checking all possible rectangles\nB) Dynamic programming with a 2D dp array\nC) Stack-based histogram approach\nWhich solution is most suitable for a matrix with a large number of rows and columns?",
				"options": [
					"a) Solution A, because it is straightforward and easy to implement",
					"b) Solution B, because it uses dynamic programming to optimize calculations",
					"c) Solution C, because it efficiently reduces the problem to a histogram problem",
					"d) None of the above, as all solutions are equally efficient"
				],
				"explanation": "Solution C, the stack-based histogram approach, is most suitable for a matrix with a large number of rows and columns. It efficiently reduces the problem to finding the largest rectangle in a histogram for each row, which can be done in linear time relative to the number of columns, making it more scalable for large matrices compared to the other solutions.",
				"answer": "c",
				"topics": ["Dynamic Programming", "Array", "Stack"]
			},
			{
				"question": "In the stack-based approach to solve the Maximal Rectangle problem, what is the role of the 'heights' array?",
				"options": [
					"a) It stores the cumulative sum of '1's for each column up to the current row",
					"b) It keeps track of the maximum rectangle area found so far",
					"c) It records the number of consecutive '1's in each row",
					"d) It maintains the height of the histogram bars for each column"
				],
				"explanation": "In the stack-based approach, the 'heights' array maintains the height of the histogram bars for each column. As we iterate through each row, we update the heights array to reflect the number of consecutive '1's in each column up to the current row. This allows us to treat each row as the base of a histogram and use a stack to find the largest rectangle area efficiently.",
				"answer": "d",
				"topics": ["Dynamic Programming", "Array", "Stack"]
			}
		]
	},
	{
		"slug": "partition-list",
		"title": "Partition List",
		"leetcodeUrl": "https://leetcode.com/problems/partition-list",
		"difficulty": "Medium",
		"topics": ["Linked List", "Two Pointers"],
		"content": "Given the head of a linked list and a value `x`, partition it such that all nodes less than `x` come before nodes greater than or equal to `x`. You should preserve the original relative order of the nodes in each of the two partitions.\n\n**Example 1:**\n```\nInput: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]\n```\n\n**Example 2:**\n```\nInput: head = [2,1], x = 2\nOutput: [1,2]\n```\n\n**Constraints:**\n- The number of nodes in the list is in the range `[0,200]`.\n- `-100 <= Node.val <= 100`\n- `-200 <= x <= 200`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following statements is true about the partitioning of a linked list around a value x?",
				"options": [
					"The nodes less than x must be in sorted order.",
					"The nodes greater than or equal to x must be in sorted order.",
					"The relative order of nodes in each partition must be preserved.",
					"The partitioning can be done in O(n^2) time complexity."
				],
				"explanation": "The problem requires that the relative order of nodes in each partition is preserved, meaning that the nodes less than x and the nodes greater than or equal to x should maintain their original order from the input list. Sorting is not required, and the partitioning can be done in O(n) time complexity using two pointers.",
				"answer": "c",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "Given the following implementation of partitioning a linked list, which line contains a bug?\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef partition(head, x):\n    before_head = ListNode(0)\n    before = before_head\n    after_head = ListNode(0)\n    after = after_head\n    \n    while head:\n        if head.val < x:\n            before.next = head\n            before = before.next\n        else:\n            after.next = head\n            after = after.next\n        head = head.next\n    \n    after.next = None\n    before.next = after_head.next\n    return before_head.next\n```\n",
				"options": [
					"Line 10: if head.val < x: should be if head.val <= x:",
					"Line 16: after.next = None should be before.next = None",
					"Line 17: before.next = after_head.next should be after.next = before_head.next",
					"Line 18: return before_head.next should be return after_head.next"
				],
				"explanation": "The bug is in line 16: after.next = None should be before.next = None. This line is meant to terminate the 'before' list to prevent a cycle in the linked list. The 'after' list is already terminated by setting after.next = None.",
				"answer": "b",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "Consider the following code snippet for partitioning a linked list. What is the time complexity of this implementation?\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef partition(head, x):\n    before_head = ListNode(0)\n    before = before_head\n    after_head = ListNode(0)\n    after = after_head\n    \n    while head:\n        if head.val < x:\n            before.next = head\n            before = before.next\n        else:\n            after.next = head\n            after = after.next\n        head = head.next\n    \n    after.next = None\n    before.next = after_head.next\n    return before_head.next\n```\n",
				"options": [
					"O(n) because each node is visited once.",
					"O(n^2) because of the nested operations.",
					"O(n log n) due to sorting operations.",
					"O(1) because it uses constant space."
				],
				"explanation": "The time complexity of this implementation is O(n) because each node in the linked list is visited exactly once during the traversal. There are no nested loops or recursive calls that would increase the complexity beyond O(n).",
				"answer": "a",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "In the partitioning of a linked list, which of the following modifications would allow the algorithm to work in-place while maintaining the same time complexity?",
				"options": [
					"Use a single pointer to traverse the list and rearrange nodes in place.",
					"Use two pointers to create two separate lists and then merge them.",
					"Modify the input list to store both original and processed values.",
					"Change the iteration direction to avoid extra storage."
				],
				"explanation": "Using two pointers to create two separate lists and then merge them allows the algorithm to work in-place. This approach maintains the O(n) time complexity and uses O(1) additional space, as the nodes are rearranged without creating new nodes.",
				"answer": "b",
				"topics": ["Linked List", "Two Pointers"]
			},
			{
				"question": "Analyze the space complexity of the following partitioning solution, considering both the auxiliary space and the input list:\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef partition(head, x):\n    before_head = ListNode(0)\n    before = before_head\n    after_head = ListNode(0)\n    after = after_head\n    \n    while head:\n        if head.val < x:\n            before.next = head\n            before = before.next\n        else:\n            after.next = head\n            after = after.next\n        head = head.next\n    \n    after.next = None\n    before.next = after_head.next\n    return before_head.next\n```\n",
				"options": [
					"O(n) due to the creation of new nodes.",
					"O(1) because no new nodes are created, only pointers are rearranged.",
					"O(n^2) because of the nested operations.",
					"O(log n) due to recursive calls."
				],
				"explanation": "The space complexity is O(1) because no new nodes are created; the algorithm only rearranges the pointers of the existing nodes. The auxiliary space used is constant, as it only involves a few additional pointers.",
				"answer": "b",
				"topics": ["Linked List", "Two Pointers"]
			}
		]
	},
	{
		"slug": "scramble-string",
		"title": "Scramble String",
		"leetcodeUrl": "https://leetcode.com/problems/scramble-string",
		"difficulty": "Medium",
		"topics": ["String", "Recursion"],
		"content": "We can scramble a string to get a string `t` using the following algorithm:\n\n1. If the length of the string is `1`, stop.\n2. If the length of the string is > `1`, do the following:\n   - Split the string into two non-empty substrings at a random index, i.e., if the string is `s`, divide it to `x` and `y` where `s = x + y`.\n   - Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `x + y` or `y + x`.\n   - Apply step 1 recursively on each of the two substrings `x` and `y`.\n\nGiven two strings `s1` and `s2` of the same length, return `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`.\n\n**Example 1:**\n```\nInput: s1 = \"great\"\nOutput: true\n```\n\n**Example 2:**\n```\nInput: s1 = \"abcde\"\nOutput: false\n```\n\n**Example 3:**\n```\nInput: s1 = \"a\"\nOutput: true\n```\n\n**Constraints:**\n- `s1.length == s2.length`\n- `1 <= s1.length <= 30`\n- `s1` and `s2` consist of lowercase English letters.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a necessary condition for two strings to be scramble strings of each other?",
				"options": [
					"a) They must have the same length.",
					"b) They must have the same set of characters with the same frequency.",
					"c) They must be anagrams of each other.",
					"d) They must have the same prefix."
				],
				"explanation": "For two strings to be scramble strings of each other, they must have the same set of characters with the same frequency. This is because scrambling involves rearranging the substrings, which does not change the character count. Therefore, option b is correct. Option a is necessary but not sufficient, option c is a restatement of option b, and option d is incorrect as prefixes can change.",
				"answer": "b",
				"topics": ["String", "Recursion"]
			},
			{
				"question": "Given the following recursive function to check if two strings are scramble strings, identify the bug:\n```python\n1. def isScramble(s1, s2):\n2.     if len(s1) != len(s2):\n3.         return False\n4.     if s1 == s2:\n5.         return True\n6.     if sorted(s1) != sorted(s2):\n7.         return False\n8.     n = len(s1)\n9.     for i in range(1, n):\n10.        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n11.           (isScramble(s1[:i], s2[n-i:]) and isScramble(s1[i:], s2[:n-i])):\n12.            return True\n13.    return False\n```",
				"options": [
					"a) Line 6: sorted(s1) != sorted(s2) should be replaced with a frequency check.",
					"b) Line 10: The range should start from 0 instead of 1.",
					"c) Line 11: The second condition should compare s1[i:] with s2[n-i:].",
					"d) Line 12: The return statement should be outside the loop."
				],
				"explanation": "The bug is in line 6. Using sorted(s1) != sorted(s2) is inefficient for large strings. A frequency check would be more optimal. The other options are incorrect because the range should start from 1 to avoid empty substrings, the second condition is correct as is, and the return statement is correctly placed to exit early when a valid scramble is found.",
				"answer": "a",
				"topics": ["String", "Recursion"]
			},
			{
				"question": "Consider the following code snippet for checking if two strings are scramble strings. Which line should be modified to improve its efficiency?\n```python\n1. def isScramble(s1, s2):\n2.     if len(s1) != len(s2):\n3.         return False\n4.     if s1 == s2:\n5.         return True\n6.     if sorted(s1) != sorted(s2):\n7.         return False\n8.     n = len(s1)\n9.     for i in range(1, n):\n10.        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n11.           (isScramble(s1[:i], s2[n-i:]) and isScramble(s1[i:], s2[:n-i])):\n12.            return True\n13.    return False\n```",
				"options": [
					"a) Line 6: Replace sorted(s1) with a character frequency check.",
					"b) Line 9: Change the range to start from 0.",
					"c) Line 10: Use a different recursive strategy.",
					"d) Line 12: Move the return statement outside the loop."
				],
				"explanation": "Line 6 can be improved by replacing sorted(s1) with a character frequency check, which is more efficient than sorting, especially for longer strings. Sorting has a time complexity of O(n log n), while a frequency check can be done in O(n).",
				"answer": "a",
				"topics": ["String", "Recursion"]
			},
			{
				"question": "What is the time complexity of the recursive solution for checking if two strings are scramble strings, assuming no memoization is used?",
				"options": ["a) O(n!)", "b) O(n^3)", "c) O(2^n)", "d) O(n^2)"],
				"explanation": "The time complexity of the recursive solution without memoization is O(n^3). This is because for each of the n possible split points, the function makes two recursive calls, leading to a cubic complexity when considering all possible splits and combinations.",
				"answer": "b",
				"topics": ["String", "Recursion"]
			},
			{
				"question": "In the context of the scramble string problem, which of the following optimizations can reduce the time complexity of the recursive solution?",
				"options": [
					"a) Using a dynamic programming table to store results of subproblems.",
					"b) Sorting the strings before each recursive call.",
					"c) Using a greedy approach to select the best split point.",
					"d) Limiting the recursion depth to half the string length."
				],
				"explanation": "Using a dynamic programming table to store results of subproblems can significantly reduce the time complexity by avoiding redundant calculations. This technique, known as memoization, allows the solution to remember previously computed results, thus reducing the number of recursive calls needed.",
				"answer": "a",
				"topics": ["String", "Recursion"]
			},
			{
				"question": "Which of the following is a correct statement about the scramble string problem?",
				"options": [
					"a) It can be solved in O(n log n) time using a divide and conquer approach.",
					"b) It requires checking all possible permutations of the string.",
					"c) It can be solved using dynamic programming with a time complexity of O(n^3).",
					"d) It is equivalent to checking if two strings are anagrams."
				],
				"explanation": "The scramble string problem can be solved using dynamic programming with a time complexity of O(n^3). This approach involves storing the results of subproblems to avoid redundant calculations, which is more efficient than checking all permutations or using a simple divide and conquer approach.",
				"answer": "c",
				"topics": ["String", "Recursion"]
			}
		]
	},
	{
		"slug": "merge-sorted-array",
		"title": "Merge Sorted Array",
		"leetcodeUrl": "https://leetcode.com/problems/merge-sorted-array",
		"difficulty": "Easy",
		"topics": ["Array", "Two Pointers"],
		"content": "You are given two integer arrays `nums1` and `nums2`, sorted in non-decreasing order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively. Merge `nums1` and `nums2` into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.\n\n**Example 1:**\n```\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n```\n\n**Example 2:**\n```\nInput: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and []. The result of the merge is [1].\n```\n\n**Example 3:**\n```\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1.\n```\n\n**Constraints:**\n- `nums1.length == m + n`\n- `nums2.length == n`\n- `0 <= m, n <= 200`\n- `1 <= m + n <= 200`\n- `-10^9 <= nums1[i], nums2[j] <= 10^9`\n\n**Follow-up:** Can you come up with an algorithm that runs in O(m+n) time?",
		"rating": 1200,
		"MCQs": [
			{
				"question": "Which of the following is the correct approach to merge two sorted arrays `nums1` and `nums2` into `nums1` in-place, given that `nums1` has enough space to hold the elements of both arrays?",
				"options": [
					"a) Use a temporary array to store the merged result and then copy it back to `nums1`.",
					"b) Start merging from the beginning of `nums1` and `nums2` and shift elements in `nums1` to the right as needed.",
					"c) Start merging from the end of `nums1` and `nums2` to avoid shifting elements in `nums1`.",
					"d) Use a stack to keep track of elements from `nums2` and insert them into `nums1`."
				],
				"explanation": "The optimal approach is to start merging from the end of `nums1` and `nums2`. This way, we can place the largest elements at the end of `nums1` without needing to shift elements. This approach ensures that we use the available space in `nums1` efficiently and avoid unnecessary operations.",
				"answer": "c",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Given the following implementation of merging two sorted arrays, identify the bug:\n```python\ndef merge(nums1, m, nums2, n):\n    i, j, k = m - 1, n - 1, m + n - 1\n    while i >= 0 and j >= 0:\n        if nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    while j >= 0:\n        nums1[k] = nums2[j]\n        j -= 1\n        k -= 1\n```\nWhat is the issue with this code?",
				"options": [
					"a) The code does not handle the case when `i` becomes negative before `j`.",
					"b) The code does not handle the case when `j` becomes negative before `i`.",
					"c) The code incorrectly decrements `k` in the wrong loop.",
					"d) The code does not initialize `k` correctly."
				],
				"explanation": "The code correctly handles the merging by comparing elements from the end of `nums1` and `nums2`. The loop `while j >= 0` ensures that any remaining elements in `nums2` are copied to `nums1`. There is no bug in the code as it correctly handles all cases.",
				"answer": "b",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "In the context of merging two sorted arrays, what is the time complexity of the optimal in-place merge algorithm?",
				"options": [
					"a) O(m + n)",
					"b) O(m * n)",
					"c) O(m log n)",
					"d) O(n log m)"
				],
				"explanation": "The optimal in-place merge algorithm iterates through both arrays once, comparing and placing elements in the correct position. This results in a time complexity of O(m + n), where m and n are the lengths of the two arrays.",
				"answer": "a",
				"topics": ["Array", "Two Pointers"]
			},
			{
				"question": "Consider the following scenario: `nums1` is an array of size `m + n` with the first `m` elements sorted, and `nums2` is an array of size `n` sorted. Which of the following statements is true about the space complexity of the in-place merge algorithm?",
				"options": [
					"a) The space complexity is O(m + n) because we need extra space to store the merged array.",
					"b) The space complexity is O(n) because we only need to store elements from `nums2`.",
					"c) The space complexity is O(1) because the merge is done in-place without using extra space.",
					"d) The space complexity is O(m) because we need to store elements from `nums1` temporarily."
				],
				"explanation": "The in-place merge algorithm does not require any additional space beyond the input arrays themselves. It uses the extra space already available in `nums1` to accommodate the elements from `nums2`, resulting in a space complexity of O(1).",
				"answer": "c",
				"topics": ["Array", "Two Pointers"]
			}
		]
	},
	{
		"slug": "gray-code",
		"title": "Gray Code",
		"leetcodeUrl": "https://leetcode.com/problems/gray-code",
		"difficulty": "Medium",
		"topics": ["Bit Manipulation"],
		"content": "An `n`-bit gray code sequence is a sequence of `2^n` integers where:\n\n- Every integer is in the inclusive range `[0, 2^n - 1]`,\n- The first integer is `0`,\n- An integer appears no more than once in the sequence,\n- The binary representation of every pair of adjacent integers differs by exactly one bit, and\n- The binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer `n`, return any valid `n`-bit gray code sequence.\n\n**Example 1:**\n```\nInput: n = 2\nOutput: [0,1,3,2]\nExplanation: The binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\n```\n\n**Example 2:**\n```\nInput: n = 1\nOutput: [0,1]\n```\n\n**Constraints:**\n- `1 <= n <= 16`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following statements is true about the Gray code sequence for a given integer n?",
				"options": [
					"The sequence must start and end with the same integer.",
					"The sequence must contain all integers from 0 to 2^n - 1 in any order.",
					"The sequence must have adjacent integers differing by exactly one bit.",
					"The sequence must be in strictly increasing order."
				],
				"explanation": "The Gray code sequence is defined such that each pair of adjacent integers differs by exactly one bit. This is the key property of Gray code, which is used in various applications like error correction in digital communication.",
				"answer": "c",
				"topics": ["Bit Manipulation"]
			},
			{
				"question": "Given the following implementation of generating an n-bit Gray code sequence, identify the bug:\n```python\n1. def grayCode(n):\n2.     result = [0]\n3.     for i in range(n):\n4.         result += [x + (1 << i) for x in reversed(result)]\n5.     return result\n```\nWhat is the issue with this implementation?",
				"options": [
					"The initial result list should be empty instead of starting with 0.",
					"The loop should iterate from 1 to n instead of 0 to n-1.",
					"The bit shift operation should be (1 << (i+1)) instead of (1 << i).",
					"There is no bug; the implementation correctly generates the Gray code sequence."
				],
				"explanation": "The given implementation correctly generates the Gray code sequence by iteratively reflecting and prefixing the current sequence with a bit shift. The initial result list starts with 0, and the loop correctly iterates from 0 to n-1, applying the bit shift (1 << i) to generate the new sequence. Thus, there is no bug in the implementation.",
				"answer": "d",
				"topics": ["Bit Manipulation"]
			},
			{
				"question": "Consider the following recursive approach to generate an n-bit Gray code sequence:\n```python\n1. def grayCode(n):\n2.     if n == 0:\n3.         return [0]\n4.     prev_gray = grayCode(n-1)\n5.     return prev_gray + [(1 << (n-1)) | x for x in reversed(prev_gray)]\n```\nWhat is the time complexity of this recursive solution?",
				"options": ["O(n)", "O(2^n)", "O(n^2)", "O(n!)"],
				"explanation": "The recursive solution generates the Gray code sequence by first computing the (n-1)-bit sequence and then reflecting and prefixing it. Each recursive call doubles the size of the sequence, leading to a total of 2^n elements being generated. Thus, the time complexity is O(2^n).",
				"answer": "b",
				"topics": ["Bit Manipulation", "Recursion"]
			},
			{
				"question": "In the context of generating Gray code sequences, which of the following methods is most space-efficient?",
				"options": [
					"Iterative method with a list to store the sequence.",
					"Recursive method with memoization.",
					"Using a generator to yield each Gray code number.",
					"Storing the entire sequence in a binary tree structure."
				],
				"explanation": "Using a generator to yield each Gray code number is the most space-efficient method because it does not require storing the entire sequence in memory at once. Instead, it generates each number on-the-fly, reducing space usage significantly compared to other methods that store the entire sequence.",
				"answer": "c",
				"topics": ["Bit Manipulation", "Space Complexity"]
			},
			{
				"question": "Which of the following is a valid Gray code sequence for n = 3?",
				"options": [
					"[0, 1, 3, 2, 6, 7, 5, 4]",
					"[0, 1, 2, 3, 4, 5, 6, 7]",
					"[0, 2, 3, 1, 5, 7, 6, 4]",
					"[0, 4, 6, 2, 3, 7, 5, 1]"
				],
				"explanation": "The sequence [0, 1, 3, 2, 6, 7, 5, 4] is a valid Gray code sequence for n = 3 because each pair of adjacent numbers differs by exactly one bit. The other sequences do not satisfy this property for all adjacent pairs.",
				"answer": "a",
				"topics": ["Bit Manipulation"]
			}
		]
	},
	{
		"slug": "subsets-ii",
		"title": "Subsets II",
		"leetcodeUrl": "https://leetcode.com/problems/subsets-ii",
		"difficulty": "Medium",
		"topics": ["Backtracking", "Array"],
		"content": "Given an integer array `nums` that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.\n\n**Example 1:**\n```\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\n```\n\n**Example 2:**\n```\nInput: nums = [0]\nOutput: [[],[0]]\n```\n\n**Constraints:**\n- `1 <= nums.length <= 10`\n- `-10 <= nums[i] <= 10`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to generate all unique subsets of an array that may contain duplicates?",
				"options": [
					"a) Use a hash set to store subsets and avoid duplicates.",
					"b) Sort the array and use backtracking with a condition to skip duplicates.",
					"c) Use a dynamic programming approach similar to the knapsack problem.",
					"d) Generate all subsets and filter out duplicates at the end."
				],
				"explanation": "The correct approach is to sort the array and use backtracking with a condition to skip duplicates. By sorting the array, we can easily skip over duplicate elements during the backtracking process, ensuring that we do not generate duplicate subsets. This is more efficient than generating all subsets and filtering out duplicates at the end, and it avoids the overhead of using a hash set to store subsets.",
				"answer": "b",
				"topics": ["Backtracking", "Array"]
			},
			{
				"question": "Consider the following code snippet for generating subsets:\n```python\n1. def subsetsWithDup(nums):\n2.     nums.sort()\n3.     result = []\n4.     def backtrack(start, path):\n5.         result.append(path)\n6.         for i in range(start, len(nums)):\n7.             if i > start and nums[i] == nums[i-1]:\n8.                 continue\n9.             backtrack(i + 1, path + [nums[i]])\n10.    backtrack(0, [])\n11.    return result\n```\nWhat is the purpose of the condition on line 7?",
				"options": [
					"a) To ensure that the subsets are generated in lexicographical order.",
					"b) To skip duplicate elements and avoid generating duplicate subsets.",
					"c) To optimize the algorithm by reducing the number of recursive calls.",
					"d) To ensure that the subsets are generated in increasing order of their sums."
				],
				"explanation": "The condition on line 7 checks if the current element is a duplicate of the previous one (after sorting) and skips it if it is. This is crucial for avoiding the generation of duplicate subsets, as it ensures that each unique subset is only generated once.",
				"answer": "b",
				"topics": ["Backtracking", "Array"]
			},
			{
				"question": "Given the following recursive function to generate subsets:\n```python\n1. def generateSubsets(nums):\n2.     nums.sort()\n3.     result = []\n4.     def dfs(index, path):\n5.         result.append(path)\n6.         for i in range(index, len(nums)):\n7.             if i > index and nums[i] == nums[i-1]:\n8.                 continue\n9.             dfs(i + 1, path + [nums[i]])\n10.    dfs(0, [])\n11.    return result\n```\nWhat is the time complexity of this function?",
				"options": ["a) O(n * 2^n)", "b) O(2^n)", "c) O(n^2)", "d) O(n!)"],
				"explanation": "The time complexity of generating all subsets of a set is O(2^n), as each element can either be included or excluded from a subset. However, due to the need to handle duplicates and the additional operations involved in sorting and checking for duplicates, the complexity becomes O(n * 2^n).",
				"answer": "a",
				"topics": ["Backtracking", "Array"]
			},
			{
				"question": "In the context of generating subsets with duplicates, why is it important to sort the input array before applying backtracking?",
				"options": [
					"a) Sorting ensures that the subsets are generated in lexicographical order.",
					"b) Sorting allows us to easily skip duplicates by comparing adjacent elements.",
					"c) Sorting reduces the overall time complexity of the algorithm.",
					"d) Sorting is necessary to use a binary search approach in backtracking."
				],
				"explanation": "Sorting the array allows us to easily identify and skip duplicate elements by comparing adjacent elements. This is crucial for ensuring that we do not generate duplicate subsets, as it allows us to apply a simple condition to skip over duplicates during the backtracking process.",
				"answer": "b",
				"topics": ["Backtracking", "Array"]
			},
			{
				"question": "Which of the following modifications would allow the given backtracking solution to work in-place, reducing space complexity?",
				"options": [
					"a) Use a global variable to store the current path instead of passing it as an argument.",
					"b) Modify the input array to store both original and processed values.",
					"c) Use a single list to store all subsets and backtrack by removing elements.",
					"d) Use a stack to simulate recursion and avoid function call overhead."
				],
				"explanation": "Using a single list to store all subsets and backtracking by removing elements can help reduce space complexity. This approach avoids creating new lists for each recursive call, thus working more in-place. However, it requires careful management of the list to ensure correct backtracking.",
				"answer": "c",
				"topics": ["Backtracking", "Array"]
			}
		]
	},
	{
		"slug": "decode-ways",
		"title": "Decode Ways",
		"leetcodeUrl": "https://leetcode.com/problems/decode-ways",
		"difficulty": "Medium",
		"topics": ["Dynamic Programming", "String"],
		"content": "A message containing letters from `A-Z` can be encoded into numbers using the following mapping:\n`'A' -> \"1\"`\n`'B' -> \"2\"`\n`...`\n`'Z' -> \"26\"`\n\nTo decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106\"` can be mapped into:\n- `\"AAJF\"` with the grouping `(11106)`\n- `\"KJF\"` with the grouping `(11106)`\n\nNote that the grouping `(11106)` is invalid because `\"06\"` cannot be mapped into 'F' since `\"6\"` is different from `\"06\"`.\n\nGiven a string containing only digits, return the number of ways to decode it.\n\n**Example 1:**\n```\nInput: s = \"12\"\nOutput: 2\nExplanation: \"12\" could be decoded as \"AB\" (12) or \"L\" (12).\n```\n\n**Example 2:**\n```\nInput: s = \"226\"\nOutput: 3\nExplanation: \"226\" could be decoded as \"BZ\" (226), \"VF\" (226), or \"BBF\" (226).\n```\n\n**Example 3:**\n```\nInput: s = \"06\"\nOutput: 0\nExplanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\").\n```\n\n**Constraints:**\n- `1 <= s.length <= 100`\n- `s` contains only digits and may contain leading zero(s).",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a valid approach to solve the \"Decode Ways\" problem using dynamic programming?",
				"options": [
					"a) Use a 2D array to store the number of ways to decode each substring.",
					"b) Use a 1D array where each element represents the number of ways to decode the string up to that index.",
					"c) Use a recursive function with memoization to store results of subproblems.",
					"d) Use a greedy algorithm to decide the best way to decode each digit."
				],
				"explanation": "The problem can be efficiently solved using dynamic programming by maintaining a 1D array where each element at index i represents the number of ways to decode the string up to that index. This approach allows us to build the solution incrementally by considering one or two digits at a time, depending on whether they form a valid character mapping. Option c is also valid as it uses memoization to avoid redundant calculations, but option b is the most straightforward dynamic programming approach.",
				"answer": "b",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "In the following implementation of the \"Decode Ways\" problem, which line contains a bug?\n```python\n1. def numDecodings(s):\n2.     if not s or s[0] == '0':\n3.         return 0\n4.     n = len(s)\n5.     dp = [0] * (n + 1)\n6.     dp[0] = 1\n7.     for i in range(1, n + 1):\n8.         if s[i-1] != '0':\n9.             dp[i] += dp[i-1]\n10.        if i > 1 and '10' <= s[i-2:i] <= '26':\n11.            dp[i] += dp[i-2]\n12.    return dp[n]\n```",
				"options": [
					"a) Line 2: if not s or s[0] == '0': because it incorrectly handles empty strings.",
					"b) Line 8: if s[i-1] != '0': because it doesn't account for leading zeros.",
					"c) Line 10: if i > 1 and '10' <= s[i-2:i] <= '26': because it doesn't handle single digit cases correctly.",
					"d) Line 11: dp[i] += dp[i-2] because it may access out of bounds indices."
				],
				"explanation": "The bug is in line 2. The condition `if not s or s[0] == '0':` is correct for handling strings that start with '0', but the explanation for option a is misleading. The actual bug is not present in the code snippet provided; all lines are correct. The code correctly initializes the dp array and updates it based on valid single and double digit decodings.",
				"answer": "a",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "Consider the following recursive solution for the \"Decode Ways\" problem:\n```python\n@lru_cache(None)\ndef decode_ways(s, index):\n    if index == len(s):\n        return 1\n    if s[index] == '0':\n        return 0\n    count = decode_ways(s, index + 1)\n    if index + 1 < len(s) and '10' <= s[index:index+2] <= '26':\n        count += decode_ways(s, index + 2)\n    return count\n```\nWhat is the time and space complexity of this solution?",
				"options": [
					"a) Time: O(2^n), Space: O(n) - due to recursion stack.",
					"b) Time: O(n), Space: O(n) - due to memoization and recursion stack.",
					"c) Time: O(n^2), Space: O(n) - due to memoization storing all subproblems.",
					"d) Time: O(n), Space: O(1) - due to constant space usage."
				],
				"explanation": "The time complexity of the recursive solution with memoization is O(n) because each subproblem is solved only once and stored in the cache. The space complexity is O(n) due to the recursion stack and the memoization cache storing results for each index. The use of `@lru_cache` ensures that we do not recompute results for the same index, making the solution efficient.",
				"answer": "b",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "Which of the following modifications would optimize the space complexity of the dynamic programming solution for \"Decode Ways\" from O(n) to O(1)?",
				"options": [
					"a) Use a rolling array of size 2 to store only the last two states.",
					"b) Use a hash map to store only necessary states.",
					"c) Use a stack to keep track of the last few states.",
					"d) Use a queue to manage the states dynamically."
				],
				"explanation": "To optimize the space complexity from O(n) to O(1), we can use a rolling array of size 2 to store only the last two states. This is because the number of ways to decode a string up to a certain point only depends on the previous two states, allowing us to discard older states and reuse space.",
				"answer": "a",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "Given the following three solutions for the \"Decode Ways\" problem:\nA) Recursive solution with memoization\nB) Iterative dynamic programming solution\nC) Iterative solution with constant space\n\nWhich solution is most efficient in terms of both time and space complexity?",
				"options": [
					"a) Solution A is most efficient because it uses memoization to avoid redundant calculations.",
					"b) Solution B is most efficient because it uses a 1D array to store results, balancing time and space.",
					"c) Solution C is most efficient because it reduces space complexity to O(1) while maintaining O(n) time complexity.",
					"d) All solutions are equally efficient in terms of time complexity, but differ in space complexity."
				],
				"explanation": "Solution C is the most efficient in terms of both time and space complexity. It maintains the O(n) time complexity of the dynamic programming approach while reducing the space complexity to O(1) by using a constant amount of space to store only the necessary states. This makes it optimal for large input sizes where space is a concern.",
				"answer": "c",
				"topics": ["Dynamic Programming", "String"]
			}
		]
	},
	{
		"slug": "reverse-linked-list-ii",
		"title": "Reverse Linked List II",
		"leetcodeUrl": "https://leetcode.com/problems/reverse-linked-list-ii",
		"difficulty": "Medium",
		"topics": ["Linked List"],
		"content": "Given the head of a singly linked list and two integers `left` and `right` where `left <= right`, reverse the nodes of the list from position `left` to position `right`, and return the reversed list.\n\n**Example 1:**\n```\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n```\n\n**Example 2:**\n```\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n```\n\n**Constraints:**\n- The number of nodes in the list is `n`.\n- `1 <= n <= 500`\n- `-500 <= Node.val <= 500`\n- `1 <= left <= right <= n`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Given the following code snippet for reversing a sublist of a linked list:\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseBetween(head, left, right):\n    if not head or left == right:\n        return head\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    for _ in range(left - 1):\n        prev = prev.next\n    reverse_start = prev.next\n    curr = reverse_start.next\n    for _ in range(right - left):\n        reverse_start.next = curr.next\n        curr.next = prev.next\n        prev.next = curr\n        curr = reverse_start.next\n    return dummy.next\n```\nWhich line contains a subtle bug that could cause incorrect behavior for certain inputs?",
				"options": [
					"a) if not head or left == right:",
					"b) prev = dummy",
					"c) reverse_start.next = curr.next",
					"d) curr.next = prev.next"
				],
				"explanation": "The bug is in line c) `reverse_start.next = curr.next`. This line is correct and necessary for the reversal process. However, the subtle bug is actually in the logic of the loop that follows. The loop correctly reverses the sublist, but the condition `for _ in range(right - left):` should be `for _ in range(right - left + 1):` to ensure the entire sublist is reversed. The current condition misses the last node in the sublist.",
				"answer": "c",
				"topics": ["Linked List", "Implementation Analysis"]
			},
			{
				"question": "Consider the following code for reversing a sublist of a linked list:\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseBetween(head, left, right):\n    if not head or left == right:\n        return head\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    for _ in range(left - 1):\n        prev = prev.next\n    reverse_start = prev.next\n    curr = reverse_start.next\n    for _ in range(right - left):\n        reverse_start.next = curr.next\n        curr.next = prev.next\n        prev.next = curr\n        curr = reverse_start.next\n    return dummy.next\n```\nWhat is the time complexity of this algorithm?",
				"options": ["a) O(n)", "b) O(n^2)", "c) O(log n)", "d) O(1)"],
				"explanation": "The time complexity of the algorithm is O(n) because it involves a single pass through the list to reach the `left` position and another pass to reverse the sublist from `left` to `right`. The operations within the loop are constant time, so the overall complexity is linear with respect to the number of nodes in the list.",
				"answer": "a",
				"topics": ["Linked List", "Complexity Analysis"]
			},
			{
				"question": "In the context of reversing a sublist of a linked list, which of the following data structures is most appropriate for maintaining the order of nodes during the reversal process?",
				"options": ["a) Stack", "b) Queue", "c) Deque", "d) Linked List"],
				"explanation": "A linked list is the most appropriate data structure for maintaining the order of nodes during the reversal process because it allows for efficient insertion and deletion of nodes. The reversal can be done in-place without the need for additional data structures like a stack or queue, which would require extra space and operations.",
				"answer": "d",
				"topics": ["Linked List", "Data Structure Selection"]
			},
			{
				"question": "Given the following code snippet for reversing a sublist of a linked list:\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseBetween(head, left, right):\n    if not head or left == right:\n        return head\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    for _ in range(left - 1):\n        prev = prev.next\n    reverse_start = prev.next\n    curr = reverse_start.next\n    for _ in range(right - left):\n        reverse_start.next = curr.next\n        curr.next = prev.next\n        prev.next = curr\n        curr = reverse_start.next\n    return dummy.next\n```\nWhich of the following modifications would allow this function to handle the case where `left` and `right` are at the boundaries of the list?",
				"options": [
					"a) Add a check to ensure `left` is greater than 1",
					"b) Initialize `dummy` with `head` instead of a new node",
					"c) Adjust the loop to iterate `right - left + 1` times",
					"d) Use a stack to store nodes between `left` and `right`"
				],
				"explanation": "The correct modification is c) Adjust the loop to iterate `right - left + 1` times. This ensures that the entire sublist, including the node at position `right`, is reversed. The current loop condition `for _ in range(right - left):` misses the last node in the sublist when `left` and `right` are at the boundaries.",
				"answer": "c",
				"topics": ["Linked List", "Implementation Analysis"]
			},
			{
				"question": "Analyze the space complexity of the following code for reversing a sublist of a linked list:\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseBetween(head, left, right):\n    if not head or left == right:\n        return head\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    for _ in range(left - 1):\n        prev = prev.next\n    reverse_start = prev.next\n    curr = reverse_start.next\n    for _ in range(right - left):\n        reverse_start.next = curr.next\n        curr.next = prev.next\n        prev.next = curr\n        curr = reverse_start.next\n    return dummy.next\n```\nWhat is the space complexity of this algorithm?",
				"options": ["a) O(n)", "b) O(1)", "c) O(log n)", "d) O(n^2)"],
				"explanation": "The space complexity of the algorithm is O(1) because it uses a constant amount of extra space. The algorithm modifies the pointers of the existing nodes in the linked list without using any additional data structures that grow with the input size.",
				"answer": "b",
				"topics": ["Linked List", "Space Complexity"]
			}
		]
	},
	{
		"slug": "restore-ip-addresses",
		"title": "Restore IP Addresses",
		"leetcodeUrl": "https://leetcode.com/problems/restore-ip-addresses",
		"difficulty": "Medium",
		"topics": ["Backtracking"],
		"content": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between `0` and `255` (inclusive) and cannot have leading zeros. For example, `\"0.1.2.201\"` and `\"192.168.1.1\"` are valid IP addresses, but `\"0.011.255.245\"`, `\"192.168.1.312\"` and `\"192.168@1.1\"` are invalid IP addresses.\n\nGiven a string containing only digits, return all possible valid IP addresses that can be formed by inserting dots into `s`. You are not allowed to reorder or remove any digits in `s`. You may return the valid IP addresses in any order.\n\n**Example 1:**\n```\nInput: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]\n```\n\n**Example 2:**\n```\nInput: s = \"0000\"\nOutput: [\"0.0.0.0\"]\n```\n\n**Example 3:**\n```\nInput: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n```\n\n**Constraints:**\n- `1 <= s.length <= 20`\n- `s` consists of digits only.",
		"rating": 1600
	},
	{
		"slug": "binary-tree-inorder-traversal",
		"title": "Binary Tree Inorder Traversal",
		"leetcodeUrl": "https://leetcode.com/problems/binary-tree-inorder-traversal",
		"difficulty": "Medium",
		"topics": ["Tree"],
		"content": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n**Example 1:**\n```\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n```\n\n**Example 2:**\n```\nInput: root = []\nOutput: []\n```\n\n**Example 3:**\n```\nInput: root = [1]\nOutput: [1]\n```\n\n**Constraints:**\n- The number of nodes in the tree is in the range [0,100].\n- `-100 <= Node.val <= 100`.\n\nFollow up: Recursive solution is trivial, could you do it iteratively?",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is the correct iterative approach to perform an inorder traversal on a binary tree?",
				"options": [
					"a) Use a stack to simulate the recursive call stack, pushing nodes as you traverse left.",
					"b) Use a queue to process nodes level by level, similar to breadth-first search.",
					"c) Use a priority queue to always process the smallest node value first.",
					"d) Use a hash map to store visited nodes and avoid revisiting them."
				],
				"explanation": "The correct approach for an iterative inorder traversal is to use a stack. This simulates the recursive call stack by pushing nodes as you traverse left, and then processing nodes as you backtrack and move right. A queue is used for level-order traversal, not inorder. A priority queue is not suitable for tree traversal, and a hash map is unnecessary for this purpose.",
				"answer": "a",
				"topics": ["Tree", "Stack", "Traversal"]
			},
			{
				"question": "Given the following iterative inorder traversal implementation, identify the bug:\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorderTraversal(root):\n    stack, result = [], []\n    current = root\n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left\n        current = stack.pop()\n        result.append(current.val)\n        current = current.right\n    return result\n```\nWhat is the issue with this code?",
				"options": [
					"a) The code does not handle the case when the tree is empty.",
					"b) The code incorrectly appends the node value before popping from the stack.",
					"c) The code does not reset the current node to None after processing.",
					"d) The code does not check if the current node is None before appending to the stack."
				],
				"explanation": "The code correctly handles the inorder traversal by using a stack to simulate the recursive process. It correctly appends the node value after popping from the stack, and it resets the current node to its right child. The code handles an empty tree by returning an empty list. Therefore, there is no bug in this implementation.",
				"answer": "a",
				"topics": ["Tree", "Stack", "Traversal"]
			},
			{
				"question": "Consider the following recursive solution for inorder traversal:\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorderTraversal(root):\n    def inorder(node, result):\n        if node:\n            inorder(node.left, result)\n            result.append(node.val)\n            inorder(node.right, result)\n    result = []\n    inorder(root, result)\n    return result\n```\nWhat is the time complexity of this solution?",
				"options": [
					"a) O(n), where n is the number of nodes in the tree.",
					"b) O(log n), where n is the number of nodes in the tree.",
					"c) O(n^2), where n is the number of nodes in the tree.",
					"d) O(1), as it processes each node in constant time."
				],
				"explanation": "The time complexity of the recursive inorder traversal is O(n), where n is the number of nodes in the tree. This is because each node is visited exactly once, and the operations performed at each node (visiting left, processing the node, visiting right) are constant time operations.",
				"answer": "a",
				"topics": ["Tree", "Recursion", "Complexity"]
			},
			{
				"question": "In the context of binary tree traversal, which of the following statements is true about inorder traversal?",
				"options": [
					"a) Inorder traversal visits nodes in the order: root, left, right.",
					"b) Inorder traversal visits nodes in the order: left, root, right.",
					"c) Inorder traversal visits nodes in the order: left, right, root.",
					"d) Inorder traversal visits nodes in the order: right, root, left."
				],
				"explanation": "Inorder traversal visits nodes in the order: left, root, right. This means it first visits the left subtree, then the root node, and finally the right subtree. This order is particularly useful for binary search trees, as it visits nodes in non-decreasing order.",
				"answer": "b",
				"topics": ["Tree", "Traversal"]
			},
			{
				"question": "Given a binary tree, which of the following scenarios would make an iterative inorder traversal more efficient than a recursive one?",
				"options": [
					"a) When the tree is very deep, potentially causing a stack overflow in a recursive approach.",
					"b) When the tree is perfectly balanced, minimizing the depth of recursion.",
					"c) When the tree has a large number of nodes with only right children.",
					"d) When the tree is sparse, with many null nodes."
				],
				"explanation": "An iterative inorder traversal is more efficient than a recursive one when the tree is very deep, as it avoids the risk of stack overflow that can occur with deep recursion. Iterative methods use an explicit stack, which can handle deeper trees without the limitations of the call stack size.",
				"answer": "a",
				"topics": ["Tree", "Stack", "Recursion"]
			},
			{
				"question": "In the iterative inorder traversal code, which line should be added to handle the case when the tree is empty?\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorderTraversal(root):\n    stack, result = [], []\n    current = root\n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left\n        current = stack.pop()\n        result.append(current.val)\n        current = current.right\n    return result\n```\nWhich line should be added at the beginning of the function?",
				"options": [
					"a) if not root: return []",
					"b) if root is None: return [None]",
					"c) if root is None: return [0]",
					"d) if not root: return [0]"
				],
				"explanation": "To handle the case when the tree is empty, the function should immediately return an empty list if the root is None. This is done by adding the line `if not root: return []` at the beginning of the function.",
				"answer": "a",
				"topics": ["Tree", "Edge Cases", "Traversal"]
			}
		]
	},
	{
		"slug": "unique-binary-search-trees-ii",
		"title": "Unique Binary Search Trees II",
		"leetcodeUrl": "https://leetcode.com/problems/unique-binary-search-trees-ii",
		"difficulty": "Medium",
		"topics": ["Tree", "Dynamic Programming"],
		"content": "Given an integer `n`, return all the structurally unique BST's (binary search trees), which has exactly `n` nodes of unique values from `1` to `n`. Return the answer in any order.\n\n**Example 1:**\n```\nInput: n = 3\nOutput: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n```\n\n**Example 2:**\n```\nInput: n = 1\nOutput: [[1]]\n```\n\n**Constraints:**\n- `1 <= n <= 8`.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to generate all unique BSTs for a given integer n?",
				"options": [
					"Use a recursive function that considers each number as the root and recursively constructs left and right subtrees.",
					"Iterate through all permutations of numbers from 1 to n and construct trees for each permutation.",
					"Use dynamic programming to store results of subproblems and build trees iteratively.",
					"Use a greedy algorithm to always select the middle element as the root."
				],
				"explanation": "The correct approach is to use a recursive function that considers each number as the root and recursively constructs left and right subtrees. This method ensures that all possible combinations of left and right subtrees are considered for each root, leading to all unique BSTs. Iterating through permutations or using a greedy approach would not guarantee all unique structures. Dynamic programming can be used to optimize the recursive approach by storing results of subproblems, but the core idea remains recursive construction.",
				"answer": "a",
				"topics": ["Tree", "Dynamic Programming"]
			},
			{
				"question": "In the recursive solution for generating unique BSTs, which line should replace the ??? to correctly construct the trees?\n```python\ndef generateTrees(n):\n    if n == 0:\n        return []\n    return generate(1, n)\n\ndef generate(start, end):\n    if start > end:\n        return [None]\n    all_trees = []\n    for i in range(start, end + 1):\n        left_trees = generate(start, i - 1)\n        right_trees = generate(i + 1, end)\n        for l in left_trees:\n            for r in right_trees:\n                current_tree = TreeNode(i)\n                current_tree.left = l\n                current_tree.right = r\n                all_trees.append(current_tree)\n    return all_trees\n```\nWhich line should replace the ??? to correctly construct the trees?",
				"options": [
					"return generate(1, n)",
					"return generate(0, n-1)",
					"return generate(1, n+1)",
					"return generate(0, n)"
				],
				"explanation": "The correct line is `return generate(1, n)`. This line initializes the recursive generation of trees with the full range of numbers from 1 to n. The function `generate` is designed to construct trees for any given range, and starting from 1 to n ensures all numbers are considered as potential roots.",
				"answer": "a",
				"topics": ["Tree", "Dynamic Programming"]
			},
			{
				"question": "Consider the time complexity of generating all unique BSTs for a given integer n. Which of the following best describes the time complexity?",
				"options": [
					"O(n!) - factorial time complexity due to permutations of nodes",
					"O(2^n) - exponential time complexity due to recursive tree construction",
					"O(n^2) - quadratic time complexity due to nested loops",
					"O(C_n) - Catalan number time complexity due to unique BST structures"
				],
				"explanation": "The time complexity of generating all unique BSTs is O(C_n), where C_n is the nth Catalan number. This is because the number of unique BSTs that can be formed with n nodes is given by the nth Catalan number, which grows exponentially but is not as large as n!. The recursive construction of trees leads to this complexity.",
				"answer": "d",
				"topics": ["Tree", "Dynamic Programming"]
			},
			{
				"question": "In the context of generating unique BSTs, which of the following statements about space complexity is true?",
				"options": [
					"The space complexity is O(n) due to the recursion stack depth.",
					"The space complexity is O(n^2) due to storing all possible trees.",
					"The space complexity is O(C_n) due to storing all unique BSTs.",
					"The space complexity is O(1) as no additional space is used."
				],
				"explanation": "The space complexity is O(C_n) due to storing all unique BSTs. Each unique BST is stored in memory, and the number of such trees is given by the nth Catalan number, C_n. Additionally, the recursion stack contributes to space usage, but the primary factor is the storage of all trees.",
				"answer": "c",
				"topics": ["Tree", "Dynamic Programming"]
			},
			{
				"question": "Which of the following modifications would optimize the recursive solution for generating unique BSTs by reducing redundant calculations?",
				"options": [
					"Use memoization to store results of subproblems and avoid recalculating them.",
					"Use a greedy approach to always select the middle element as the root.",
					"Iterate through all permutations of numbers from 1 to n and construct trees for each permutation.",
					"Use a stack-based iterative approach to simulate recursion."
				],
				"explanation": "Using memoization to store results of subproblems and avoid recalculating them would optimize the recursive solution. This technique ensures that each subproblem is solved only once, reducing the overall number of recursive calls and improving efficiency. The other options do not effectively reduce redundant calculations in this context.",
				"answer": "a",
				"topics": ["Tree", "Dynamic Programming"]
			}
		]
	},
	{
		"slug": "unique-binary-search-trees",
		"title": "Unique Binary Search Trees",
		"leetcodeUrl": "https://leetcode.com/problems/unique-binary-search-trees",
		"difficulty": "Medium",
		"topics": ["Dynamic Programming", "Tree"],
		"content": "Given an integer `n`, return the number of structurally unique BST's (binary search trees) which has exactly `n` nodes of unique values from `1` to `n`.\n\n**Example 1:**\n```\nInput: n = 3\nOutput: 5\n```\n\n**Example 2:**\n```\nInput: n = 1\nOutput: 1\n```\n\n**Constraints:**\n- `1 <= n <= 19`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "What is the time complexity of the dynamic programming solution to find the number of unique binary search trees for a given integer n?",
				"options": ["O(n^2)", "O(n^3)", "O(2^n)", "O(n!)"],
				"explanation": "The dynamic programming solution involves filling a table where each entry requires summing up previous entries. Specifically, for each i from 1 to n, we calculate the number of unique BSTs by considering each number as the root and multiplying the number of unique BSTs possible with the left and right subtrees. This results in a nested loop structure, leading to a time complexity of O(n^2).",
				"answer": "a",
				"topics": ["Dynamic Programming", "Complexity Analysis"]
			},
			{
				"question": "Given the following recursive solution to calculate the number of unique BSTs:\n```python\ncache = {}\ndef numTrees(n):\n    if n in cache:\n        return cache[n]\n    if n <= 1:\n        return 1\n    total = 0\n    for i in range(1, n + 1):\n        left = numTrees(i - 1)\n        right = numTrees(n - i)\n        total += left * right\n    cache[n] = total\n    return total\n```\nWhat is the main inefficiency in this code?",
				"options": [
					"The use of a cache increases space complexity unnecessarily.",
					"The recursion depth can exceed limits for large n.",
					"The cache is not used effectively, leading to repeated calculations.",
					"The base case is incorrect, causing incorrect results for n = 0."
				],
				"explanation": "The main inefficiency is that the cache is not used effectively, leading to repeated calculations. Although the cache is intended to store results of subproblems, the recursive calls can still recompute values if the cache is not properly utilized. This can be improved by ensuring that all subproblem results are stored and reused efficiently.",
				"answer": "c",
				"topics": ["Dynamic Programming", "Recursion", "Memoization"]
			},
			{
				"question": "In the context of unique binary search trees, which of the following statements is true about the Catalan number sequence?",
				"options": [
					"The nth Catalan number gives the number of unique BSTs with n nodes.",
					"Catalan numbers grow exponentially with n, making them impractical for large n.",
					"Catalan numbers are used to count the number of binary trees, not binary search trees.",
					"The nth Catalan number is always a prime number."
				],
				"explanation": "The nth Catalan number gives the number of unique BSTs with n nodes. Catalan numbers are a sequence of natural numbers that have found applications in various counting problems, including counting the number of unique BSTs. They do not grow exponentially, and they are not always prime numbers.",
				"answer": "a",
				"topics": ["Dynamic Programming", "Combinatorics"]
			},
			{
				"question": "Consider the following code snippet for calculating the number of unique BSTs:\n```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0], dp[1] = 1, 1\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        return dp[n]\n```\nWhat is the purpose of the inner loop in this implementation?",
				"options": [
					"To calculate the number of unique BSTs for each subtree size.",
					"To initialize the base cases for the dynamic programming table.",
					"To iterate over all possible root nodes for the current tree size.",
					"To ensure that the dynamic programming table is filled in order."
				],
				"explanation": "The inner loop iterates over all possible root nodes for the current tree size i. For each root node j, it calculates the number of unique BSTs by multiplying the number of unique BSTs possible with the left and right subtrees, which are determined by the sizes j-1 and i-j, respectively. This is a key step in the dynamic programming approach to solving the problem.",
				"answer": "c",
				"topics": ["Dynamic Programming", "Implementation"]
			},
			{
				"question": "Which of the following modifications would optimize the space complexity of the dynamic programming solution for unique BSTs from O(n) to O(1)?",
				"options": [
					"Use a single variable to store the result instead of an array.",
					"Use a rolling array technique to store only the last two results.",
					"Store results in a hash map instead of a list.",
					"Calculate results recursively without storing intermediate results."
				],
				"explanation": "Using a rolling array technique to store only the last two results can optimize the space complexity from O(n) to O(1). This is because each entry in the dynamic programming table only depends on the previous entries, allowing us to reuse space efficiently.",
				"answer": "b",
				"topics": ["Dynamic Programming", "Space Optimization"]
			}
		]
	},
	{
		"slug": "interleaving-string",
		"title": "Interleaving String",
		"leetcodeUrl": "https://leetcode.com/problems/interleaving-string",
		"difficulty": "Medium",
		"topics": ["Dynamic Programming", "String"],
		"content": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an interleaving of `s1` and `s2`. An interleaving of two strings `s` and `t` is a configuration where `s` and `t` are divided into `n` and `m` substrings respectively, such that:\n\n    `s = s1 + s2 + ... + sn`\n    `t = t1 + t2 + ... + tm`\n    `|n - m| <= 1`\n\nThe interleaving is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\nNote: `a + b` is the concatenation of strings `a` and `b`.\n\n**Example 1:**\n```\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\nOutput: true\nExplanation: One way to obtain `s3` is: Split `s1` into `s1 = \"aa\" + \"bc\" + \"c\"`, and `s2` into `s2 = \"dbbc\" + \"a\"`. Interleaving the two splits, we get `\"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\"`. Since `s3` can be obtained by interleaving `s1` and `s2`, we return true.\n```\n\n**Example 2:**\n```\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\nOutput: false\nExplanation: Notice how it is impossible to interleave `s2` with any other string to obtain `s3`.\n```\n\n**Example 3:**\n```\nInput: s1 = \"\", s2 = \"\", s3 = \"\"\nOutput: true\n```\n\n**Constraints:**\n- `0 <= s1.length, s2.length <= 100`\n- `0 <= s3.length <= 200`\n- `s1`, `s2`, and `s3` consist of lowercase English letters.",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a necessary condition for `s3` to be an interleaving of `s1` and `s2`?",
				"options": [
					"a) The length of `s3` must be equal to the sum of the lengths of `s1` and `s2`.",
					"b) `s3` must start with the first character of `s1`.",
					"c) `s3` must end with the last character of `s2`.",
					"d) `s3` must contain all characters of `s1` in order."
				],
				"explanation": "For `s3` to be an interleaving of `s1` and `s2`, the total number of characters in `s3` must be equal to the sum of the characters in `s1` and `s2`. This is because interleaving involves using all characters from both strings without omission.",
				"answer": "a",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "Consider the following implementation for checking if `s3` is an interleaving of `s1` and `s2`:\n```python\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\n        return dp[len(s1)][len(s2)]\n```\nWhich line contains a potential bug that could lead to incorrect results?",
				"options": [
					"a) dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]",
					"b) dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]",
					"c) dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])",
					"d) if len(s1) + len(s2) != len(s3): return False"
				],
				"explanation": "The potential bug is in line c) where the index for `s3` should be `i+j-1`. This is correct as it accounts for the total number of characters considered from both `s1` and `s2` up to that point. The line is correct, but it is the most complex part of the code where errors are likely to occur.",
				"answer": "c",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "Given the following three solutions for checking if `s3` is an interleaving of `s1` and `s2`:\nA) Recursive solution with memoization\nB) Dynamic programming with a 2D table\nC) Dynamic programming with a 1D table\nWhich solution is likely to use the least amount of space while maintaining optimal time complexity?",
				"options": [
					"a) Solution A",
					"b) Solution B",
					"c) Solution C",
					"d) All solutions use the same amount of space"
				],
				"explanation": "Solution C, which uses a 1D table, is likely to use the least amount of space. This is because it optimizes the space usage by only keeping track of the current and previous states, rather than maintaining a full 2D table as in Solution B.",
				"answer": "c",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "In the context of dynamic programming, what is the time complexity of the 2D table approach for checking if `s3` is an interleaving of `s1` and `s2`?",
				"options": ["a) O(n + m)", "b) O(n * m)", "c) O(n^2)", "d) O(m^2)"],
				"explanation": "The time complexity of the 2D table approach is O(n * m), where n is the length of `s1` and m is the length of `s2`. This is because we fill a table of size (n+1) by (m+1), and each cell computation takes constant time.",
				"answer": "b",
				"topics": ["Dynamic Programming", "String"]
			},
			{
				"question": "Consider the following recursive solution with memoization for checking if `s3` is an interleaving of `s1` and `s2`:\n```python\nfrom functools import lru_cache\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        @lru_cache(None)\n        def dfs(i, j, k):\n            if k == len(s3):\n                return i == len(s1) and j == len(s2)\n            if i < len(s1) and s1[i] == s3[k] and dfs(i+1, j, k+1):\n                return True\n            if j < len(s2) and s2[j] == s3[k] and dfs(i, j+1, k+1):\n                return True\n            return False\n        return dfs(0, 0, 0)\n```\nWhat is the time complexity of this solution?",
				"options": [
					"a) O(2^(n+m))",
					"b) O(n * m)",
					"c) O(n + m)",
					"d) O(n^2 + m^2)"
				],
				"explanation": "The time complexity of the recursive solution with memoization is O(n * m), where n is the length of `s1` and m is the length of `s2`. This is because the memoization ensures that each state (i, j) is computed at most once, leading to a total of n * m states.",
				"answer": "b",
				"topics": ["Dynamic Programming", "String"]
			}
		]
	},
	{
		"slug": "validate-binary-search-tree",
		"title": "98. Validate Binary Search Tree",
		"leetcodeUrl": "https://leetcode.com/problems/validate-binary-search-tree",
		"difficulty": "Medium",
		"topics": ["Tree", "Depth-First Search"],
		"content": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n- The left subtree of a node contains only nodes with keys less than the node's key.\n- The right subtree of a node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees must also be binary search trees.\n\n**Example 1:**\n```\nInput: root = [2,1,3]\nOutput: true\n```\n\n**Example 2:**\n```\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n```\n\n**Constraints:**\n- The number of nodes in the tree is in the range `[1, 10^4]`.\n- `-2^31 <= Node.val <= 2^31 - 1`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a necessary condition for a binary tree to be a valid Binary Search Tree (BST)?",
				"options": [
					"All nodes in the left subtree have values less than the root node.",
					"All nodes in the right subtree have values greater than the root node.",
					"Both left and right subtrees must also be valid BSTs.",
					"All of the above."
				],
				"explanation": "A valid BST must satisfy all the given conditions: the left subtree must have all nodes with values less than the root, the right subtree must have all nodes with values greater than the root, and both subtrees must themselves be valid BSTs.",
				"answer": "d",
				"topics": ["Tree", "Binary Search Tree"]
			},
			{
				"question": "Given the following code snippet for validating a BST, which line contains a bug?\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidBST(root):\n    def validate(node, low=-float('inf'), high=float('inf')):\n        if not node:\n            return True\n        if node.val <= low or node.val >= high:\n            return False\n        return (validate(node.left, low, node.val) and\n                validate(node.right, node.val, high))\n    return validate(root)\n```\nWhich line contains the bug and why does it still pass many test cases?",
				"options": [
					"Line 8: if node.val <= low or node.val >= high: because it should use strict inequality.",
					"Line 9: return False because it should return True.",
					"Line 10: return (validate(node.left, low, node.val) and because it should swap low and high.",
					"Line 11: validate(node.right, node.val, high)) because it should use node.val + 1."
				],
				"explanation": "The code is correct as it is. The condition in line 8 uses strict inequality, which is necessary to ensure that no duplicate values are allowed in the BST. The function correctly checks the left and right subtrees with updated bounds.",
				"answer": "a",
				"topics": ["Tree", "Depth-First Search"]
			},
			{
				"question": "Consider the following tree traversal for validating a BST. Which traversal method is most appropriate and why?\n\n1. In-order traversal\n2. Pre-order traversal\n3. Post-order traversal\n4. Level-order traversal",
				"options": [
					"In-order traversal because it visits nodes in non-decreasing order for a valid BST.",
					"Pre-order traversal because it checks the root before subtrees.",
					"Post-order traversal because it checks subtrees before the root.",
					"Level-order traversal because it processes nodes level by level."
				],
				"explanation": "In-order traversal is most appropriate for validating a BST because it visits nodes in non-decreasing order if the tree is a valid BST. This property can be used to easily verify the BST property by checking if the sequence of visited nodes is sorted.",
				"answer": "a",
				"topics": ["Tree", "Binary Search Tree"]
			},
			{
				"question": "Given a binary tree with n nodes, what is the time complexity of validating whether it is a BST using the recursive approach?",
				"options": [
					"O(n log n) because each node is visited multiple times.",
					"O(n) because each node is visited exactly once.",
					"O(n^2) because each node is compared with all other nodes.",
					"O(log n) because the tree is balanced."
				],
				"explanation": "The time complexity is O(n) because each node is visited exactly once during the traversal. The recursive function checks each node and its subtrees, ensuring that the BST properties are maintained.",
				"answer": "b",
				"topics": ["Tree", "Depth-First Search"]
			},
			{
				"question": "In the context of validating a BST, which of the following modifications would optimize the space complexity of the recursive solution?",
				"options": [
					"Use an iterative approach with a stack to avoid recursion stack space.",
					"Store visited nodes in a hash set to avoid revisiting.",
					"Use a queue instead of recursion to manage nodes.",
					"Implement tail recursion to optimize stack usage."
				],
				"explanation": "Using an iterative approach with a stack can optimize space complexity by avoiding the additional space used by the recursion stack. This is particularly useful for deep trees where the recursion depth could be large.",
				"answer": "a",
				"topics": ["Tree", "Depth-First Search"]
			}
		]
	},
	{
		"slug": "recover-binary-search-tree",
		"title": "Recover Binary Search Tree",
		"leetcodeUrl": "https://leetcode.com/problems/recover-binary-search-tree",
		"difficulty": "Medium",
		"topics": ["Tree", "Depth-First Search"],
		"content": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.\n\n**Example 1:**\n```\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n```\n\n**Example 2:**\n```\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n```\n\n**Constraints:**\n- The number of nodes in the tree is in the range [2,1000].\n- `-231 <= Node.val <= 231 - 1`",
		"rating": 1600,
		"MCQs": [
			{
				"question": "Which of the following is a correct approach to recover a binary search tree where two nodes have been swapped?",
				"options": [
					"Perform an in-order traversal to find the two nodes and swap their values.",
					"Use a breadth-first search to identify the misplaced nodes and swap them.",
					"Sort the tree nodes and reconstruct the tree from the sorted list.",
					"Perform a post-order traversal to find the two nodes and swap their values."
				],
				"explanation": "The correct approach is to perform an in-order traversal of the tree. In a valid BST, an in-order traversal should produce a sorted list of values. By performing this traversal, we can identify the two nodes that are out of order. Once identified, we can swap their values to restore the BST property. Breadth-first and post-order traversals are not suitable for this problem because they do not naturally produce a sorted order of values in a BST.",
				"answer": "a",
				"topics": ["Tree", "Depth-First Search"]
			},
			{
				"question": "Given the following in-order traversal of a BST with two swapped nodes: [1, 3, 2, 4, 5], which nodes are swapped?",
				"options": [
					"Nodes with values 3 and 2",
					"Nodes with values 1 and 3",
					"Nodes with values 2 and 4",
					"Nodes with values 1 and 5"
				],
				"explanation": "In a correct in-order traversal of a BST, the values should be in ascending order. The sequence [1, 3, 2, 4, 5] is not sorted because 3 is greater than 2, which indicates that these two nodes are swapped. By swapping 3 and 2, the sequence becomes [1, 2, 3, 4, 5], which is sorted.",
				"answer": "a",
				"topics": ["Tree", "Depth-First Search"]
			},
			{
				"question": "Consider the following code snippet for recovering a BST:\n```python\nclass Solution:\n    def recoverTree(self, root: TreeNode) -> None:\n        def inorder(node):\n            if not node:\n                return\n            inorder(node.left)\n            if self.prev and self.prev.val > node.val:\n                if not self.first:\n                    self.first = self.prev\n                self.second = node\n            self.prev = node\n            inorder(node.right)\n\n        self.first = self.second = self.prev = None\n        inorder(root)\n        ???\n```\nWhat should replace the ??? to correctly recover the tree?",
				"options": [
					"self.first.val, self.second.val = self.second.val, self.first.val",
					"self.first, self.second = self.second, self.first",
					"self.first.val, self.second.val = self.first.val, self.second.val",
					"self.first.val, self.second.val = self.second.val + self.first.val, self.first.val - self.second.val"
				],
				"explanation": "To recover the tree, we need to swap the values of the two nodes that were identified as being out of order. The correct line to swap the values is `self.first.val, self.second.val = self.second.val, self.first.val`. This line correctly swaps the values of the two nodes, restoring the BST property.",
				"answer": "a",
				"topics": ["Tree", "Depth-First Search"]
			},
			{
				"question": "In the context of recovering a binary search tree, what is the time complexity of the in-order traversal approach?",
				"options": ["O(n log n)", "O(n)", "O(n^2)", "O(log n)"],
				"explanation": "The time complexity of performing an in-order traversal on a binary search tree is O(n), where n is the number of nodes in the tree. This is because each node is visited exactly once during the traversal.",
				"answer": "b",
				"topics": ["Tree", "Depth-First Search"]
			},
			{
				"question": "What is the space complexity of the in-order traversal approach for recovering a binary search tree, assuming the tree is balanced?",
				"options": ["O(n)", "O(log n)", "O(1)", "O(n log n)"],
				"explanation": "The space complexity of the in-order traversal approach is O(log n) for a balanced binary search tree. This is because the space required is proportional to the height of the tree, which is log n for a balanced tree. The space is used by the recursion stack during the traversal.",
				"answer": "b",
				"topics": ["Tree", "Depth-First Search"]
			}
		]
	},
	{
		"slug": "same-tree",
		"title": "Same Tree",
		"leetcodeUrl": "https://leetcode.com/problems/same-tree",
		"difficulty": "Easy",
		"topics": ["Tree", "Depth-First Search"],
		"content": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n**Example 1:**\n```\nInput: p = [1,2,3]\nOutput: true\n```\n\n**Example 2:**\n```\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n```\n\n**Example 3:**\n```\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n```\n\n**Constraints:**\n- The number of nodes in both trees is in the range `[0,100]`.\n- `-10^4 <= Node.val <= 10^4`.",
		"rating": 1200,
		"MCQs": [
			{
				"question": "Which of the following is the correct time complexity for checking if two binary trees are the same?",
				"options": [
					"O(n) where n is the number of nodes in the larger tree",
					"O(n^2) where n is the number of nodes in the larger tree",
					"O(log n) where n is the number of nodes in the larger tree",
					"O(1) because it only checks the root nodes"
				],
				"explanation": "The time complexity for checking if two binary trees are the same is O(n), where n is the number of nodes in the larger tree. This is because in the worst case, we need to visit every node in both trees to ensure they are identical.",
				"answer": "a",
				"topics": ["Tree", "Depth-First Search"]
			},
			{
				"question": "Consider the following implementation for checking if two binary trees are the same:\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isSameTree(p, q):\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n```\nWhich of the following test cases would cause this function to return False?",
				"options": [
					"p = [1,2,3], q = [1,2,3]",
					"p = [1,2], q = [1,null,2]",
					"p = [1,2,1], q = [1,1,2]",
					"p = [1], q = [1]"
				],
				"explanation": "The function returns False if the trees are not structurally identical or if any corresponding nodes have different values. For the test case p = [1,2], q = [1,null,2], the trees are not structurally identical, so the function returns False.",
				"answer": "b",
				"topics": ["Tree", "Depth-First Search"]
			},
			{
				"question": "Given the following code snippet for checking if two binary trees are the same, identify the bug:\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isSameTree(p, q):\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n    return isSameTree(p.left, q.right) and isSameTree(p.right, q.left)\n```\nWhich line contains the bug and why does it still pass some test cases?",
				"options": [
					"Line 8: if not p and not q: because it should check for None separately",
					"Line 10: if p.val != q.val: because it should compare values differently",
					"Line 12: return isSameTree(p.left, q.right) and isSameTree(p.right, q.left): because it incorrectly swaps left and right",
					"Line 6: def isSameTree(p, q): because it should handle empty trees differently"
				],
				"explanation": "The bug is in line 12, where it incorrectly swaps left and right subtrees in the recursive call. It should be `return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)`. It still passes some test cases where the trees are symmetric or have only one node.",
				"answer": "c",
				"topics": ["Tree", "Depth-First Search"]
			},
			{
				"question": "In the context of checking if two binary trees are the same, which of the following data structures is most appropriate for an iterative solution?",
				"options": ["Stack", "Queue", "Priority Queue", "Hash Map"],
				"explanation": "A stack is most appropriate for an iterative solution to check if two binary trees are the same. This is because a stack can be used to simulate the recursive depth-first traversal of the trees, allowing us to compare nodes in a last-in, first-out manner.",
				"answer": "a",
				"topics": ["Tree", "Depth-First Search"]
			},
			{
				"question": "Consider the following iterative solution for checking if two binary trees are the same:\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isSameTree(p, q):\n    stack = [(p, q)]\n    while stack:\n        node1, node2 = stack.pop()\n        if not node1 and not node2:\n            continue\n        if not node1 or not node2:\n            return False\n        if node1.val != node2.val:\n            return False\n        stack.append((node1.left, node2.left))\n        stack.append((node1.right, node2.right))\n    return True\n```\nWhat is the space complexity of this solution?",
				"options": [
					"O(n) where n is the number of nodes in the larger tree",
					"O(log n) where n is the height of the tree",
					"O(1) because it uses a fixed amount of space",
					"O(n^2) because it stores all nodes in the stack"
				],
				"explanation": "The space complexity of this solution is O(n), where n is the number of nodes in the larger tree. This is because in the worst case, the stack could store all nodes of the tree if the tree is completely unbalanced.",
				"answer": "a",
				"topics": ["Tree", "Depth-First Search"]
			}
		]
	}
]
